<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TunnelZainer_Web</title>
    <style>
        html, body {
            margin : 0;
            height : 100%
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }

        #button {
            position: absolute;
            left: 5px;
            bottom: 5px;
            padding: 10px;
            background: #11ffee00;
            color: #2FA1D6;
            border: #11ffee00;
            cursor: pointer;
        }
        
        #button:hover {
            background: #444;
        }        

        /* Add a black background color to the top navigation */
            .topnav {
            position: absolute;
            background-color: #000000;
            overflow: hidden;
        }
        
        /* Style the links inside the navigation bar */
        .topnav a {
            float: left;
            color: #f2f2f2;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
            font-size: 12px;
        }
        
        /* Change the color of links on hover */
        .topnav a hover {
            background-color: #ddd;
            color: black;
        }
        
        /* Add a color to the active/current link */
        .topnav a.active {
            background-color: #2FA1D6;
            color: white;
        }
                
    </style>
</head>
<body>

    <div class="topnav">
        <a href='TZ_Web1.html'>1. 도로횡단</a>
        <a href='TZ_Web2.html'>2. 터널단면</a>
        <a class="active" href='TZ_Web3.html'>3. 지보패턴</a>
        <a href='TZ_Web4.html'>4. 강지보공</a>
        <a href='TZ_Web5.html'>5. 라이닝구조도</a>
        <a href='TZ_Web6.html'>6. 배수계획</a>
        <a href='TZ_Web7.html'>7. 연결통로</a>
        <a href='TZ_Web8.html'>8. 갱문형식</a>
        <a href='TZ_Web9.html'>9. 부대시설</a>
    </div>
    
    <canvas id="c"></canvas>
    
    <button id="button" type="button" >Export Model</button>    
    
    <script type="module">
        
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js';
        import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';
        import { GUI } from 'https://Lee-hoseong.github.io/jsm/libs/dat.gui.module.js';
        import { GLTFExporter } from 'https://Lee-hoseong.github.io/jsm/exporters/GLTFExporter.js';
        

        // Matrix 선언
        const matrix = new THREE.Matrix4();


        // 메쉬컨테이너
        let showContainer = [];


        // Three js 기본변수
        let camera, scene, renderer


        // 계산값 불러오기
        const roadWidth = JSON.parse( sessionStorage.getItem( '도로폭' ) );
        const shoulderLeft = JSON.parse( sessionStorage.getItem( '좌측길어깨폭' ) );
        const shoulderRight = JSON.parse( sessionStorage.getItem( '우측길어깨폭' ) );

        const crossSlopeMin = JSON.parse( sessionStorage.getItem( '최소편경사' ) );
        const crossSlopeMax = JSON.parse( sessionStorage.getItem( '최대편경사' ) );

        const concrete = JSON.parse( sessionStorage.getItem( '콘크리트포장두께' ) );
        const cementeFilter = JSON.parse( sessionStorage.getItem( '필터층포장두께' ) );

        const liningT0 = JSON.parse( sessionStorage.getItem('라이닝두께') );

        const roadCenterDistance = JSON.parse( sessionStorage.getItem('이격거리(최종)' ) );

        const r1ThetaLt= JSON.parse( sessionStorage.getItem('중심각좌측' ) );
        const r1ThetaRt = JSON.parse( sessionStorage.getItem('중심각우측' ) );
        const r1Height = JSON.parse( sessionStorage.getItem('r1중심고' ) );
        const r1Final = JSON.parse( sessionStorage.getItem('r1반지름' ) );

        const r2Origin = JSON.parse( sessionStorage.getItem('r2원점' ) );
        const r2Final = JSON.parse( sessionStorage.getItem('r2반지름' ) );

        const r3Origin = JSON.parse( sessionStorage.getItem('r3원점' ) );
        const r3Final = JSON.parse( sessionStorage.getItem('r3반지름' ) );

        const r4Origin = JSON.parse( sessionStorage.getItem('r4원점' ) );
        const r4Final = JSON.parse( sessionStorage.getItem('r4반지름' ) );

        const r5Origin = JSON.parse( sessionStorage.getItem('r5원점' ) );
        const r5Final = JSON.parse( sessionStorage.getItem('r5반지름' ) );


        const footingType = JSON.parse( sessionStorage.getItem('공동구타입' ) );
        const footingHeight = JSON.parse( sessionStorage.getItem('공동구높이' ) );
        const footingLtType = JSON.parse( sessionStorage.getItem('좌측공동구' ) );
        const footingRtType = JSON.parse( sessionStorage.getItem('우측공동구' ) );

        const marginLeft = JSON.parse( sessionStorage.getItem('좌측측대(최종)' ) );
        const marginRight = JSON.parse( sessionStorage.getItem('우측측대(최종)' ) );

        const crossSlopeStandard = JSON.parse( sessionStorage.getItem('적용편경사' ) );

        const ventilation = JSON.parse( sessionStorage.getItem('환기타입' ) );

        const bracketCase = JSON.parse( sessionStorage.getItem( '브라켓케이스' ) );
        const bracketLtPts = JSON.parse( sessionStorage.getItem( '브라켓좌측점' ) );
        const bracketRtPts = JSON.parse( sessionStorage.getItem( '브라켓우측점' ) );
        const bracketLtAngle = JSON.parse( sessionStorage.getItem( '브라켓좌측각도' ) );
        const bracketRtAngle = JSON.parse( sessionStorage.getItem( '브라켓우측각도' ) );
        const ductslabPts = JSON.parse( sessionStorage.getItem( '슬래브') );


        // 파라메트릭 값
        const ui = {

            // 적용 편경사
            crossSlopeStandard : crossSlopeStandard,

            // 적용 연장
            totalLength : 10,

            //스프링라인
            springLineEL : 1.500,    

            //굴진장, 지보장
            longSpacing : 2.000, // (longitudinalSpacing)
            
            //숏크리트 두께
            shotcrete : 0.120,
            
            //록볼트
            rbZone : '전단면',            
            rbLength : 3.000,
            rbCircSpacing : 1.500, // (Circumferential Spacing)
            rbLtLastDel : false,
            rbRtLastDel : false,
            
            //강지보타입
            latticegirderType : 'LG-50',
            
            //보조공법
            auxiliaryMethod : '없음',
            division : '갱구부',
            auxiliaryZone : '120도'
            
        };


        // Run        
        initGraphic();
        designTunnel();
        createUI();
        

        function initGraphic() {
            
            const canvas = document.querySelector('#c'); 
            
            // camera(필수)

            // // Perspective
            // camera = new THREE.PerspectiveCamera( 50, 2, 0.1, 1000 ); //화각, 2, 가까운면, 먼쪽면
            // camera.position.set( -7, 7, 15 );             
            

            // Orthographic
            camera = new THREE.OrthographicCamera( 
                window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.1, 1000 
            ); //left. right, top, bottom, near, far 
            camera.zoom = 20
            camera.position.set( 0, 0, 60 ); 
            
            

            // OrbitControl : 뷰 확대 및 회전
            const controls = new OrbitControls( camera, canvas );
            // controls.target.set( 0, 3, 0 );
            controls.target.set( 0, 0, 0 );
            controls.update();
            

            // Scene(필수) : 컨테이너
            scene = new THREE.Scene();               
            scene.background = new THREE.Color( 0xf0f0f0 );
            

            // 바닥면 : 그림자를 받기 위함
            const planeGeometry = new THREE.PlaneBufferGeometry( 100, 100 );
            planeGeometry.rotateX( - Math.PI/2 );
            const planeMaterial = new THREE.ShadowMaterial( { opacity: 0.3 } );
            const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            plane.position.y = -1.999;
            plane.receiveShadow = true;
            scene.add( plane );
            

            // 바닥 그리드
            const size = 30;
            const divisions = 30;
            const gridHelper = new THREE.GridHelper( size, divisions );
            gridHelper.position.y = - 2;
            gridHelper.material.opacity = 0.4;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            

            // 좌표축 생성, x축:red, y축:green, z축:blue
            const axes = new THREE.AxesHelper(1); 
            scene.add( axes );
            

            // light(필수) : AmbientLight는 그림자와 상관없음     
            scene.add( new THREE.AmbientLight( 0xf0f0f0, 1 ) );
            
            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.1 );
            directionalLight.position.set( 3, 40, 0 );
            directionalLight.target.position.set(-5, 0, 0);
            directionalLight.castShadow = true;
            scene.add( directionalLight );
            scene.add( directionalLight.target );
            
            // light helper
            const lightHelper = new THREE.DirectionalLightHelper( directionalLight, 10 );
            scene.add( lightHelper );            
            
            function updateLight() {
                directionalLight.target.updateMatrixWorld();
                lightHelper.update();
            }

            updateLight();            

            // Render
            renderer = new THREE.WebGLRenderer( { canvas } );
            renderer.physicallyCorrectLights = true
            renderer.shadowMap.enabled = true;
            
        }
        


        function designTunnel() {
            
            // 이전 메쉬 삭제
            showContainer.forEach( i => scene.remove( i ) )

            // 배열초기화
            showContainer = [];

            // 1cycle, 2cycle
            const cycle1Group = new THREE.Group();
            const cycle2Group = new THREE.Group();
            const cycle3Group = new THREE.Group(); // 나머지 길이
            const cycle4Group = new THREE.Group(); // 나머지 길이

            // 나머지 cycle의 길이
            const remainderLength = ui.totalLength % ui.longSpacing

            // 콘크리트포장과 시멘트필터층
            const concreteLt = new THREE.Vector3( - roadCenterDistance - marginLeft, ( - roadCenterDistance - marginLeft ) * ui.crossSlopeStandard / 100 );
            const concreteRt = new THREE.Vector3( roadWidth - roadCenterDistance + marginRight, ( roadWidth - roadCenterDistance + marginRight ) * ui.crossSlopeStandard / 100 );

            const cementeFilterLt = new THREE.Vector3( concreteLt.x, concreteLt.y - concrete );
            const cementeFilterRt = new THREE.Vector3( concreteRt.x, concreteRt.y - concrete );

            const concretePavementShp = new THREE.Shape();
            concretePavementShp.moveTo( concreteLt.x, concreteLt.y );
            concretePavementShp.lineTo( concreteRt.x, concreteRt.y );
            concretePavementShp.lineTo( cementeFilterRt.x, cementeFilterRt.y );
            concretePavementShp.lineTo( cementeFilterLt.x, cementeFilterLt.y );
            concretePavementShp.lineTo( concreteLt.x, concreteLt.y ); //close Path

            // const concretePavementLine = addLine( concretePavementShp, 'darkslategray' );
            // showContainer.push( concretePavementLine );

            const concretePavementExtr1 = addExtr( concretePavementShp, 'darkslategray', ui.totalLength );
            showContainer.push( concretePavementExtr1 );

           
            const cementeFilterShp = new THREE.Shape();
            cementeFilterShp.moveTo( cementeFilterLt.x, cementeFilterLt.y );
            cementeFilterShp.lineTo( cementeFilterRt.x, cementeFilterRt.y );
            cementeFilterShp.lineTo( cementeFilterRt.x, cementeFilterRt.y - cementeFilter );
            cementeFilterShp.lineTo( cementeFilterLt.x, cementeFilterLt.y - cementeFilter );
            cementeFilterShp.lineTo( cementeFilterLt.x, cementeFilterLt.y ); //close Path
            
            // const cementeFilterLine = addLine( cementeFilterShp, 'silver' );
            // showContainer.push( cementeFilterLine );

            const cementeFilterExtr1 = addExtr( cementeFilterShp, 'silver', ui.totalLength );
            showContainer.push( cementeFilterExtr1 );

            
            // 맹암거 그리기
            const moleDrainageHeight = 0.400;

            const moleDrainageLtShp = new THREE.Shape();
            moleDrainageLtShp.moveTo( concreteLt.x, concreteLt.y - footingHeight );
            moleDrainageLtShp.lineTo( concreteLt.x, concreteLt.y - concrete - cementeFilter );
            moleDrainageLtShp.lineTo( concreteLt.x + 0.175, ( concreteLt.x + 0.175 ) * ui.crossSlopeStandard / 100 - concrete - cementeFilter );
            moleDrainageLtShp.lineTo( concreteLt.x - 0.125, concreteLt.y - footingHeight - moleDrainageHeight );
            moleDrainageLtShp.lineTo( concreteLt.x - 0.425, concreteLt.y - footingHeight - moleDrainageHeight );
            moleDrainageLtShp.lineTo( concreteLt.x - 0.550, concreteLt.y - footingHeight );
            moleDrainageLtShp.lineTo( concreteLt.x, concreteLt.y - footingHeight );

            const moleDrainageLtExtr1 = addExtr( moleDrainageLtShp, 'slategray', ui.longSpacing );
            cycle1Group.add( moleDrainageLtExtr1 );

            const moleDrainageLtExtr2 = addExtr( moleDrainageLtShp, 'slategray', ui.longSpacing );
            cycle2Group.add( moleDrainageLtExtr2 );

            const moleDrainageLtExtr3 = addExtr( moleDrainageLtShp, 'slategray', remainderLength );
            cycle3Group.add( moleDrainageLtExtr3 );

            const moleDrainageLtExtr4 = addExtr( moleDrainageLtShp, 'slategray', remainderLength );
            cycle4Group.add( moleDrainageLtExtr4 );


            const moleDrainageRtShp = new THREE.Shape();
            moleDrainageRtShp.moveTo( concreteRt.x, concreteRt.y - footingHeight );
            moleDrainageRtShp.lineTo( concreteRt.x, concreteRt.y - concrete - cementeFilter );
            moleDrainageRtShp.lineTo( concreteRt.x - 0.175, ( concreteRt.x - 0.175 ) * ui.crossSlopeStandard / 100 - concrete - cementeFilter );
            moleDrainageRtShp.lineTo( concreteRt.x + 0.125, concreteRt.y - footingHeight - moleDrainageHeight );
            moleDrainageRtShp.lineTo( concreteRt.x + 0.425, concreteRt.y - footingHeight - moleDrainageHeight );
            moleDrainageRtShp.lineTo( concreteRt.x + 0.550, concreteRt.y - footingHeight );
            moleDrainageRtShp.lineTo( concreteRt.x, concreteRt.y - footingHeight );

            const moleDrainageRtExtr1 = addExtr( moleDrainageRtShp, 'slategray', ui.longSpacing );
            cycle1Group.add( moleDrainageRtExtr1 );

            const moleDrainageRtExtr2 = addExtr( moleDrainageRtShp, 'slategray', ui.longSpacing );
            cycle2Group.add( moleDrainageRtExtr2 );

            const moleDrainageRtExtr3 = addExtr( moleDrainageRtShp, 'slategray', remainderLength );
            cycle3Group.add( moleDrainageRtExtr3 );

            const moleDrainageRtExtr4 = addExtr( moleDrainageRtShp, 'slategray', remainderLength );
            cycle4Group.add( moleDrainageRtExtr4 );



            // 편경사변화에 따른 공동구 위치 계산 

            /*
             * 배열 내장함수(map, forEach)
             *
             * map : 변화함수
             * map은 배열 안의 원소를 변화하여 새로운 배열을 만듬
             * 1) 새로운 배열을 선언하고, 2) for문으로 바꿔서 넣는 것은 한 번에 함.
             * 
             * 
             * forEach : 콜백함수
             * forEach는 원소에 대하여 처리하고 싶은 코드를 함수로 넣어줌
             */ 

            const footingLtSlope = footingLtType.map( i => new THREE.Vector2 ( i.x + concreteLt.x, i.y + concreteLt.y ) );
            const footingRtSlope = footingRtType.map( i => new THREE.Vector2 ( i.x + concreteRt.x, i.y + concreteRt.y ) );

            // let footingLtSlope = [];
            // let footingRtSlope = [];
            
            // for ( let i=0; i < footingLtType.length; i++ ) {
            //     footingLtSlope.push( new THREE.Vector2 ( footingLtType[i].x + concreteLt.x, footingLtType[i].y + concreteLt.y ) );
            // };

            // for ( let i=0; i < footingRtType.length; i++ ) {
            //     footingRtSlope.push( new THREE.Vector2 ( footingRtType[i].x + concreteRt.x, footingRtType[i].y + concreteRt.y ) );
            // };


            // 터널형상 그리기
            const r2Theta1 = Math.asin( ( r2Origin.y - footingLtSlope[footingLtSlope.length-1].y ) / r2Final ) + Math.PI/2 - r1ThetaLt;

            const r4Theta1 = Math.asin( ( r4Origin.y - footingRtSlope[footingRtSlope.length-1].y ) / r4Final ) + Math.PI/2 - r1ThetaRt;

            const r3Gamma1 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / r3Final );
            const r3Theta1 = Math.PI/2 - r1ThetaLt + r3Gamma1;

            const r5Gamma1 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / r5Final );
            const r5Theta1 = Math.PI/2 - r1ThetaRt + r5Gamma1;


            const footingRtReverse = [...footingRtSlope].reverse();// 원본 배열유지


            const liningShp = new THREE.Shape();
            liningShp.moveTo( footingLtSlope[0].x, footingLtSlope[0].y );
            footingLtSlope.forEach( i => { liningShp.lineTo( i.x, i.y ) } );
            // for ( let i=1; i < footingLtSlope.length; i++) { liningShp.lineTo( footingLtSlope[i].x, footingLtSlope[i].y ) };
            liningShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + r2Theta1, Math.PI/2 + r1ThetaLt, true );
            liningShp.absarc( 0, r1Height, r1Final, Math.PI/2 + r1ThetaLt, Math.PI/2, true );
            liningShp.absarc( 0, r1Height, r1Final, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            liningShp.absarc( r4Origin.x, r4Origin.y, r4Final, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r4Theta1, true );
            footingRtReverse.forEach( i => { liningShp.lineTo( i.x, i.y ) } );
            // for ( let i=0; i < footingRtReverse.length; i++) { liningShp.lineTo( footingRtReverse[i].x, footingRtReverse[i].y ) };
            liningShp.lineTo( footingRtReverse[footingRtReverse.length-1].x, footingRtReverse[footingRtReverse.length-1].y - footingHeight );
            liningShp.absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false );
            liningShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false );
            liningShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false );
            liningShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );
            liningShp.lineTo( footingLtSlope[0].x, footingLtSlope[0].y - footingHeight );
            liningShp.lineTo( footingLtSlope[0].x, footingLtSlope[0].y );

            const liningExtr1 = addExtr( liningShp, 'steelblue', ui.longSpacing );
            cycle1Group.add( liningExtr1 );

            const liningExtr2 = addExtr( liningShp, 'steelblue', ui.longSpacing );
            cycle2Group.add( liningExtr2 );

            const liningExtr3 = addExtr( liningShp, 'steelblue', remainderLength );
            cycle3Group.add( liningExtr3 );
            
            const liningExtr4 = addExtr( liningShp, 'steelblue', remainderLength );
            cycle4Group.add( liningExtr4 );



            // 숏크리트 그리기
            const r3Gamma2 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final + ui.shotcrete ) );
            const r3Theta2 = Math.PI/2 - r1ThetaLt + r3Gamma2;
            
            const r5Gamma2 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / ( r5Final + ui.shotcrete ) );
            const r5Theta2 = Math.PI/2 - r1ThetaRt + r5Gamma2;

            const scShp = new THREE.Shape();    
            scShp.absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false );
            scShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false );
            scShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false );
            scShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );
            scShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt + r3Theta2, Math.PI/2 + r1ThetaLt, true );
            scShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2 + r1ThetaLt,  Math.PI/2, true );
            scShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2,  Math.PI/2 - r1ThetaRt, true );
            scShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );

            const scExtr1 = addExtr( scShp, 'skyblue', ui.longSpacing );
            cycle1Group.add( scExtr1 );

            const scExtr2 = addExtr( scShp, 'skyblue', ui.longSpacing );
            cycle2Group.add( scExtr2 );

            const scExtr3 = addExtr( scShp, 'skyblue', remainderLength );
            cycle3Group.add( scExtr3 );

            const scExtr4 = addExtr( scShp, 'skyblue', remainderLength );
            cycle4Group.add( scExtr4 );


            // 환기타입

            // 브라켓 생성
            if ( ventilation == '횡류식' && bracketCase == 'case1' ) {

                const bracketLtShp = new THREE.Shape();
                bracketLtShp.moveTo( bracketLtPts[0].x, bracketLtPts[0].y );
                bracketLtPts.forEach( i => { bracketLtShp.lineTo( i.x, i.y ) } );
                bracketLtShp.absarc( 0, r1Height, r1Final, Math.PI/2 + bracketLtAngle[1], Math.PI/2 + bracketLtAngle[0], true );

                const bracketLtExtr1 = addExtr( bracketLtShp, 'steelblue', ui.longSpacing );
                cycle1Group.add( bracketLtExtr1 );

                const bracketLtExtr2 = addExtr( bracketLtShp, 'steelblue', ui.longSpacing );
                cycle2Group.add( bracketLtExtr2 );

                const bracketLtExtr3 = addExtr( bracketLtShp, 'steelblue', remainderLength );
                cycle3Group.add( bracketLtExtr3 );

                const bracketLtExtr4 = addExtr( bracketLtShp, 'steelblue', remainderLength );
                cycle4Group.add( bracketLtExtr4 );

                const bracketRtShp = new THREE.Shape();
                bracketRtShp.moveTo( bracketRtPts[0].x, bracketRtPts[0].y );
                bracketRtPts.forEach( i => { bracketRtShp.lineTo( i.x, i.y ) } );
                bracketRtShp.absarc( 0, r1Height, r1Final, Math.PI/2 - bracketRtAngle[1], Math.PI/2 - bracketRtAngle[0], false );

                const bracketRtExtr1 = addExtr( bracketRtShp, 'steelblue', ui.longSpacing );
                cycle1Group.add( bracketRtExtr1 );

                const bracketRtExtr2 = addExtr( bracketRtShp, 'steelblue', ui.longSpacing );
                cycle2Group.add( bracketRtExtr2 );

                const bracketRtExtr3 = addExtr( bracketRtShp, 'steelblue', remainderLength );
                cycle3Group.add( bracketRtExtr3 );

                const bracketRtExtr4 = addExtr( bracketRtShp, 'steelblue', remainderLength );
                cycle4Group.add( bracketRtExtr4 );

            } else if ( ventilation == '횡류식' && bracketCase == 'case2' ) {

                const bracketLtShp = new THREE.Shape();
                bracketLtShp.moveTo( bracketLtPts[0].x, bracketLtPts[0].y );
                bracketLtPts.forEach( i => { bracketLtShp.lineTo( i.x, i.y ) } );
                bracketLtShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + bracketLtAngle[1], Math.PI/2 + r1ThetaLt, true );
                bracketLtShp.absarc( 0, r1Height, r1Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + bracketLtAngle[0], true );

                const bracketLtExtr1 = addExtr( bracketLtShp, 'lightlblue', ui.longSpacing );
                cycle1Group.add( bracketLtExtr1 );

                const bracketLtExtr2 = addExtr( bracketLtShp, 'lightlblue', ui.longSpacing );
                cycle2Group.add( bracketLtExtr2 );

                const bracketLtExtr3 = addExtr( bracketLtShp, 'lightlblue', remainderLength );
                cycle3Group.add( bracketLtExtr3 );

                const bracketLtExtr4 = addExtr( bracketLtShp, 'lightlblue', remainderLength );
                cycle4Group.add( bracketLtExtr4 );

                const bracketRtShp = new THREE.Shape();
                bracketRtShp.moveTo( bracketRtPts[0].x, bracketRtPts[0].y );
                bracketRtPts.forEach( i => { bracketRtShp.lineTo( i.x, i.y ) } );
                bracketRtShp.absarc( r4Origin.x, r4Origin.y, r4Final, Math.PI/2 - r1ThetaRt - bracketRtAngle[1], Math.PI/2 - r1ThetaRt, false );
                bracketRtShp.absarc( 0, r1Height, r1Final, Math.PI/2 - r1ThetaRt, Math.PI/2 - bracketRtAngle[0], false );

                const bracketRtExtr1 = addExtr( bracketRtShp, 'lightlblue', ui.longSpacing );
                cycle1Group.add( bracketRtExtr1 );

                const bracketRtExtr2 = addExtr( bracketRtShp, 'lightlblue', ui.longSpacing );
                cycle2Group.add( bracketRtExtr2 );

                const bracketRtExtr3 = addExtr( bracketRtShp, 'lightlblue', remainderLength );
                cycle3Group.add( bracketRtExtr3 );

                const bracketRtExtr4 = addExtr( bracketRtShp, 'lightlblue', remainderLength );
                cycle4Group.add( bracketRtExtr4 );

            } else if ( ventilation == '횡류식' && bracketCase == 'case3' ) {

                const bracketLtShp = new THREE.Shape();
                bracketLtShp.moveTo( bracketLtPts[0].x, bracketLtPts[0].y );
                bracketLtPts.forEach( i => { bracketLtShp.lineTo( i.x, i.y ) } );
                bracketLtShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + bracketLtAngle[1], Math.PI/2 + r1ThetaLt + bracketLtAngle[0], true );

                const bracketLtExtr1 = addExtr( bracketLtShp, 'dodgerblue', ui.longSpacing );
                cycle1Group.add( bracketLtExtr1 );

                const bracketLtExtr2 = addExtr( bracketLtShp, 'dodgerblue', ui.longSpacing );
                cycle2Group.add( bracketLtExtr2 );

                const bracketLtExtr3 = addExtr( bracketLtShp, 'dodgerblue', remainderLength );
                cycle3Group.add( bracketLtExtr3 );

                const bracketLtExtr4 = addExtr( bracketLtShp, 'dodgerblue', remainderLength );
                cycle4Group.add( bracketLtExtr4 );

                const bracketRtShp = new THREE.Shape();
                bracketRtShp.moveTo( bracketRtPts[0].x, bracketRtPts[0].y );
                bracketRtPts.forEach( i => { bracketRtShp.lineTo( i.x, i.y ) } );
                bracketRtShp.absarc( r4Origin.x, r4Origin.y, r4Final, Math.PI/2 - r1ThetaRt - bracketRtAngle[1], Math.PI/2 - r1ThetaRt - bracketRtAngle[0], false );

                const bracketRtExtr1 = addExtr( bracketRtShp, 'dodgerblue', ui.longSpacing );
                cycle1Group.add( bracketRtExtr1 );

                const bracketRtExtr2 = addExtr( bracketRtShp, 'dodgerblue', ui.longSpacing );
                cycle2Group.add( bracketRtExtr2 );

                const bracketRtExtr3 = addExtr( bracketRtShp, 'dodgerblue', remainderLength );
                cycle3Group.add( bracketRtExtr3 );

                const bracketRtExtr4 = addExtr( bracketRtShp, 'dodgerblue', remainderLength );
                cycle4Group.add( bracketRtExtr4 );

            }

            // 덕트슬래브 생성
            if ( ventilation == '횡류식' ) {

                const ductSlabShp = new THREE.Shape();
                ductSlabShp.moveTo( ductslabPts[0].x, ductslabPts[0].y );
                ductslabPts.forEach( i => { ductSlabShp.lineTo( i.x, i.y ) } );

                const ductSlabExtr1 = addExtr( ductSlabShp, 'darkslateblue', ui.longSpacing );
                cycle1Group.add( ductSlabExtr1 );
                const ductSlabExtr2 = addExtr( ductSlabShp, 'darkslateblue', ui.longSpacing );
                cycle2Group.add( ductSlabExtr2 );
                const ductSlabExtr3 = addExtr( ductSlabShp, 'darkslateblue', remainderLength );
                cycle3Group.add( ductSlabExtr3 );
                const ductSlabExtr4 = addExtr( ductSlabShp, 'darkslateblue', remainderLength );
                cycle4Group.add( ductSlabExtr4 );

            }


            /**************************************************************************************
             * 상하반 분할 굴착
             **************************************************************************************/     

            // 1. 스프링 라인
            const upperHalfLeftTheta = Math.asin( ( r3Origin.y - ui.springLineEL ) / ( r3Final + ui.shotcrete ) ) ;

            const upperHalfLeftShp = new THREE.Shape();
            upperHalfLeftShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
            upperHalfLeftShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt, Math.PI + upperHalfLeftTheta, false );
            
            const upperHalfRightTheta = Math.asin( ( r5Origin.y - ui.springLineEL ) / ( r5Final + ui.shotcrete ) ) ;

            const upperHalfRightShp = new THREE.Shape();
            upperHalfRightShp.absarc(  0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            upperHalfRightShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, 0 - upperHalfRightTheta, true );
            
            const springLineShp = new THREE.Shape();
            springLineShp.moveTo( upperHalfLeftShp.getPoint( 1 ).x , upperHalfLeftShp.getPoint( 1 ).y );
            springLineShp.lineTo( 0 , ui.springLineEL );
            springLineShp.lineTo( upperHalfRightShp.getPoint( 1 ).x , upperHalfRightShp.getPoint( 1 ).y );
            
            // const springLine = addLine( springLineShp, 'black', ui.longSpacing );
            // showContainer.push( springLine );

            const springExtr1 = addExtr( springLineShp, 'wheat', ui.longSpacing );
            cycle1Group.add( springExtr1 );

            const springExtr2 = addExtr( springLineShp, 'wheat', ui.longSpacing );
            cycle2Group.add( springExtr2 );

            const springExtr3 = addExtr( springLineShp, 'wheat', remainderLength );
            cycle3Group.add( springExtr3 );

            const springExtr4 = addExtr( springLineShp, 'wheat', remainderLength );
            cycle4Group.add( springExtr4 );

            /**************************************************************************************
             * 보조공법
             * 
             * 선진보강(대구경) : Umbrella Arch Method - Large (uamLa)
             * 선진보강(소구경) : Umbrella Arch Method - Small (uamSm)
             * 포어폴링 : Forepoling (fp)
             * 보조공법 보강각도 : auxiliaryZoneAngle
             **************************************************************************************/           
            
            // 보조공법제원
            
            // 선진보강(대구경)
            // 2.1 선진보강(대구경) 횡방향 간격
            const uamLaSpaing = 0.500;
            
            // 2.2 선진보강(대구경) 형상
            const uamLaShp = new THREE.Shape;
            uamLaShp.absarc( 0, 0, 0.4, 0, Math.PI * 2, false );
            
            const uamLaShpGeo = new THREE.ExtrudeBufferGeometry( uamLaShp, { steps : 1, depth : 12,  bevelEnabled : false} );
            

            // 선진보강(소구경)
            // 2.1 선진보강(소구경) 횡방향 간격
            const uamSmSpaing = 0.500; //횡방향
            
            // 2.2 선진보강(소구경) 형상
            const uamSmShp = new THREE.Shape;
            uamSmShp.absarc( 0, 0, 0.2, 0, Math.PI * 2, false );
            
            const uamSmShpGeo = new THREE.ExtrudeBufferGeometry( uamSmShp, { steps : 1, depth : 12,  bevelEnabled : false} );
            

            // 포어폴링
            // 2.1 포어폴링 횡방향 간격
            const fpSpaing = 0.500; //횡방향
            
            // 2.2 포어폴링 형상
            const fpShp = new THREE.Shape;
            fpShp.absarc( 0, 0, 0.07, 0, Math.PI * 2, false );
            
            const fpShpGeo = new THREE.ExtrudeBufferGeometry( fpShp, { steps : 1, depth : 4,  bevelEnabled : false} );

            
            // 2.3 보조공법 옵셋거리
            let  uamLaOffset
            let  uamSmOffset
            let  fpOffset
            
            if ( ui.division == '본선부') {
                
                // 내측이격
                uamLaOffset = - 0.200;
                uamSmOffset = - 0.200;
                fpOffset = ui.shotcrete/2;
                
            } else if ( ui.division == '갱구부') {
                
                // 외측이격
                uamLaOffset = ui.shotcrete + 0.500; 
                uamSmOffset = ui.shotcrete + 0.500;
                fpOffset = ui.shotcrete + 0.300;
                
            };
            
            
            // 보조공법 타입에 따른 제원
            let auxiliarySpaing
            let auxiliaryOffset
            let auxiliaryGeo
            
            if ( ui.auxiliaryMethod == '선진보강(대)') {
                
                auxiliarySpaing = uamLaSpaing;
                auxiliaryOffset = uamLaOffset;
                auxiliaryGeo = uamLaShpGeo;
                
            } else if ( ui.auxiliaryMethod == '선진보강(소)') {
                
                auxiliarySpaing = uamSmSpaing;
                auxiliaryOffset = uamSmOffset;
                auxiliaryGeo = uamSmShpGeo;
                
            } else if ( ui.auxiliaryMethod == '포어폴링') {
                
                auxiliarySpaing = fpSpaing;
                auxiliaryOffset = fpOffset;
                auxiliaryGeo = fpShpGeo;
                
            } else if ( ui.auxiliaryMethod == '없음') {
                
                // 록볼트만 실행
                
            };
            
            
            // 2.4 보조공법 재료
            const auxiliaryMat = new THREE.MeshStandardMaterial  ( { color:'indianred', opacity: 0.7, transparent: true } ); //공통


            // 2.5 보조공법 영역의 경로
            let auxiliaryPathLeft, auxiliaryPathRight
            let calAngle //스프링라인에서의 각도 60도를 R1중심점에서 환산한 각도
            
            if ( ui.auxiliaryZone == '120도') {
                
                // 보조공법 영역 각도 계산
                const auxiliaryZoneAngle = Math.PI/3; //60도
                
                const deltaH = ui.springLineEL - r1Height;
                calAngle = auxiliaryZoneAngle - Math.asin( deltaH * Math.sin( auxiliaryZoneAngle ) / r1Final ) ;
                
                auxiliaryPathLeft = new THREE.Shape();
                auxiliaryPathLeft.absarc( 0, r1Height, r1Final + liningT0 + auxiliaryOffset, Math.PI/2, Math.PI/2 + calAngle, false );
                //addLine( auxiliaryPathLeft, 0x000000);

                auxiliaryPathRight = new THREE.Shape();
                auxiliaryPathRight.absarc( 0, r1Height, r1Final + liningT0 + auxiliaryOffset, Math.PI/2,  Math.PI/2 - calAngle, true );
                //addLine( auxiliaryPathRight, 0x000000r);
                
            } else if ( ui.auxiliaryZone == '상반부') {

                auxiliaryPathLeft = new THREE.Shape();
                auxiliaryPathLeft.absarc( 0, r1Height, r1Final + liningT0 + auxiliaryOffset,Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                auxiliaryPathLeft.absarc( r3Origin.x, r3Origin.y, r3Final + auxiliaryOffset, Math.PI/2 + r1ThetaLt, Math.PI + upperHalfLeftTheta, false );
                //addLine( auxiliaryPathLeft, 0x000000r);

                auxiliaryPathRight = new THREE.Shape();
                auxiliaryPathRight.absarc(  0, r1Height, r1Final + liningT0 + auxiliaryOffset, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
                auxiliaryPathRight.absarc( r5Origin.x, r5Origin.y, r5Final + auxiliaryOffset, Math.PI/2 - r1ThetaRt, 0 - upperHalfRightTheta, true );                
                //addLine( auxiliaryPathRight, 0x000000);
                
            } else if ( ui.auxiliaryZone == '전단면') {

                auxiliaryPathLeft = new THREE.Shape();
                auxiliaryPathLeft.absarc( 0, r1Height, r1Final + liningT0 + auxiliaryOffset, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                auxiliaryPathLeft.absarc( r3Origin.x, r3Origin.y, r3Final + auxiliaryOffset, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta2, false );                
                //addLine( auxiliaryPathLeft, 0x000000);
                
                auxiliaryPathRight = new THREE.Shape();
                auxiliaryPathRight.absarc( 0, r1Height, r1Final + liningT0 + auxiliaryOffset, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
                auxiliaryPathRight.absarc( r5Origin.x, r5Origin.y, r5Final + auxiliaryOffset, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );                
                //addLine( auxiliaryPathRight, 0x000000);
                
            };
            
            
            // 2.6 보조공법 그리기
            const auxiliaryGroup = new THREE.Group();
            
            // 보조공법 센터
            if ( ui.auxiliaryMethod == '선진보강(대)' ||  ui.auxiliaryMethod == '선진보강(소)' ||  ui.auxiliaryMethod == '포어폴링' ) {

                const auxiliaryPoints = [];

                const segment = auxiliaryPathLeft.getPointAt( 0 )
                auxiliaryPoints.push( segment );

                const tangent = auxiliaryPathLeft.getTangentAt( 0 ); //나눈점에서 unit circle생성. normal과 x,y 반대 
                const angle = Math.atan2(tangent.y, tangent.x);

                const auxiliaryMesh = new THREE.Mesh( auxiliaryGeo, auxiliaryMat );
                // auxiliaryMesh.castShadow = true;
                auxiliaryMesh.rotation.x = THREE.Math.degToRad( 170 );  //설치각도                

                const blockSystem = new THREE.Object3D(); // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                blockSystem.add( auxiliaryMesh );    

                blockSystem.position.set ( segment.x, segment.y, 0 );
                blockSystem.rotation.z = angle;
                // blockSystem.translateZ(ui.longSpacing );

                auxiliaryGroup.add( blockSystem );

            }
            
            // 보조공법 좌측
            for ( let i=1; i * auxiliarySpaing <= auxiliaryPathLeft.getLength(); i++) {
                
                const auxiliaryPoints = [];
                
                // 보조공법영역 경로 횡간격으로 나누기
                const segment = auxiliaryPathLeft.getPointAt( i * auxiliarySpaing / auxiliaryPathLeft.getLength() );
                auxiliaryPoints.push( segment );
                
                const tangent = auxiliaryPathLeft.getTangentAt( i * auxiliarySpaing / auxiliaryPathLeft.getLength() ); //나눈점에서 unit circle생성. normal과 x,y 반대 
                const angle = Math.atan2(tangent.y, tangent.x);
                
                const auxiliaryMesh = new THREE.Mesh( auxiliaryGeo, auxiliaryMat );
                auxiliaryMesh.castShadow = true;
                auxiliaryMesh.rotation.x = THREE.Math.degToRad( 170 );  //설치각도                
                
                const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                blockSystem.add( auxiliaryMesh );    
                
                blockSystem.position.set ( segment.x, segment.y, 0);
                blockSystem.rotation.z = angle;
                // blockSystem.translateZ(ui.longSpacing );
                
                auxiliaryGroup.add( blockSystem );
                
            };
                
            // 보조공법 우측
            for ( let i=1; i * auxiliarySpaing <= auxiliaryPathRight.getLength(); i++) {
                
                const auxiliaryPoints = [];

                // 보조공법영역 경로 횡간격으로 나누기
                const segment = auxiliaryPathRight.getPointAt( i * auxiliarySpaing / auxiliaryPathRight.getLength() );
                auxiliaryPoints.push(segment)
                
                const tangent = auxiliaryPathRight.getTangentAt( i * auxiliarySpaing / auxiliaryPathRight.getLength() ); //나눈점에서 unit circle생성. normal과 x,y 반대 
                const angle = Math.atan2(-tangent.y, -tangent.x);
                
                const auxiliaryMesh = new THREE.Mesh( auxiliaryGeo, auxiliaryMat ) ;
                auxiliaryMesh.castShadow = true;
                auxiliaryMesh.rotation.x = THREE.Math.degToRad( 170 );  //설치각도   
                
                const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                blockSystem.add( auxiliaryMesh );
                
                blockSystem.position.set ( segment.x, segment.y, 0);
                blockSystem.rotation.z = angle;
                // blockSystem.translateZ(ui.longSpacing );
                
                auxiliaryGroup.add( blockSystem );
                
                };
                
            // cycle1Group.add( auxiliaryGroup );


            /**************************************************************************************
             * 록볼트
             **************************************************************************************/      
            
            // 3.1 록볼트 경로

            // 아치부 경로
            const archLtShp = new THREE.Shape();
            archLtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
            
            const archRtShp = new THREE.Shape();
            archRtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            
            // 전단면 경로
            const fullFaceLtShp = new THREE.Shape();
            fullFaceLtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
            fullFaceLtShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta2, false );
            
            const fullFaceRtShp = new THREE.Shape();
            fullFaceRtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            fullFaceRtShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );
            
            

            // 보조공법이 120도 일 때, 상반부에서 남은 록볼트 경로
            const auxiliary120LtShp = new THREE.Shape();
            auxiliary120LtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2 + calAngle,  Math.PI/2 + r1ThetaLt, false );
            auxiliary120LtShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete,  Math.PI/2 + r1ThetaLt,  Math.PI/2 + r1ThetaLt + r3Theta2, false );
            
            const auxiliary120RtShp = new THREE.Shape();
            auxiliary120RtShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete,  Math.PI/2 - calAngle,  Math.PI/2 - r1ThetaRt, true );
            auxiliary120RtShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete,  Math.PI/2 - r1ThetaRt,  Math.PI/2 - r1ThetaRt - r5Theta2, true );
            
            // 하반부
            const bottomHalfLtShp = new THREE.Shape();
            bottomHalfLtShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete,  Math.PI + upperHalfLeftTheta - Math.PI/18, Math.PI/2 + r1ThetaLt + r3Theta2, false );// 록볼트 갯수를 더 넣기 위해 10도를 더해줬음
            
            const bottomHalfRtShp = new THREE.Shape();
            bottomHalfRtShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, 0 - upperHalfLeftTheta + Math.PI/18, Math.PI/2 - r1ThetaRt - r5Theta2, true );// 록볼트 갯수를 더 넣기 위해 10도를 더해줬음
            
            
            // 록볼트 보강영역
            let rbPathLeft
            let rbPathRight
            
            if ( ( ui.auxiliaryMethod =='선진보강(대)' || ui.auxiliaryMethod =='선진보강(소)' ) && ui.auxiliaryZone =='120도') {
             
                rbPathLeft = auxiliary120LtShp,
                rbPathRight = auxiliary120RtShp,
                rbDraw();
                
            } else if ( ( ui.auxiliaryMethod =='선진보강(대)' || ui.auxiliaryMethod =='선진보강(소)' ) && ui.auxiliaryZone =='상반부') {
                
                rbPathLeft = bottomHalfLtShp,
                rbPathRight = bottomHalfRtShp,
                rbDraw();
                
            } else if ( ( ui.auxiliaryMethod =='선진보강(대)' || ui.auxiliaryMethod =='선진보강(소)' ) && ui.auxiliaryZone =='전단면') {
                
                // 록볼트 그리지 않음
            
            } else if ( ui.rbZone =='전단면' ) {
                
                rbPathLeft = fullFaceLtShp,
                rbPathRight = fullFaceRtShp,
                rbDraw();
                
            } else if ( ui.rbZone =='상반부' ) {
                
                rbPathLeft = upperHalfLeftShp,
                rbPathRight = upperHalfRightShp,
                rbDraw();
                
            } else if ( ui.rbZone =='아치부' ) {
                
                rbPathLeft = archLtShp,
                rbPathRight = archRtShp,
                rbDraw();
                
            };
            
            
            // 3.2 록볼트 그리기 함수
            function rbDraw() {

                const rbCircSpacing = ui.rbCircSpacing/2
            
                // 록볼트 그리기
                let rbCenter
                const rbLeftContainer = [];
                const rbRightContainer = [];

                const rbGeo = new THREE.CylinderBufferGeometry( 0.025/2, 0.025/2, ui.rbLength, 32 );
                const rbmat = new THREE.MeshStandardMaterial( {color: 'darkcyan'} );


                // 록볼트 센터
                {

                    const rbPoints = [];

                    // 록볼트 횡간격으로 나누기
                    const segment = rbPathLeft.getPointAt( 0 );

                    rbPoints.push( segment );

                    // 횡간격에서 록볼트길이만큼 옵셋
                    const tangent = rbPathLeft.getTangentAt( 0 ); // 나눈점에서 unit circle생성. normal과 x,y 반대
                    const angle = Math.atan2( tangent.y, tangent.x);

                    const rbMesh = new THREE.Mesh( rbGeo, rbmat );
                    // rbMesh.castShadow = true;
                    rbMesh.position.y = -ui.rbLength/2 + 0.05;

                    const plateGeo = new THREE.BoxGeometry( 0.120, 0.010, 0.120 );
                    const plateMat = new THREE.MeshStandardMaterial( {color: 'cadetblue'} );
                    const plateMesh = new THREE.Mesh( plateGeo, plateMat );
                    plateMesh.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const nutPts = [];
                    nutPts.push( new THREE.Vector3(  0.000, -0.0219393, 0) );
                    nutPts.push( new THREE.Vector3(  0.019, -0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.000,  0.0219393, 0) );
                    nutPts.push( new THREE.Vector3( -0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3( -0.019, -0.0109697, 0) );
                    
                    const nutShp = new THREE.Shape();
                    nutShp.moveTo( nutPts[0].x, nutPts[0].y );
                    nutPts.forEach( i => nutShp.lineTo( i.x, i.y ) );

                    const nutExtr = addExtr( nutShp, 'indigo', 0.030 ); // 최소 숏크리트두께 고려
                    nutExtr.rotation.x = Math.PI*3/2;
                    nutExtr.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                    blockSystem.add( rbMesh );
                    blockSystem.add( plateMesh );
                    blockSystem.add( nutExtr );

                    blockSystem.position.set ( segment.x, segment.y, 0);
                    blockSystem.rotation.z = angle;

                    rbCenter = blockSystem;

                }
                
                // 록볼트 좌측
                for ( let i=1; i * rbCircSpacing <= rbPathLeft.getLength(); i++) {

                    const rbPoints = [];

                    // 록볼트 횡간격으로 나누기
                    const segment = rbPathLeft.getPointAt( i * rbCircSpacing / rbPathLeft.getLength() );

                    rbPoints.push( segment );

                    // 횡간격에서 록볼트길이만큼 옵셋
                    const tangent = rbPathLeft.getTangentAt( i * rbCircSpacing / rbPathLeft.getLength() ); // 나눈점에서 unit circle생성. normal과 x,y 반대
                    const angle = Math.atan2( tangent.y, tangent.x);

                    const rbMesh = new THREE.Mesh( rbGeo, rbmat );
                    rbMesh.castShadow = true;
                    rbMesh.position.y = -ui.rbLength/2 + 0.05;

                    const plateGeo = new THREE.BoxGeometry( 0.120, 0.010, 0.120 );
                    const plateMat = new THREE.MeshStandardMaterial ( {color: 'cadetblue'} );
                    const plateMesh = new THREE.Mesh( plateGeo, plateMat );
                    plateMesh.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const nutPts = [];
                    nutPts.push( new THREE.Vector3(  0.000, -0.0219393, 0) );
                    nutPts.push( new THREE.Vector3(  0.019, -0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.000,  0.0219393, 0) );
                    nutPts.push( new THREE.Vector3( -0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3( -0.019, -0.0109697, 0) );
                    
                    const nutShp = new THREE.Shape();
                    nutShp.moveTo( nutPts[0].x, nutPts[0].y );
                    nutPts.forEach( i => nutShp.lineTo( i.x, i.y ) );

                    const nutExtr = addExtr( nutShp, 'indigo', 0.030 ); // 최소 숏크리트두께 고려
                    nutExtr.rotation.x = Math.PI*3/2;
                    nutExtr.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                    blockSystem.add( rbMesh );
                    blockSystem.add( plateMesh );
                    blockSystem.add( nutExtr );

                    blockSystem.position.set ( segment.x, segment.y, 0);
                    blockSystem.rotation.z = angle;

                    rbLeftContainer.push( blockSystem );

                }

                // 록볼트 우측
                for ( let i=1; i * rbCircSpacing <= rbPathRight.getLength(); i++) {

                    const rbPoints = [];

                    // 록볼트 횡간격으로 나누기
                    const segment = rbPathRight.getPointAt( i * rbCircSpacing / rbPathRight.getLength() );

                    rbPoints.push( segment );

                    // 횡간격에서 록볼트길이만큼 옵셋
                    const tangent = rbPathRight.getTangentAt( i * rbCircSpacing / rbPathRight.getLength() ); // 나눈점에서 unit circle생성. normal과 x,y 반대
                    const angle = Math.atan2( - tangent.y, - tangent.x);

                    const rbMesh = new THREE.Mesh( rbGeo, rbmat );
                    rbMesh.castShadow = true;
                    rbMesh.position.y = -ui.rbLength/2 + 0.05;

                    const plateGeo = new THREE.BoxGeometry( 0.120, 0.010, 0.120 );
                    const plateMat = new THREE.MeshStandardMaterial( {color: 'cadetblue'} );
                    const plateMesh = new THREE.Mesh( plateGeo, plateMat );
                    plateMesh.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const nutPts = [];
                    nutPts.push( new THREE.Vector3(  0.000, -0.0219393, 0) );
                    nutPts.push( new THREE.Vector3(  0.019, -0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3(  0.000,  0.0219393, 0) );
                    nutPts.push( new THREE.Vector3( -0.019,  0.0109697, 0) );
                    nutPts.push( new THREE.Vector3( -0.019, -0.0109697, 0) );
                    
                    const nutShp = new THREE.Shape();
                    nutShp.moveTo( nutPts[0].x, nutPts[0].y );
                    nutPts.forEach( i => nutShp.lineTo( i.x, i.y ) );

                    const nutExtr = addExtr( nutShp, 'indigo', 0.030 ); // 최소 숏크리트두께 고려
                    nutExtr.rotation.x = Math.PI*3/2;
                    nutExtr.position.set( 0, 0.010, 0);// 숏크리트 곡선 때문에 좀 더 넣어줌

                    const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                    blockSystem.add( rbMesh );
                    blockSystem.add( plateMesh );
                    blockSystem.add( nutExtr );

                    blockSystem.position.set ( segment.x, segment.y, 0);
                    blockSystem.rotation.z = angle;

                    rbRightContainer.push( blockSystem );

                }

                // 마지막 록볼트 삭제
                if ( ui.rbLtLastDel == true ) {

                    rbLeftContainer.pop()
                    
                }

                if ( ui.rbRtLastDel == true ) {

                    rbRightContainer.pop()

                }
                

                // 록볼트 1Cycle, 2Cycle 생성
                const rbGroup1 = new THREE.Group();
                const rbGroup2 = new THREE.Group();
                const rbGroup3 = new THREE.Group();
                const rbGroup4 = new THREE.Group();
               
                
                for( let i=0; i < rbLeftContainer.length; i++ ) {

                    if( i % 2 == 0 ) {

                        rbGroup1.add( rbLeftContainer[ i ] );

                    } else {

                        rbGroup2.add( rbLeftContainer[ i ] );

                    }

                }

                for( let i=0; i < rbRightContainer.length; i++ ) {

                    if( i % 2 == 0 ) {

                        rbGroup1.add( rbRightContainer[ i ] );

                    } else {

                        rbGroup2.add( rbRightContainer[ i ] );

                    }

                }

                // 선진보강일때 록볼트 센터 제외함
                if ( ui.auxiliaryMethod =='없음' || ui.auxiliaryMethod =='포어폴링' )  {

                    rbGroup2.add(rbCenter);

                };

                rbGroup3.add( rbGroup1.clone() );
                rbGroup4.add( rbGroup2.clone() );


                // 록볼트 1Cycle, 2Cycle 배치
                rbGroup1.position.set( 0, 0, ui.longSpacing*0.5 );
                cycle1Group.add( rbGroup1 );

                const newMaterial = new THREE.MeshStandardMaterial( {color: 'darkslateblue'} );

                rbGroup1.traverse( (o) => { if ( o.isMesh ) o.material = newMaterial } );

                rbGroup2.position.set( 0, 0, ui.longSpacing*0.5 );
                cycle2Group.add( rbGroup2 );

                rbGroup3.position.set( 0, 0, remainderLength*0.5 );
                cycle3Group.add( rbGroup4 )

                rbGroup3.traverse( (o) => { if ( o.isMesh ) o.material = newMaterial } );

                rbGroup4.position.set( 0, 0, remainderLength*0.5 );
                cycle4Group.add( rbGroup3 )


                console.log( '록볼트 개수', rbGroup1.children.length + rbGroup2.children.length )
                
            }

            

            // 공동구 뚜껑 생성
            let coverLeftB0, coverRightB0, coverL, coverS;
            const coverT = 0.060;

            switch ( footingType ) {

                case '자연환기' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[15].x - footingRtType[8].x );

                    coverL = 0.480;
                    coverS = 0.500; // spacing

                    break;

                case '기계환기' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[15].x - footingRtType[8].x );
              
                    coverL = 0.250;
                    coverS = 0.250; // spacing

                    break;

                case '기계환기(물분무)' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[16].x - footingRtType[8].x );

                    coverL = 0.250;
                    coverS = 0.250; // spacing

                    break;

            }

            const coverLeftB1 = ( ( coverLeftB0 - 0.020 ) - ( 0.025 + 0.150 +0.025 ) ) / 2;

            const coverSlabLtShp = new THREE.Shape();
            coverSlabLtShp.moveTo( 0, 0 );
            coverSlabLtShp.lineTo( 0, coverL );
            coverSlabLtShp.lineTo( - coverLeftB1, coverL );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025, coverL -0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150, coverL -0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150 - 0.025, coverL );
            coverSlabLtShp.lineTo( - coverLeftB0 + 0.020, coverL );
            coverSlabLtShp.lineTo( - coverLeftB0 + 0.020, 0 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150 - 0.025, 0 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150, 0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025, 0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1, 0 );
            coverSlabLtShp.lineTo( 0, 0 );

            const coverSlabLtExtr = addExtr( coverSlabLtShp, 'powderblue', coverT );
            coverSlabLtExtr.rotateX( Math.PI/2 )


            const coverRightB1 = ( ( coverRightB0 - 0.020 ) - ( 0.025 + 0.150 +0.025 ) ) / 2;

            const coverSlabRtShp = new THREE.Shape();
            coverSlabRtShp.moveTo( 0, 0 );
            coverSlabRtShp.lineTo( 0, coverL );
            coverSlabRtShp.lineTo( coverRightB1, coverL );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025, coverL -0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150, coverL -0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150 + 0.025, coverL );
            coverSlabRtShp.lineTo( coverRightB0 - 0.020, coverL );
            coverSlabRtShp.lineTo( coverRightB0 - 0.020, 0 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150 + 0.025, 0 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150, 0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025, 0.025 );
            coverSlabRtShp.lineTo( coverRightB1, 0 );
            coverSlabRtShp.lineTo( 0, 0 );

            const coverSlabRtExtr = addExtr( coverSlabRtShp, 'powderblue', coverT );
            coverSlabRtExtr.rotateX( Math.PI/2 )            


            for ( let i=0; i*coverS < ui.totalLength; i++ ) {

                const covercloneLt = coverSlabLtExtr.clone();
                covercloneLt.position.set( footingLtType[8].x + concreteLt.x - 0.010, footingLtType[8].y + concreteLt.y, i*coverS );
                showContainer.push( covercloneLt );

                const covercloneRt = coverSlabRtExtr.clone();
                covercloneRt.position.set( footingRtType[8].x + concreteRt.x + 0.010, footingRtType[8].y + concreteRt.y, i*coverS );
                showContainer.push( covercloneRt );

            }


            // // 측벽유공관-좌
            // {

            //     // y = mx + d, 횡배수관 중심선
            //     const mValue = -0.04; // -4%

            //     const wallPipeD = 0.114; // 외경 114, 내경 100
            //     const yInit = footingLtSlope[0].y - footingHeight;
            //     const pipeAtan = Math.atan(4/100); // -4%각도

            //     const dValue =  -mValue*(concreteLt.x - 0.550) + yInit + wallPipeD/2/Math.cos(pipeAtan);


            //     // (x-a)^2 + (y-b)^2 = r^2
            //     const aValue = r3Origin.x;
            //     const bValue = r3Origin.y;
            //     const rValue = r3Final - wallPipeD/2;


            //     // difference = r^2(1+m^2) - (b-ma-d)^2
            //     const difference = rValue*rValue*(1+mValue*mValue) - (bValue-mValue*aValue-dValue)*(bValue-mValue*aValue-dValue);


            //     // x1 = [ a + bm - dm + sqrt(difference) ] / [ 1 + m^2 ]
            //     // x2 = [ a + bm - dm - sqrt(difference) ] / [ 1 + m^2 ]
            //     const x1Value = ( aValue+bValue*mValue - dValue*mValue + Math.sqrt(difference) ) / ( 1+mValue*mValue);
            //     const x2Value = ( aValue+bValue*mValue - dValue*mValue - Math.sqrt(difference) ) / ( 1+mValue*mValue);


            //     // 결과
            //     const xValue = Math.min( x1Value, x2Value ); // min값
            //     const yValue = mValue*xValue + dValue;


            //     // 측벽유공관 생성
            //     const wallPipeShape = new THREE.Shape();
            //     wallPipeShape.absarc( xValue, yValue, wallPipeD/2, 0, Math.PI*2, false );

            //     const wallPipeExtr = addExtr( wallPipeShape, 'red', ui.totalLength);
            //     showContainer.push( wallPipeExtr );

            // }

            // // 측벽유공관-우
            // {

            //     // y = mx + d, 횡배수관 중심선
            //     const mValue = 0.04; // -4%

            //     const wallPipeD = 0.114; // 외경 114, 내경 100
            //     const yInit = footingRtSlope[0].y - footingHeight;
            //     const pipeAtan = Math.atan(-4/100); // -4%각도

            //     const dValue =  -mValue*(concreteRt.x - 0.550) + yInit + wallPipeD/2/Math.cos(pipeAtan);


            //     // (x-a)^2 + (y-b)^2 = r^2
            //     const aValue = r5Origin.x;
            //     const bValue = r5Origin.y;
            //     const rValue = r5Final - wallPipeD/2;


            //     // difference = r^2(1+m^2) - (b-ma-d)^2
            //     const difference = rValue*rValue*(1+mValue*mValue) - (bValue-mValue*aValue-dValue)*(bValue-mValue*aValue-dValue);


            //     // x1 = [ a + bm - dm + sqrt(difference) ] / [ 1 + m^2 ]
            //     // x2 = [ a + bm - dm - sqrt(difference) ] / [ 1 + m^2 ]
            //     const x1Value = ( aValue+bValue*mValue - dValue*mValue + Math.sqrt(difference) ) / ( 1+mValue*mValue);
            //     const x2Value = ( aValue+bValue*mValue - dValue*mValue - Math.sqrt(difference) ) / ( 1+mValue*mValue);


            //     // 결과
            //     const xValue = Math.max( x1Value, x2Value ); // max값
            //     const yValue = mValue*xValue + dValue;


            //     // 측벽유공관 생성
            //     const wallPipeShape = new THREE.Shape();
            //     wallPipeShape.absarc( xValue, yValue, wallPipeD/2, 0, Math.PI*2, false );

            //     const wallPipeExtr = addExtr( wallPipeShape, 'red', ui.totalLength );
            //     showContainer.push( wallPipeExtr );

            // }



            // 1cycle, 2cycle 배치
            for ( let i=0; i*ui.longSpacing < ui.totalLength; i++) {

                if ( i == parseInt( ui.totalLength/ui.longSpacing) ) { // 1cycle, 2cycle이 아닌 나머지의 경우

                    if ( i % 2 ==0 ) {

                        const cycle4Clone = cycle4Group.clone();
                        cycle4Clone.position.set( 0, 0, ui.totalLength - i*ui.longSpacing - remainderLength );
                        showContainer.push( cycle4Clone );

                    } else {

                        const cycle3Clone = cycle3Group.clone();
                        cycle3Clone.position.set( 0, 0, ui.totalLength - i*ui.longSpacing - remainderLength );
                        showContainer.push( cycle3Clone );

                    }

                } else if ( i % 2 == 0 ) {

                    const cycle1Clone = cycle1Group.clone();
                    cycle1Clone.position.set( 0, 0, ui.totalLength - i*ui.longSpacing - ui.longSpacing );
                    showContainer.push( cycle1Clone );

                } else {

                    const cycle2Clone = cycle2Group.clone();
                    cycle2Clone.position.set( 0, 0, ui.totalLength - i*ui.longSpacing - ui.longSpacing  );
                    showContainer.push( cycle2Clone );

                }

            }

            // 보조공법 배치
            for ( let i=0; ui.totalLength - i*6 > 0; i++) {

                const auxiliaryGroupClone = auxiliaryGroup.clone();
                auxiliaryGroupClone.position.set( 0, 0, ui.totalLength - i*6 )
                showContainer.push( auxiliaryGroupClone )

            }


            if ( ui.auxiliaryMethod == '포어폴링') {

                for ( let i=0; ui.totalLength - i*ui.longSpacing > 0; i++) {

                    const auxiliaryGroupClone = auxiliaryGroup.clone();
                    auxiliaryGroupClone.position.set( 0, 0, ui.totalLength - i*ui.longSpacing )
                    showContainer.push( auxiliaryGroupClone )

                }

            }


            // 결과값 저장
            sessionStorage.setItem('스프링라인EL', JSON.stringify( ui.springLineEL ) );
            sessionStorage.setItem('적용편경사', JSON.stringify( ui.crossSlopeStandard ) );



            // 체적계산
            console.log( '숏크리트 체적', getVolume(scExtr1.geometry) )
            console.log( '라이닝 체적', getVolume(liningExtr1.geometry) )

            function getVolume(geometry) {
                if (!geometry.isBufferGeometry) {
                    console.log("'geometry' must be an indexed or non-indexed buffer geometry");
                    return 0;
                }
                var isIndexed = geometry.index !== null;
                let position = geometry.attributes.position;
                let sum = 0;
                let p1 = new THREE.Vector3(),
                p2 = new THREE.Vector3(),
                p3 = new THREE.Vector3();
                if (!isIndexed) {
                    let faces = position.count / 3;
                    for (let i = 0; i < faces; i++) {
                        p1.fromBufferAttribute(position, i * 3 + 0);
                        p2.fromBufferAttribute(position, i * 3 + 1);
                        p3.fromBufferAttribute(position, i * 3 + 2);
                        sum += signedVolumeOfTriangle(p1, p2, p3);
                    }
                }
                else {
                    let index = geometry.index;
                    let faces = index.count / 3;
                    for (let i = 0; i < faces; i++){
                        p1.fromBufferAttribute(position, index.array[i * 3 + 0]);
                        p2.fromBufferAttribute(position, index.array[i * 3 + 1]);
                        p3.fromBufferAttribute(position, index.array[i * 3 + 2]);
                        sum += signedVolumeOfTriangle(p1, p2, p3);
                    }
                }
                return sum;
            }

            function signedVolumeOfTriangle(p1, p2, p3) {
                return p1.dot(p2.cross(p3)) / 6.0;
            }



            //  오브젝트 로더, 웹에서 만든 Mesh를 다른 탭에서도 불러서 사용가능
            // {

            //     const objectLoader = new THREE.ObjectLoader();


            //     const json = JSON.parse( sessionStorage.getItem('브라켓' ) );
                
            //     const loadMesh = objectLoader.parse( json );
            //     showContainer.push( loadMesh );


            // }



            // scene 생성
            showContainer.forEach( i => scene.add( i ) );

        }


        function createUI() {
            
            const gui = new GUI();
            
            const commonFolder = gui.addFolder( '공통' )
            commonFolder.add( ui, 'crossSlopeStandard', crossSlopeMin, crossSlopeMax, 0.050 ).name( '적용 편경사' ).onChange( designTunnel );
            commonFolder.add( ui, 'totalLength', 1, 20, 0.1 ).name( '적용 연장' ).onChange( designTunnel );
            commonFolder.open();
            
            const supportSystemFolder = gui.addFolder( '지보패턴' )
            supportSystemFolder.add( ui, 'springLineEL', 1.000, 4.000, 0.010 ).name( '스프링라인EL' ).onChange( designTunnel );            
            supportSystemFolder.add( ui, 'longSpacing', 1.000, 4.000, 0.100 ).name( '굴진장/지보장' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'shotcrete', 0.050, 0.300, 0.010 ).name( '숏크리트 두께' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'rbZone', [ '없음','아치부', '상반부', '전단면' ] ).name( '록볼트 보강영역' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'rbLength', 3.000, 5.000, 1.000 ).name( '록볼트 길이' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'rbCircSpacing', 1.000, 4.000, 0.100 ).name( '록볼트 횡간격' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'rbLtLastDel').name( '좌측하단 삭제' ).onChange( designTunnel );
            supportSystemFolder.add( ui, 'rbRtLastDel').name( '우측하단 삭제' ).onChange( designTunnel );
            
            const auxiliaryMethodFolder = gui.addFolder( '보조공법' )
            auxiliaryMethodFolder.add( ui, 'auxiliaryMethod', [ '없음', '포어폴링', '선진보강(소)', '선진보강(대)' ] ).name( '타입' ).onChange( designTunnel );            
            auxiliaryMethodFolder.add( ui, 'division', [ '본선부', '갱구부' ] ).name( '구간' ).onChange( designTunnel );            
            auxiliaryMethodFolder.add( ui, 'auxiliaryZone', [ '120도', '상반부', '전단면' ] ).name( '영역' ).onChange( designTunnel );
            //auxiliaryMethodFolder.open();

        }
        
        

        function addLine( shape, color ) {
            const points = shape.getPoints();
            const lineGeo = new THREE.BufferGeometry().setFromPoints( points );
            const lineMat = new THREE.LineBasicMaterial( { color } );
            const line = new THREE.Line( lineGeo, lineMat );
            // line.castShadow = true;
            return line;
        }

        function addSurf( shape, color ) {
            const surfGeo = new THREE.ShapeGeometry( shape, 100 );
            const surfMat = new THREE.MeshStandardMaterial ( { color, opacity: 0.7, transparent: true, side: THREE.DoubleSide } );
            const mesh = new THREE.Mesh( surfGeo, surfMat );
            return mesh;
        }
        
        function addExtr( shape, color, length ) {
            
            const extrudeSettings = {
                steps : 1,
                depth : length,
                bevelEnabled : false,
            }
            
            const extrudeGeo = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );
            const extrudeMat = new THREE.MeshStandardMaterial ( { color, roughness : 0.8, metalness : 0.2, transparent: true } );
            const mesh = new THREE.Mesh( extrudeGeo, extrudeMat ) ;
            return mesh;
            
        };

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            
            return needResize;
        }
        
        function render() {
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }


            // 

            
            renderer.renderLists.dispose();
            renderer.render(scene, camera);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);




        //export GLTF
        const exporter = new GLTFExporter();

        document.getElementById("button").addEventListener("click", exportFile);        
        
        
        function exportFile() {

            const result = exporter.parse( scene, function ( result ) {

					if ( result instanceof ArrayBuffer ) {

						saveArrayBuffer( result, '지보패턴.glb' );

					} else {

						const output = JSON.stringify( result, null, 2 );
						saveString( output, '지보패턴.gltf' );

					}

            } ) }

        const link = document.createElement( 'a' );
        link.style.display = 'none';
        document.body.appendChild( link );

        function save( blob, filename ) {

            link.href = URL.createObjectURL( blob );
            link.download = filename;
            link.click();

        }

        function saveString( text, filename ) {

            save( new Blob( [ text ], { type: 'text/plain' } ), filename );

        }

        function saveArrayBuffer( buffer, filename ) {

            save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

        } 

        
    </script>
    
</body>

</html>
