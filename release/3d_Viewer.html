<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D_Viewer</title>
    <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous"> -->
    <style>
        html, body {
            margin : 0;
            height : 100%
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #info {
            position: absolute;
            top: 20px;
            /* left : 50%; */
            padding: 10px;
            /* transform : translate( -50% ); */
            /* text-align: center; */
            background: rgba( 0, 0, 0, 0 );
            color: black;
            font-size: 12px;
        } 

        .obit-controls-gizmo {
            position: absolute;
            top: 2em;
            right: 2em;
            z-index: 1000;
            background-color: #FFF0;
            border-radius: 100%;
            transition: background-color .15s  linear;
            cursor: pointer;
        }

        .obit-controls-gizmo.dragging, 
        .obit-controls-gizmo:hover {
            background-color: #FFF3;
        }

        .obit-controls-gizmo.inactive {
            pointer-events: none;
            background-color: #FFF0  !important;
        }

    </style>
</head>
<body>

    <div id="info">
        <b>Camera Type</b>
        <br>
        <b style="color:#2FA1D6">C : </b>Perspective/Orthographic
        <br>
        <b>Wireframe</b>
        <br>
        <b style="color:#2FA1D6">W : </b>On/Off
        <br>
        <b>Auto Rotate</b>
        <br>
        <b style="color:#2FA1D6">A : </b>On/Off
        <br>
        <b>View Mode</b>
        <br>
        <b style="color:#2FA1D6">F : </b>Front, <b style="color:#2FA1D6">B : </b>Back, <b style="color:#2FA1D6">R : </b>Right, <b style="color:#2FA1D6">L : </b>Left, <b style="color:#2FA1D6">T : </b>Top 
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js'; // min으로 교체
        import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';
        import { OrbitControlsGizmo  } from 'https://Lee-hoseong.github.io//ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';
        import { GLTFLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/GLTFLoader.js';
        import { GUI } from 'https://Lee-hoseong.github.io/jsm/libs/dat.gui.module.js';
        import { RGBELoader } from 'https://Lee-hoseong.github.io/jsm/loaders/RGBELoader.js';


        // variable
        let camera, scene, light, renderer;
        let cameraPerspective, cameraOrtho;
        let controlsPerspective, controlsOrtho;
        let box, sizeBox, centerBox, model;
        let progressBarDiv;
        let clippingPlanes;


        create3DViewer();
        animate();

        function create3DViewer () {
            const canvas = document.querySelector('#c'); 
            
            // scene
            scene = new THREE.Scene();               
            scene.background = new THREE.Color( 0xf0f0f0 );         

            // camera
            const aspect = window.innerWidth/window.innerHeight;
            
            cameraPerspective = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            // camera.position.set( 0, 0, 0);
            scene.add( cameraPerspective );

            cameraOrtho = new THREE.OrthographicCamera( 
                window.innerWidth/-aspect, 
                window.innerWidth/aspect, 
                window.innerHeight/aspect, 
                window.innerHeight/-aspect, 0.1, 1000 
            );
            cameraOrtho.zoom = 50;
            scene.add( cameraOrtho );

            camera = cameraPerspective;
            

            // OrbitControl
            controlsPerspective = new OrbitControls( cameraPerspective, canvas );
            controlsPerspective.autoRotate = true;
            controlsPerspective.autoRotateSpeed = -3;
            controlsPerspective.screenSpacePanning = true;
     
            controlsOrtho = new OrbitControls( cameraOrtho, canvas );
            controlsOrtho.autoRotate = true;
            controlsOrtho.autoRotateSpeed = -3;
            controlsOrtho.screenSpacePanning = true;


            // Gizmo
            const controlsGizmoPerspective = new  OrbitControlsGizmo(controlsPerspective, { size:  100, padding:  8 });
            document.body.appendChild(controlsGizmoPerspective.domElement);
            console.log( controlsGizmoPerspective )


            // plane
            // const planeGeometry = new THREE.PlaneBufferGeometry( 100, 100 );
            // planeGeometry.rotateX( - Math.PI/2 );
            // const planeMaterial = new THREE.ShadowMaterial( { opacity: 0.3 } );
            // const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            // plane.position.y = -1.999;
            // plane.receiveShadow = true;
            // scene.add( plane );
            

            // Axes
            const axes = new THREE.AxesHelper( 1 ); 
            scene.add( axes );
            

            // light
            scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );
            
            light = new THREE.DirectionalLight( 'white', 3 );
            light.position.set( -1, 2, 4 );
            // light.position.set( 0.5, 0, 0.866 );
            // light.target.position.set( 0, 0, 0 );
            // light.castShadow = true;
            // scene.add(light);
            camera.add( light );

            const hemiLight = new THREE.HemisphereLight();
            light.add( hemiLight );
            

            // light helper
            // const lightHelper = new THREE.DirectionalLightHelper( light, 10 );
            // scene.add( lightHelper );


            //
            new RGBELoader()
                .setDataType( THREE.FloatType )
                .setPath( 'https://Lee-hoseong.github.io/texture/' )
                // .load( 'short_tunnel_1k.hdr', function ( texture ) {
                .load( 'footprint_court_2k.hdr', function ( texture ) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                } );


            // Render
            renderer = new THREE.WebGLRenderer( { canvas } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.outputEncoding = THREE.sRGBEncoding; // 출력 렌더링 인코딩을 제어
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // HDR값을 LDR값으로 변환
            renderer.toneMappingExposure = 1.0;

            renderer.shadowMap.enabled = true;

            renderer.physicallyCorrectLights = true

            renderer.localClippingEnabled = true;

            // resize
            window.addEventListener( 'resize', onWindowResize );


            // keydown
            document.addEventListener( 'keydown', onKeyDown );


            // progressBar
            progressBarDiv = document.createElement( 'div' );
            progressBarDiv.innerText = 'Loading...';
            progressBarDiv.style.fontSize = '3em';
            progressBarDiv.style.color = '#888';
            progressBarDiv.style.display = 'block';
            progressBarDiv.style.position = 'absolute';
            progressBarDiv.style.top = '50%';
            progressBarDiv.style.width = '100%';
            progressBarDiv.style.textAlign = 'center';


            updateProgressBar( 0 );
            showProgressBar();

            // GLTF Loader
            // let gltfLoader = new GLTFLoader().setPath( 'https://Lee-hoseong.github.io/model/' );
            let gltfLoader = new GLTFLoader();
            const url = 'truck.glb';
            // const url = '3dtest.glb';
            // const url = '/rock/scene.gltf';
            // const url = '1250_main.glb';
            gltfLoader.load( url, function ( gltf ) {
                // gltf.scene.traverse( function( node ) {
                //     if ( node instanceof THREE.Mesh ) {
                //         node.castShadow = true;
                //         node.receiveShadow = true;
                //         node.geometry.center();
                //     }
                // });

                model = gltf.scene;
                scene.add( model );

                zoomFit( model, camera, "Z", true   );

                // clipping
                clippingPlanes = [ 
                    new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), box.max.x ),
                    new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), box.max.y ),
                    new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), box.max.z )
                ];

                // clipping Helper
                // const planeHelpers = clippingPlanes.map( p => new THREE.PlaneHelper( p, 5, 'black' ) );
				// planeHelpers.forEach( ph => {
				// 	ph.visible = true;
				// 	scene.add( ph );
				// } );

                gltf.scene.traverse( ( child )=> {
                    if( !child.isMesh ) return;

                    child.material.clippingPlanes = clippingPlanes;
                })
                
                console.log( "model :", model );
                console.log( "sizeBox :", sizeBox );

                // grid
                const size = 2*sizeBox;
                const divisions = 20;
                const gridHelper = new THREE.GridHelper( size, divisions );
                gridHelper.position.x = centerBox.x;
                gridHelper.position.y = 0;
                gridHelper.material.opacity = 0.4;
                gridHelper.material.transparent = true;
                scene.add( gridHelper );

                hideProgressBar();
                // createUI();

            }, onProgress, onError );

        }

        function zoomFit(obj3D, viewMode, bFront) {
            
            // 모델의 경계 박스
            box = new THREE.Box3().setFromObject(obj3D);

            // const boxHelper = new THREE.BoxHelper( obj3D, 'black' );
            // scene.add( boxHelper );

            // 모델의 경계 박스 대각의 길이
            sizeBox = box.getSize(new THREE.Vector3()).length();

            // 모델의 경계 박스 중심 위치
            centerBox = box.getCenter(new THREE.Vector3());

            // viewmode 설정
            let offsetX =0, offsetY=0, offsetZ=0;
            viewMode === "X" ? offsetX = 1 : (viewMode === "Y") ?
                offsetY = 1 : offsetZ = 1;

            // 앞면을 볼지 뒷면을 볼지
            if( !bFront ) {
                offsetX *= -1; 
                offsetY *= -1; 
                offsetZ *= -1; 
            }

            // 카메라 위치 설정
            camera.position.set( 
                centerBox.x + offsetX, centerBox.y + offsetY, centerBox.z + offsetZ
            );
            
            // 모델 크기의 절반값
            const halfSizeModel = sizeBox * 0.5;

            // 카메라의 fov의 절반값
            const halfFov = THREE.Math.degToRad(cameraPerspective.fov * 0.5);

            // 모델을 화면에 꽉 채우기 위한 적당한 거리
            const distance = halfSizeModel / Math.tan(halfFov);

            // 모델 중심에서 카메라 위치로 향하는 방향 단위 벡터 계산
            const direction = (new THREE.Vector3()).subVectors(camera.position, centerBox).normalize();

            // "단위 방향 벡터" 방향으로 모델 중심 위치에서 distance 거리에 대한 위치
            const position = direction.multiplyScalar(distance).add(centerBox);
            camera.position.copy(position);

            // 모델의 크기에 맞춰 카메라의 near, far 값을 대략적으로 조정
            camera.near = sizeBox / 100;
            camera.far = sizeBox * 100;

            // 카메라 기본 속성 변경에 따른 투영행렬 업데이트
            camera.updateProjectionMatrix();

            // 카메라 모델의 중심을 바라 보도록 함
            camera.lookAt(centerBox.x, centerBox.y, centerBox.z);

            // orbitControl이 객체중심에서 회전하도록
            controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
            controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);

        }

        function onKeyDown( event ) {

            switch ( event.keyCode ) {

                case 70: /*F*/
                    zoomFit(model, "Z", true);
                    break;

                case 66: /*b*/
                    zoomFit(model, "Z", false);
                    break;                    

                case 82: /*R*/
                    zoomFit(model, "X", true);
                    break;

                case 76: /*L*/
                    zoomFit(model, "X", false);
                    break;

                case 84: /*T*/
                    zoomFit(model, "Y", true);
                    break;

                case 65: /*A*/
                    if( controlsPerspective.autoRotate || controlsOrtho.autoRotate ) {
                        controlsPerspective.autoRotate = false;
                        controlsOrtho.autoRotate = false;
                    } else {
                        controlsPerspective.autoRotate = true;
                        controlsOrtho.autoRotate = true;
                    }
                    break;

                case 67: /*C*/
                    if( camera == cameraPerspective ) {
                        // perspective에서 ortho로 변경
                        camera = cameraOrtho;
                        camera.position.copy( cameraPerspective.position );
                        cameraOrtho.updateProjectionMatrix();

                        camera.add(light);

                        controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
                        // controlsOrtho.update();
                    } else {
                        // ortho에서 perspective로 변경
                        camera = cameraPerspective;
                        camera.position.copy( cameraOrtho.position );
                        cameraPerspective.updateProjectionMatrix();
                        
                        camera.add(light);

                        controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
                        // controlsPerspective.update();
                    }
                    break;
                    
                case 87: /*W*/
                    scene.traverse( ( child )=> {
                        if( !child.isMesh ) return;

                        if( child.material.wireframe ) {
                            child.material.wireframe = false;
                        } else {
                            child.material.wireframe = true; 
                        }
                    })
                    break;
            }

        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;

            camera.left = -height * aspect;
            camera.right = height * aspect;
            camera.top = height;
            camera.bottom = -height;

            camera.updateProjectionMatrix();

            renderer.setSize( width, height );
        }

        function animate() {
            controlsPerspective.update();
            controlsOrtho.update();
            
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( scene, camera );
        }

        function onProgress( xhr ) {
            if ( xhr.lengthComputable ) {
                updateProgressBar( xhr.loaded / xhr.total );
                console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );
            }
        }

        function onError( error ) {
            const message = 'Error loading model';
            progressBarDiv.innerText = message;
            console.log( message );
            console.error( error );
        }

        function showProgressBar() {
            document.body.appendChild( progressBarDiv );
        }

        function hideProgressBar() {
            document.body.removeChild( progressBarDiv );
            console.log( "설명하지 못한다면, 그것은 진정으로 이해한 것이 아니다.");
            console.log( "더구나, 지금은 설명도 필요없는 시대다!");
        }

        function updateProgressBar( fraction ) {
            progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';
        }

        function createUI() {

            // onFinishChange 적용
            const gui = new GUI();
            
            const clippingFolder = gui.addFolder( '절단면' )
            const props = { 
                x : box.max.x,
                negateX : false,
                y : box.max.y,
                negateY : false,
                z : box.max.z,
                negateZ : false,
            };
            clippingFolder.add( props, 'x', box.min.x, box.max.x, 0.01 ).onChange( (value) => {
                if(props.negateX) {
                    clippingPlanes[ 0 ].constant = -value;
                } else {
                    clippingPlanes[ 0 ].constant = value;
                }
            });
            clippingFolder.add( props, 'negateX').name( 'x방향반대' ).onChange( ()=>{
                clippingPlanes[ 0 ].negate();
            });
            clippingFolder.add( props, 'y', box.min.y, box.max.y ).onChange( (value)=>{
                if(props.negateY) {
                    clippingPlanes[ 1 ].constant = -value;
                } else {
                    clippingPlanes[ 1 ].constant = value;
                }
            });
            clippingFolder.add( props, 'negateY').name( 'y방향반대' ).onChange( ()=>{
                clippingPlanes[ 1 ].negate();
            });

            clippingFolder.add( props, 'z', box.min.z, box.max.z ).onChange( (value)=>{
                if(props.negateZ) {
                    clippingPlanes[ 2 ].constant = -value;
                } else {
                    clippingPlanes[ 2 ].constant = value;
                }
            });
            clippingFolder.add( props, 'negateZ').name( 'z방향반대' ).onChange( ()=>{
                clippingPlanes[ 2 ].negate();
            });
            // clippingFolder.open();
        }


    </script>
    
</body>

</html>