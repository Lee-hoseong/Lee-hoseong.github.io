<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D_Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <style>
        html, body {
            margin : 0;
            height : 100%
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            /* left : 50%; */
            padding: 10px;
            /* transform : translate( -50% ); */
            /* text-align: center; */
            background: rgba( 0, 0, 0, 0 );
            color: black;
            font-size: 12px;
        } 

        .obit-controls-gizmo {
            position: absolute;
            top: 2em;
            right: 2em;
            z-index: 1000;
            background-color: #FFF0;
            border-radius: 100%;
            transition: background-color .15s  linear;
            cursor: pointer;
        }

        .obit-controls-gizmo.dragging, 
        .obit-controls-gizmo:hover {
            background-color: #FFF3;
        }

        .obit-controls-gizmo.inactive {
            pointer-events: none;
            background-color: #FFF0  !important;
        }

    </style>
</head>
<body>

    <!-- <div class="container-fluid">
        <div class="fixed-top ms-2" style="color:black; font-weight: 700;">Hanmac Family 3D Viewer</div>

        <div class="fixed-bottom" style="background: #18312D;  color: white; ">
            <div class="row text-center">
                <div class="col"><i class="bi-play-btn" style="font-size: 2rem"></i><br>자동회전</div>
                <div class="col"><i class="bi-boxes" style="font-size: 2rem"></i><br>원근/직교</div>
                <div class="col"><i class="bi bi-brightness-low" style="font-size: 2rem"></i><br>불투명도</div>
                <div class="col"><i class="bi bi-sliders" style="font-size: 2rem"></i><br>클리핑</div>
                <div class="col"><i class="bi bi-ui-checks" style="font-size: 2rem"></i><br>설정</div>
              </div>
        </div>
    </div> -->
    

    <!-- <i class="bi-github" role="img" aria-label="GitHub"></i> -->

    <!-- <div id="info" class="btn-group btn-group-sm" role="group" aria-label="Basic checkbox toggle button group">
        <input type="checkbox" class="btn-check" id="btncheck1" autocomplete="off" checked>
        <label class="btn btn btn-outline-secondary" for="btncheck1">Perspective</label>
        
        <input type="checkbox" class="btn-check" id="btncheck2" autocomplete="off">
        <label class="btn btn-outline-secondary" for="btncheck2">Wireframe</label>
        
        <input type="checkbox" class="btn-check" id="btncheck3" autocomplete="off" checked>
        <label class="btn btn-outline-secondary" for="btncheck3">Auto rotate</label>
    </div> -->

    <div id="info">
        <b>Camera Type</b>
        <br>
        <b style="color:#2FA1D6">C : </b>Perspective/Orthographic
        <br>
        <b>Wireframe</b>
        <br>
        <b style="color:#2FA1D6">W : </b>On/Off
        <br>
        <b>Auto Rotate</b>
        <br>
        <b style="color:#2FA1D6">A : </b>On/Off
        <br>
        <b>View Mode</b>
        <br>
        <b style="color:#2FA1D6">F : </b>Front, <b style="color:#2FA1D6">B : </b>Back, <b style="color:#2FA1D6">R : </b>Right, <b style="color:#2FA1D6">L : </b>Left, <b style="color:#2FA1D6">T : </b>Top 
    </div>

    <canvas id="c"></canvas>

    <script type="module">
        
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js'; // min으로 교체
        import { GLTFLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/GLTFLoader.js';
        import { GUI } from 'https://Lee-hoseong.github.io/jsm/libs/dat.gui.module.js';
        import { RGBELoader } from 'https://Lee-hoseong.github.io/jsm/loaders/RGBELoader.js';

        import { OrbitControls } from 'https://Lee-hoseong.github.io//ThreeOrbitControlsGizmo/OrbitControls.js';
        import { OrbitControlsGizmo  } from 'https://Lee-hoseong.github.io/ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';
        // import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';

        // variable
        let camera, scene, light, renderer;
        let cameraPerspective, cameraOrtho;
        let controlsPerspective, controlsOrtho;
        let controlsGizmoPerspective, controlsGizmoOrtho;
        let box, sizeBox, centerBox, model;
        let progressBarDiv;
        let clippingPlanes;


        create3DViewer();
        animate();

        function create3DViewer () {
            const canvas = document.querySelector('#c'); 
            
            // scene
            scene = new THREE.Scene();               
            scene.background = new THREE.Color( 0xf0f0f0 );         

            // camera
            const aspect = window.innerWidth/window.innerHeight;
            
            cameraPerspective = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            scene.add( cameraPerspective );

            cameraOrtho = new THREE.OrthographicCamera( 
                window.innerWidth/-aspect, 
                window.innerWidth/aspect, 
                window.innerHeight/aspect, 
                window.innerHeight/-aspect, 0.1, 1000 
            );
            // cameraOrtho.zoom = 1;
            scene.add( cameraOrtho );

            camera = cameraPerspective;
            

            // OrbitControl
            controlsPerspective = new OrbitControls( cameraPerspective, canvas );
            controlsPerspective.autoRotate = true;
            controlsPerspective.autoRotateSpeed = -3;
            controlsPerspective.screenSpacePanning = true;
     
            controlsOrtho = new OrbitControls( cameraOrtho, canvas );
            controlsOrtho.autoRotate = true;
            controlsOrtho.autoRotateSpeed = -3;
            controlsOrtho.screenSpacePanning = true;


            // Gizmo
            controlsGizmoPerspective = new OrbitControlsGizmo(controlsPerspective, { size:  100, padding:  8 });
            controlsGizmoOrtho = new OrbitControlsGizmo(controlsOrtho, { size:  100, padding:  8 });

            document.body.appendChild(controlsGizmoPerspective.domElement);
          

            // Axes
            const axes = new THREE.AxesHelper( 1 ); 
            scene.add( axes );
            

            // light
            scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );
            
            light = new THREE.DirectionalLight( 'white', 3 );
            light.position.set( -1, 2, 4 );
            // light.position.set( 0.5, 0, 0.866 );
            // light.target.position.set( 0, 0, 0 );
            // light.castShadow = true;
            // scene.add(light);
            camera.add( light );


            // light helper
            // const lightHelper = new THREE.DirectionalLightHelper( light, 10 );
            // scene.add( lightHelper );


            //
            new RGBELoader()
                .setDataType( THREE.FloatType )
                .setPath( 'https://Lee-hoseong.github.io/texture/' )
                .load( 'short_tunnel_1k.hdr', function ( texture ) {
                // .load( 'footprint_court_2k.hdr', function ( texture ) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                } );


            // Render
            renderer = new THREE.WebGLRenderer( { canvas, antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );

            renderer.outputEncoding = THREE.sRGBEncoding; // 출력 렌더링 인코딩을 제어
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // HDR값을 LDR값으로 변환
            renderer.toneMappingExposure = 1.0;

            renderer.shadowMap.enabled = true;

            renderer.physicallyCorrectLights = true

            renderer.localClippingEnabled = true;


            // resize
            window.addEventListener( 'resize', onWindowResize );


            // keydown
            document.addEventListener( 'keydown', onKeyDown );


            // progressBar
            progressBarDiv = document.createElement( 'div' );
            progressBarDiv.innerText = 'Loading...';
            progressBarDiv.style.fontSize = '3em';
            progressBarDiv.style.color = '#888';
            progressBarDiv.style.display = 'block';
            progressBarDiv.style.position = 'absolute';
            progressBarDiv.style.top = '50%';
            progressBarDiv.style.width = '100%';
            progressBarDiv.style.textAlign = 'center';


            updateProgressBar( 0 );
            showProgressBar();


            // GLTF Loader
            let gltfLoader = new GLTFLoader();
            // gltfLoader.setPath( 'https://Lee-hoseong.github.io/release/' );
            gltfLoader.setPath( 'https://Lee-hoseong.github.io/model/' );
            
            // const url = 'formwork.glb';
            const url = '3dtest.glb';

            gltfLoader.load( url, function ( gltf ) {

                /*
                gltf.scene.traverse( function( node ) {
                    if ( node instanceof THREE.Mesh ) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        node.geometry.center();
                    }
                });
                */

                model = gltf.scene;

                model.scale.x = 1;
                model.scale.y = 1;
                model.scale.z = 1;
                
                scene.add( model );

                zoomFit( model, camera, "Z", true );

                // clipping
                clippingPlanes = [ 
                    new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), box.max.x ),
                    new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), box.max.y ),
                    new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), box.max.z )
                ];


                /*
                // clipping Helper
                const planeHelpers = clippingPlanes.map( p => new THREE.PlaneHelper( p, 5, 'black' ) );
				planeHelpers.forEach( ph => {
					ph.visible = true;
					scene.add( ph );
				} );
                */

                gltf.scene.traverse( ( child )=> {
                    if( !child.isMesh ) return;

                    child.material.clippingPlanes = clippingPlanes;
                    child.material.transparent = true;

                })
                
                console.log( "model :", model );

                // grid
                const size = 2*sizeBox;
                const divisions = 20;
                const gridHelper = new THREE.GridHelper( size, divisions );
                gridHelper.position.x = centerBox.x;
                gridHelper.position.y = 0;
                gridHelper.material.opacity = 0.4;
                gridHelper.material.transparent = true;
                scene.add( gridHelper );

                hideProgressBar();
                // createUI();

            }, onProgress, onError );

        }

        function zoomFit(obj3D, viewMode, bFront) {
            box = new THREE.Box3().setFromObject(obj3D);
            sizeBox = box.getSize(new THREE.Vector3()).length();
            centerBox = box.getCenter(new THREE.Vector3());

            // viewmode 설정
            let offsetX =0, offsetY=0, offsetZ=0;
            viewMode === "X" ? offsetX = 1 : (viewMode === "Y") ? offsetY = 1 : offsetZ = 1;

            // 앞면을 볼지 뒷면을 볼지
            if( !bFront ) {
                offsetX *= -1; 
                offsetY *= -1; 
                offsetZ *= -1; 
            }

            // 카메라 위치 설정
            camera.position.set( 
                centerBox.x + offsetX, centerBox.y + offsetY, centerBox.z + offsetZ
            );
            
            // 모델 크기의 절반값
            const halfSizeModel = sizeBox * 0.5;

            // 카메라의 fov의 절반값
            const halfFov = THREE.Math.degToRad(cameraPerspective.fov * 0.5);

            // 모델을 화면에 꽉 채우기 위한 적당한 거리
            const distance = halfSizeModel / Math.tan(halfFov);

            // 모델 중심에서 카메라 위치로 향하는 방향 단위 벡터 계산
            const direction = (new THREE.Vector3()).subVectors(camera.position, centerBox).normalize();

            // "단위 방향 벡터" 방향으로 모델 중심 위치에서 distance 거리에 대한 위치
            const position = direction.multiplyScalar(distance).add(centerBox);
            camera.position.copy(position);

            // 모델의 크기에 맞춰 카메라의 near, far 값을 대략적으로 조정
            camera.near = sizeBox / 100;
            camera.far = sizeBox * 100;

            // 카메라 기본 속성 변경에 따른 투영행렬 업데이트
            camera.updateProjectionMatrix();

            // 카메라 모델의 중심을 바라 보도록 함
            camera.lookAt(centerBox.x, centerBox.y, centerBox.z);

            // orbitControl이 객체중심에서 회전하도록
            controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
            controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
        }

        function onKeyDown( event ) {
            switch ( event.keyCode ) {

                case 70: /*F*/
                    zoomFit(model, "Z", true);
                    break;

                case 66: /*b*/
                    zoomFit(model, "Z", false);
                    break;                    

                case 82: /*R*/
                    zoomFit(model, "X", true);
                    break;

                case 76: /*L*/
                    zoomFit(model, "X", false);
                    break;

                case 84: /*T*/
                    zoomFit(model, "Y", true);
                    break;

                case 65: /*A*/
                    changeAutoRotate();
                    break;

                case 67: /*C*/
                    changeCamera();
                    break;
                    
                case 87: /*W*/
                    changeWireframe();
                    break;
            }

        }

        document.getElementById("btncheck1").addEventListener("change", changeCamera );
        document.getElementById("btncheck2").addEventListener("change", changeWireframe );
        document.getElementById("btncheck3").addEventListener("change", changeAutoRotate );


        function changeAutoRotate () {
            if( controlsPerspective.autoRotate || controlsOrtho.autoRotate ) {
                controlsPerspective.autoRotate = false;
                controlsOrtho.autoRotate = false;
            } else {
                controlsPerspective.autoRotate = true;
                controlsOrtho.autoRotate = true;
            }
        }

        function changeWireframe () {
            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                if( child.material.wireframe ) {
                    child.material.wireframe = false;
                } else {
                    child.material.wireframe = true; 
                }
            });
        }
      
        function changeCamera () {
            if( camera == cameraPerspective ) {
                // perspective에서 ortho로 변경
                cameraOrtho.near = cameraPerspective.near;
                cameraOrtho.far = cameraPerspective.far;
                cameraOrtho.zoom = Math.min( window.innerWidth / (box.max.x - box.min.x), window.innerHeight / (box.max.y - box.min.y)) * 0.4

                camera = cameraOrtho;
                camera.position.copy( cameraPerspective.position );
                cameraOrtho.updateProjectionMatrix();

                camera.add(light);

                controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
                // controlsOrtho.update();

                // Gizmo
                document.body.removeChild(controlsGizmoPerspective.domElement);
                document.body.appendChild(controlsGizmoOrtho.domElement);

                // console.log( 'controlsGizmo', controlsGizmo );

            } else {
                // ortho에서 perspective로 변경
                camera = cameraPerspective;
                camera.position.copy( cameraOrtho.position );
                cameraPerspective.updateProjectionMatrix();
                
                camera.add(light);

                controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
                // controlsPerspective.update();

                // Gizmo
                document.body.removeChild(controlsGizmoOrtho.domElement);
                document.body.appendChild(controlsGizmoPerspective.domElement);
            }
        }


        // 기본 렌더
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;

            camera.left = -height * aspect;
            camera.right = height * aspect;
            camera.top = height;
            camera.bottom = -height;
      
            camera.updateProjectionMatrix();

            renderer.setSize( width, height );
        }

        function animate() {
            controlsPerspective.update();
            controlsOrtho.update();
            
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( scene, camera );
        }


        // 프로그래스 관련
        function onProgress( xhr ) {
            if ( xhr.lengthComputable ) {
                updateProgressBar( xhr.loaded / xhr.total );
                console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );
            }
        }

        function onError( error ) {
            const message = 'Error loading model';
            progressBarDiv.innerText = message;
            console.log( message );
            console.error( error );
        }

        function showProgressBar() {
            document.body.appendChild( progressBarDiv );
        }

        function hideProgressBar() {
            document.body.removeChild( progressBarDiv );
            console.log( "설명하지 못한다면, 그것은 진정으로 이해한 것이 아니다.");
            console.log( "더구나, 지금은 설명도 필요없는 시대다!");
        }

        function updateProgressBar( fraction ) {
            progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';
        }


        // GUI
        function createUI() {

            // onFinishChange 적용
            const gui = new GUI();
            
            const clippingFolder = gui.addFolder( '절단면' );

            const props = { 
                x : box.max.x,
                negateX : false,
                y : box.max.y,
                negateY : false,
                z : box.max.z,
                negateZ : false,

                opacity : 1,
            };

            clippingFolder.add( props, 'x', box.min.x, box.max.x, 0.01 ).onChange( (value) => {
                if(props.negateX) {
                    clippingPlanes[ 0 ].constant = -value;
                } else {
                    clippingPlanes[ 0 ].constant = value;
                }
            });

            clippingFolder.add( props, 'negateX').name( '반전x' ).onChange( ()=>{
                clippingPlanes[ 0 ].negate();
            });

            clippingFolder.add( props, 'y', box.min.y, box.max.y ).onChange( (value)=>{
                if(props.negateY) {
                    clippingPlanes[ 1 ].constant = -value;
                } else {
                    clippingPlanes[ 1 ].constant = value;
                }
            });

            clippingFolder.add( props, 'negateY').name( '반전y' ).onChange( ()=>{
                clippingPlanes[ 1 ].negate();
            });

            clippingFolder.add( props, 'z', box.min.z, box.max.z ).onChange( (value)=>{
                if(props.negateZ) {
                    clippingPlanes[ 2 ].constant = -value;
                } else {
                    clippingPlanes[ 2 ].constant = value;
                }
            });

            clippingFolder.add( props, 'negateZ').name( '반전z' ).onChange( ()=>{
                clippingPlanes[ 2 ].negate();
            });

            const opacityFolder = gui.addFolder( '투명도' );
            opacityFolder.add( props, 'opacity', 0, 1, 0.01 ).onChange( (value)=>{
                scene.traverse( ( child )=> {
                    if( !child.isMesh ) return;

                    child.material.opacity = value;
                })

            });
            
            // opacityFolder.open();
        }

    </script>
</body>
</html>