<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TunnelZainer_Web</title>
    <style>
        html, body {
            margin : 0;
            height : 100%
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }

        #button {
            position: absolute;
            left: 5px;
            bottom: 5px;
            padding: 10px;
            background: #11ffee00;
            color: #2FA1D6;
            border: #11ffee00;
            cursor: pointer;
        }
        
        #button:hover {
            background: #444;
        }
        
        #info {
            position: absolute;
            top: 40px;
            padding: 10px;
            background: rgba( 0, 0, 0, 0 );
            color: black;
            font-size: 12px;
        }        

        /* Add a black background color to the top navigation */
        .topnav {
            position: absolute;
            background-color: #000000;
            overflow: hidden;
        }
        
        /* Style the links inside the navigation bar */
        .topnav a {
            float: left;
            color: #f2f2f2;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
            font-size: 12px;
        }
        
        /* Change the color of links on hover */
        .topnav a hover {
            background-color: #ddd;
            color: black;
        }
        
        /* Add a color to the active/current link */
        .topnav a.active {
            background-color: #2FA1D6;
            color: white;
        }

        /* 로딩 스피너 */
        #loading {
            display: block;
            position: absolute;
            left: 50%;
            top: 50%;
            width: 150px;
            height: 150px;
            margin: -75px 0 0 -75px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #9370DB;
            -webkit-animation: spin 2s linear infinite;
            animation: spin 2s linear infinite;
        }

        #loading:before {
            content: "";
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #BA55D3;
            -webkit-animation: spin 3s linear infinite;
            animation: spin 3s linear infinite;
        }

        #loading:after {
            content: "";
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: #FF00FF;
            -webkit-animation: spin 1.5s linear infinite;
            animation: spin 1.5s linear infinite;
        }

        @-webkit-keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        @keyframes spin {
            0%   {
                -webkit-transform: rotate(0deg);
                -ms-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            100% {
                -webkit-transform: rotate(360deg);
                -ms-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }   


        
    </style>
</head>
<body>
    <div class="topnav">
        <a href='TZ_Web1.html'>1. 도로횡단</a>
        <a href='TZ_Web2.html'>2. 터널단면</a>
        <a href='TZ_Web3.html'>3. 지보패턴</a>
        <a href='TZ_Web4.html'>4. 강지보공</a>
        <a href='TZ_Web5.html'>5. 라이닝구조도</a>
        <a href='TZ_Web6.html'>6. 배수계획</a>
        <a class="active" href='TZ_Web7.html'>7. 연결통로</a>
        <a href='TZ_Web8.html'>8. 갱문형식</a>
        <a href='TZ_Web9.html'>9. 부대시설</a>
    </div>

    <div id="loading"></div>
    
    <canvas id="c"></canvas>

    <div id="info"> <b>R:</b> Right, <b>F:</b> Front </div>
    
    <button id="button" type="button" >Export Model</button>

    <script type="module">
        
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js';
        import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';
        import { GUI } from 'https://Lee-hoseong.github.io/jsm/libs/dat.gui.module.js';
        import { STLExporter } from 'https://Lee-hoseong.github.io/jsm/exporters/STLExporter.js';
        
        import { GLTFLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/GLTFLoader.js';
        // import { CSG } from 'https://Lee-hoseong.github.io/csg/looeee/csg.module.js';//looeee
        import { CSG } from 'https://Lee-hoseong.github.io/csg/looeee_NPM/CSG.js';//looeee
        import { ConvexGeometry } from 'https://Lee-hoseong.github.io/jsm/geometries/ConvexGeometry.js';
        

        // 로딩화면
        function showLoading() {

            document.getElementById("loading").style.display = "block"

        }

        function hideLoading() {

            document.getElementById("loading").style.display = "none"

        }


        // Matrix 선언
        const matrix = new THREE.Matrix4();


        // GLTF Loader 선언
        let loader = new GLTFLoader().setPath( 'https://Lee-hoseong.github.io/model/' );        


        // 메쉬컨테이너
        let showContainer = [];


        // Three js 기본변수
        let camera, scene, renderer, clippingPlane, orbitControls


        // 계산값 불러오기
        const roadWidth = JSON.parse( sessionStorage.getItem( '도로폭' ) );
        const shoulderLeft = JSON.parse( sessionStorage.getItem( '좌측길어깨폭' ) );
        const shoulderRight = JSON.parse( sessionStorage.getItem( '우측길어깨폭' ) );

        const crossSlopeMin = JSON.parse( sessionStorage.getItem( '최소편경사' ) );
        const crossSlopeMax = JSON.parse( sessionStorage.getItem( '최대편경사' ) );

        const concrete = JSON.parse( sessionStorage.getItem( '콘크리트포장두께' ) );
        const cementeFilter = JSON.parse( sessionStorage.getItem( '필터층포장두께' ) );

        const liningT0 = JSON.parse( sessionStorage.getItem( '라이닝두께') );

        const roadCenterDistance = JSON.parse( sessionStorage.getItem( '이격거리(최종)' ) );

        const r1ThetaLt= JSON.parse( sessionStorage.getItem( '중심각좌측' ) );
        const r1ThetaRt = JSON.parse( sessionStorage.getItem( '중심각우측' ) );
        const r1Height = JSON.parse( sessionStorage.getItem( 'r1중심고' ) );
        const r1Final = JSON.parse( sessionStorage.getItem( 'r1반지름' ) );

        const r2Origin = JSON.parse( sessionStorage.getItem( 'r2원점' ) );
        const r2Final = JSON.parse( sessionStorage.getItem( 'r2반지름' ) );

        const r3Origin = JSON.parse( sessionStorage.getItem( 'r3원점' ) );
        const r3Final = JSON.parse( sessionStorage.getItem( 'r3반지름' ) );

        const r4Origin = JSON.parse( sessionStorage.getItem( 'r4원점' ) );
        const r4Final = JSON.parse( sessionStorage.getItem( 'r4반지름' ) );

        const r5Origin = JSON.parse( sessionStorage.getItem( 'r5원점' ) );
        const r5Final = JSON.parse( sessionStorage.getItem( 'r5반지름' ) );


        const footingType = JSON.parse( sessionStorage.getItem( '공동구타입' ) );
        const footingHeight = JSON.parse( sessionStorage.getItem( '공동구높이' ) );
        const footingLtType = JSON.parse( sessionStorage.getItem( '좌측공동구' ) );
        const footingRtType = JSON.parse( sessionStorage.getItem( '우측공동구' ) );

        const marginLeft = JSON.parse( sessionStorage.getItem( '좌측측대(최종)' ) );
        const marginRight = JSON.parse( sessionStorage.getItem( '우측측대(최종)' ) );

        const springLineEL =  JSON.parse( sessionStorage.getItem( '스프링라인EL' ) );

        const crossSlopeStandard = JSON.parse( sessionStorage.getItem('적용편경사' ) );


        // 파라메트릭 값
        const ui = {

            // 공통
            crossSlopeStandard :  crossSlopeStandard,
            totalLength : 20, // 본선 접속부 보강 길이

            // 구분
            crossPsgeType : '차량용', // 연결통로 타입
            category : '일반도', // 카테고리

            // 연결통로 각도
            verticalAngle : 0,
            horizontalAngle : 0,        
            

            // <보강도>
            // 본선 
            longSpacing : 1.500, // 굴진장/지보장 (longitudinalSpacing)
            
            shotcrete : 0.120, // 숏크리트 두께
            
            rbZone : '전단면', // 록볼트 영역           
            rbLength : 3.000, // 록볼트 길이
            rbCircSpacing : 1.500, // 록볼트 횡간격(Circumferential Spacing)
            rbLtLastDel : false, 
            rbRtLastDel : false,
            
            steelribType : 'LG-50', // 강지보타입

            // 연결통로 
            psgeLongSpacing : 1.500, // 굴진장/지보장 (longitudinalSpacing)

            psgeShotcrete : 0.120, // 숏크리트 두께

            psgeRbZone : '전단면', // 록볼트 영역   
            psgeRbLength : 3.000, // 록볼트 길이
            psgeRbCircSpacing : 1.500, // 록볼트 횡간격(Circumferential Spacing)

            psgeSteelribType : 'LG-50', // 강지보타입


            // <구조도>
            // 본선
            coverDepth : 0.060, // 피복두께
            
            mainCompDia : 0.013, // 주철근(수직) 직경
            mainTensDia : 0.013,
            
            outMaxLen : 8.000, // 장철근 외측 최대길이
            inMaxLen : 8.000, // 장철근 내측 최대길이
            
            outControl : 0.500, // 주철근 위치조정
            inControl : 0.700,
            
            lap : 0.500, // 겹이음길이
            ctc : 0.125, // 종방향 간격
            
            distrDia : 0.013, // 배력철근(수평) 직경
            distrSpacing : 0.200, // 배력철근 간격


            // 연결통로
            psgeCoverDepth : 0.060, // 피복두께
            
            psgeMainCompDia : 0.013, // 주철근(수직) 직경
            psgeMainTensDia : 0.013,
            
            psgeOutMaxLen : 8.000, // 장철근 외측 최대길이
            psgeInMaxLen : 8.000, // 장철근 내측 최대길이
            
            psgeOutControl : 0.500, // 주철근 위치조정
            psgeInControl : 0.700,
            
            psgeLap : 0.500, // 겹이음길이
            psgeCtc : 0.200, // 종방향 간격
            
            psgeDistrDia : 0.013, // 배력철근(수평) 직경
            psgeDistrSpacing : 0.200, // 배력철근 간격

        };
        
        const psgeLength = 10; // 피난연결통로 길이
        const stairLength = 0.5; // 본선 접속부 계단 길이


        // 본선 접속부의 길이
        const pedestrianConnLength = 7; // 대인용의 경우
        const vehicleConnLength = 10; // 차량용의 경우
        const heavyGoodsConnLength = 14; // 대형차량용의 경우



        // 자연환기 계단 형상
        const naturalStair1 = [];
        naturalStair1.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.8700,  0.2850 ) );
        naturalStair1.push( new THREE.Vector2 ( -0.8895,  0.4800 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.0500,  0.4800 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.0500,  0.4200 ) );// 9
        naturalStair1.push( new THREE.Vector2 ( -1.1000,  0.4200 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.4000, -0.0210 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.4000,  0.4200 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.4500,  0.4200 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.4500,  0.4800 ) );
        naturalStair1.push( new THREE.Vector2 ( -1.5000,  0.4800 ) );  

        const naturalStair2 = [];
        naturalStair2.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.8700,  0.2850 ) );
        naturalStair2.push( new THREE.Vector2 ( -0.8730,  0.3150 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.0500,  0.3150 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.0500,  0.2550 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.1000,  0.2550 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.4000, -0.0210 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.4000,  0.2550 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.4500,  0.2550 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.4500,  0.3150 ) );
        naturalStair2.push( new THREE.Vector2 ( -1.5000,  0.3150 ) );

        const naturalStair3 = [];
        naturalStair3.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        naturalStair3.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        naturalStair3.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        naturalStair3.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        naturalStair3.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        naturalStair3.push( new THREE.Vector2 ( -0.7774,  0.1500 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.0500,  0.1500 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.0500,  0.0900 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.1000,  0.0900 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.4000, -0.0210 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.4000,  0.0900 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.4500,  0.0900 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.4500,  0.1500 ) );
        naturalStair3.push( new THREE.Vector2 ( -1.5000,  0.1500 ) );


        // 자연환기-대인용의 접속부공동구 형상
        const naturalPedestrianConn = [];
        naturalPedestrianConn.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.0500, -0.0210 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.0500, -0.0810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.1000, -0.0810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.1000, -0.3810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.4000, -0.3810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.4000, -0.0810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.4500, -0.0810 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.4500, -0.0210 ) );
        naturalPedestrianConn.push( new THREE.Vector2 ( -1.5000, -0.0210 ) );


        // 자연환기-차량용-대형차량용의 접속부공동구 형상
        const naturalVehicleConn = [];
        naturalVehicleConn.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.0500, -0.0210 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.0500, -0.0510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.1000, -0.0510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.1000, -0.3510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.4000, -0.3510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.4000, -0.0510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.4500, -0.0510 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.4500, -0.0210 ) );
        naturalVehicleConn.push( new THREE.Vector2 ( -1.5000, -0.0210 ) );


        // 기계환기 계단 형상
        const mechanicalStair1 = [];
        mechanicalStair1.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.8700,  0.2850 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -0.8895,  0.4800 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.0500,  0.4800 ) ); // 8
        mechanicalStair1.push( new THREE.Vector2 ( -1.0500,  0.4200 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.1000,  0.4200 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.6000, -0.0210 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.6000,  0.4200 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.6500,  0.4200 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.6500,  0.4800 ) );
        mechanicalStair1.push( new THREE.Vector2 ( -1.7000,  0.4800 ) );

        const mechanicalStair2 = [];
        mechanicalStair2.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.8494,  0.2550 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.8700,  0.2850 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -0.8730,  0.3150 ) ); 
        mechanicalStair2.push( new THREE.Vector2 ( -1.0500,  0.3150 ) ); // 9
        mechanicalStair2.push( new THREE.Vector2 ( -1.0500,  0.2550 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.1000,  0.2550 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.6000, -0.0210 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.6000,  0.2550 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.6500,  0.2550 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.6500,  0.3150 ) );
        mechanicalStair2.push( new THREE.Vector2 ( -1.7000,  0.3150 ) );

        const mechanicalStair3 = [];
        mechanicalStair3.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.7500,  0.1100 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -0.7774,  0.1500 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.0500,  0.1500 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.0500,  0.0900 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.1000,  0.0900 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.1000, -0.0210 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.6000, -0.0210 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.6000,  0.0900 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.6500,  0.0900 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.6500,  0.1500 ) );
        mechanicalStair3.push( new THREE.Vector2 ( -1.7000,  0.1500 ) );


        // 기계환기-대인용의 접속부공동구 형상
        const mechanicalPedestrianConn = [];
        mechanicalPedestrianConn.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.0500, -0.0210 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.0500, -0.0810 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.1000, -0.0810 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.1000, -0.5210 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.5000, -0.5210 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.6000, -0.0810 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.6500, -0.0810 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.6500, -0.0210 ) );
        mechanicalPedestrianConn.push( new THREE.Vector2 ( -1.7000, -0.0210 ) );


        // 기계환기-차량용-대형차량용의 접속부공동구 형상
        const mechanicalVehicleConn = [];
        mechanicalVehicleConn.push( new THREE.Vector2 (  0.0000,  0.0000 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -0.6500, -0.0130 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -0.6500, -0.1650 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -0.7500, -0.1650 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -0.7500, -0.0150 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.0500, -0.0210 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.0500, -0.0510 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.1000, -0.0510 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.1000, -0.4910 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.5000, -0.4910 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.6000, -0.0510 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.6500, -0.0510 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.6500, -0.0210 ) );
        mechanicalVehicleConn.push( new THREE.Vector2 ( -1.7000, -0.0210 ) );


        // Run        
        initGraphic();
        designTunnel();
        function designTunnel() {

            showLoading();

            setTimeout( function() { designTunnel333() }, 200 );

        }
        createUI();
        

        function initGraphic() {
            
            const canvas = document.querySelector('#c'); 
            
            // camera(필수)

            // Perspective
            camera = new THREE.PerspectiveCamera( 50, 2, 0.1, 1000 ); //화각, 2, 가까운면, 먼쪽면
            camera.position.set( 7, 7, 40 );             
            

            // Orthographic
            // camera = new THREE.OrthographicCamera( 
            //     window.innerWidth / - 64, window.innerWidth / 64, window.innerHeight / 64, window.innerHeight / - 64, 0.1, 1000 
            // ); //left. right, top, bottom, near, far 
            // camera.position.set( 0, 0, 40 );
            // // camera.position.set( -40, 0, 0 ); 
            

            // OrbitControl : 뷰 확대 및 회전
            orbitControls = new OrbitControls( camera, canvas );
            // orbitControls.target.set( 0, 3, 0 );
            orbitControls.target.set( 0, 0, 0 );
            orbitControls.update();
            

            // Scene(필수) : 컨테이너
            scene = new THREE.Scene();               
            scene.background = new THREE.Color( 0xf0f0f0 );
            

            // // 바닥면 : 그림자를 받기 위함
            // const planeGeometry = new THREE.PlaneBufferGeometry( 100, 100 );
            // planeGeometry.rotateX( - Math.PI/2 );
            // const planeMaterial = new THREE.ShadowMaterial( { opacity: 0.3 } );
            // const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            // plane.position.y = -1.999;
            // // plane.receiveShadow = true;
            // scene.add( plane );
            

            // // 바닥 그리드
            // const size = 30;
            // const divisions = 30;
            // const gridHelper = new THREE.GridHelper( size, divisions );
            // gridHelper.position.y = - 2;
            // gridHelper.material.opacity = 0.4;
            // gridHelper.material.transparent = true;
            // scene.add(gridHelper);
            

            // 좌표축 생성, x축:red, y축:green, z축:blue
            const axes = new THREE.AxesHelper(1); 
            scene.add(axes);
            

            // light(필수) : AmbientLight는 그림자와 상관없음     
            scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );
            
            const light = new THREE.DirectionalLight( 'white', 0.1 );
            // light.castShadow = true;
            scene.add(light);
            

            // light helper
            // const lightHelper = new THREE.SpotLightHelper( light, 10 );
            // scene.add( lightHelper );

            // 클리핑
            clippingPlane = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), 10 )
            

            // Render
            renderer = new THREE.WebGLRenderer( { canvas } );
            renderer.shadowMap.enabled = true;  

            // keydown
            document.addEventListener( 'keydown', onKeyDown );
            
        }
        


        function designTunnel333() {

            // 이전 메쉬 삭제
            showContainer.forEach( i => scene.remove( i ) )

            // 배열초기화
            showContainer = [];
            
            // 시간측정
            const start_time = (new Date()).getTime();             
            //

            // 도로중심선
            const roadCenterPoints = [];
            roadCenterPoints.push( new THREE.Vector2 ( -roadCenterDistance, - 2 ) );
            roadCenterPoints.push( new THREE.Vector2 ( -roadCenterDistance, roadWidth + shoulderRight ) );

            const roadCenterShape = new THREE.Shape( roadCenterPoints );
            
            const roadCenterDashLine = addDashLine(  roadCenterShape, 'dimgray' );
            // showContainer.push( roadCenterDashLine );

            // 터널중심선
            const tunnelCenterDashLine = addDashLine( roadCenterShape, 'dimgray' );
            tunnelCenterDashLine.position.set( roadCenterDistance, 0, 0);
            showContainer.push( tunnelCenterDashLine );

            // 콘크리트포장과 시멘트필터층
            const concreteLt = new THREE.Vector3( - roadCenterDistance - marginLeft, ( - roadCenterDistance - marginLeft ) * ui.crossSlopeStandard / 100 );
            const concreteRt = new THREE.Vector3( roadWidth - roadCenterDistance + marginRight, ( roadWidth - roadCenterDistance + marginRight ) * ui.crossSlopeStandard / 100 );

            const cementeFilterLt = new THREE.Vector3( concreteLt.x, concreteLt.y - concrete );
            const cementeFilterRt = new THREE.Vector3( concreteRt.x, concreteRt.y - concrete );

            const concretePavementShp = new THREE.Shape();
            concretePavementShp.moveTo( concreteLt.x, concreteLt.y );
            concretePavementShp.lineTo( concreteRt.x, concreteRt.y );
            concretePavementShp.lineTo( cementeFilterRt.x, cementeFilterRt.y );
            concretePavementShp.lineTo( cementeFilterLt.x, cementeFilterLt.y );
            concretePavementShp.lineTo( concreteLt.x, concreteLt.y ); //close Path

            const concretePavementExtr1 = addExtr( concretePavementShp, 'darkslategray', ui.totalLength, 0.9 );
            showContainer.push( concretePavementExtr1 ); 

            const cementeFilterShp = new THREE.Shape();
            cementeFilterShp.moveTo( cementeFilterLt.x, cementeFilterLt.y );
            cementeFilterShp.lineTo( cementeFilterRt.x, cementeFilterRt.y );
            cementeFilterShp.lineTo( cementeFilterRt.x, cementeFilterRt.y - cementeFilter );
            cementeFilterShp.lineTo( cementeFilterLt.x, cementeFilterLt.y - cementeFilter );
            cementeFilterShp.lineTo( cementeFilterLt.x, cementeFilterLt.y ); //close Path
            
            const cementeFilterExtr1 = addExtr( cementeFilterShp, 'silver', ui.totalLength, 0.9 );
            showContainer.push( cementeFilterExtr1 );

            // 편경사변화에 따른 공동구 위치 계산 
            const footingLtSlope = footingLtType.map( i => new THREE.Vector2 ( i.x + concreteLt.x, i.y + concreteLt.y ) );
            const footingRtSlope = footingRtType.map( i => new THREE.Vector2 ( i.x + concreteRt.x, i.y + concreteRt.y ) );

            // 접속부 공동구, 계단 타입 결정
            let footingConn, stair1, stair2, stair3

            if ( footingType =='자연환기' && ui.crossPsgeType == '대인용') {
                
                footingConn = naturalPedestrianConn
                stair1 = naturalStair1
                stair2 = naturalStair2
                stair3 = naturalStair3

            } else if ( footingType =='자연환기' && ( ui.crossPsgeType == '차량용' || ui.crossPsgeType == '대형차량용' ) ) {
                
                footingConn = naturalVehicleConn
                stair1 = naturalStair1
                stair2 = naturalStair2
                stair3 = naturalStair3

            } else if ( footingType !='자연환기' && ui.crossPsgeType == '대인용') {

                footingConn = mechanicalPedestrianConn
                stair1 = mechanicalStair1
                stair2 = mechanicalStair2
                stair3 = mechanicalStair3                

            } else if ( footingType !='자연환기' && ( ui.crossPsgeType == '차량용' || ui.crossPsgeType == '대형차량용' ) ) {

                footingConn = mechanicalVehicleConn
                stair1 = mechanicalStair1
                stair2 = mechanicalStair2
                stair3 = mechanicalStair3                 

            }

            // 본선 접속부 길이 결정
            let footingConnLength

            switch ( ui.crossPsgeType ) {

                case '대인용' :
                    footingConnLength = pedestrianConnLength
                    break;

                case '차량용' :
                    footingConnLength = vehicleConnLength
                    break;

                case '대형차량용' :
                    footingConnLength = heavyGoodsConnLength
                    break;

            }

            // 본선 터널 길이
            const mainTunnelLength = ( ui.totalLength - footingConnLength - stairLength*3*2 ) / 2;

            // 연결통로 접속부 보강구간
            const psgeReinforceL = ui.crossPsgeType == '대인용' ? 4 : 6;

            // 연결통로 접속부 net 보강길이
            const netReinforceL = psgeReinforceL - r3Origin.x + r3Final - ( - r2Origin.x + r2Final + 1.5 );
            
            // 편경사변화에 따른 본선 접속부 공동구 위치 계산 
            const footingConnSlope = footingConn.map( i => new THREE.Vector2( i.x + concreteLt.x, i.y + concreteLt.y ) );
            const stair1Slope = stair1.map( i => new THREE.Vector2( i.x + concreteLt.x, i.y + concreteLt.y ) );
            const stair2Slope = stair2.map( i => new THREE.Vector2( i.x + concreteLt.x, i.y + concreteLt.y ) );
            const stair3Slope = stair3.map( i => new THREE.Vector2( i.x + concreteLt.x, i.y + concreteLt.y ) );






            /****************************************************************************************************
             * 일반도 contents
             *
             * 1. 본선
             *      1.1 본선1
             *      1.2 본선2
             *      1.3 본선접속부
             *      1.4 본선1 숏크리트
             *      1.5 본선2 숏크리트
             *      1.6 본선접속부 숏크리트
             * 
             * 2. 접속부 계단
             * 
             * 3. 연결통로와 접속부 헌치
             *      3.1 형상
             *          a) 대인용 연결통로
             *          b) 대인용 접속부
             *          c) 차량용 연결통로
             *          d) 차량용 접속부
             *          e) 대형차량용 연결통로
             *          f) 대형차량용 접속부
             *      3.2 연결통로
             *      3.3 접속부 헌치
             *          a) 내측
             *          b) 외측
             *          c) 숏크리트
             * 
             * 4. 최종모델링
             *      4.1 최종 차집합
             *      4.2 공동구 뚜껑
             *      4.3 본선접속부 공동구 덮개
             ****************************************************************************************************/

            // 1. 본선 ////////////////////////////////////////////////////////////////////////////////////////////////////
            
            // 1.1 본선1(main Tunnel)형상
            const r2Theta1 = Math.asin( ( r2Origin.y - footingLtSlope[footingLtSlope.length-1].y ) / r2Final ) + Math.PI/2 - r1ThetaLt;
            const r4Theta1 = Math.asin( ( r4Origin.y - footingRtSlope[footingRtSlope.length-1].y ) / r4Final ) + Math.PI/2 - r1ThetaRt;
            const r3Gamma1 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / r3Final );
            const r3Theta1 = Math.PI/2 - r1ThetaLt + r3Gamma1;
            const r5Gamma1 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / r5Final );
            const r5Theta1 = Math.PI/2 - r1ThetaRt + r5Gamma1;

            const footingRtReverse = [...footingRtSlope].reverse(); // 원본 배열유지

            const mainTunnelShp = new THREE.Shape();
            mainTunnelShp.moveTo( footingLtSlope[0].x, footingLtSlope[0].y );
            footingLtSlope.forEach( i => mainTunnelShp.lineTo( i.x, i.y ) );
            mainTunnelShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + r2Theta1, Math.PI/2 + r1ThetaLt, true );
            mainTunnelShp.absarc( 0, r1Height, r1Final, Math.PI/2 + r1ThetaLt, Math.PI/2, true );
            mainTunnelShp.absarc( 0, r1Height, r1Final, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            mainTunnelShp.absarc( r4Origin.x, r4Origin.y, r4Final, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r4Theta1, true );
            footingRtReverse.forEach( i => mainTunnelShp.lineTo( i.x, i.y ) );
            mainTunnelShp.lineTo( footingRtReverse[footingRtReverse.length-1].x, footingRtReverse[footingRtReverse.length-1].y - footingHeight );
            mainTunnelShp.absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false );
            mainTunnelShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false );
            mainTunnelShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false );
            mainTunnelShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );
            mainTunnelShp.lineTo( footingLtSlope[0].x, footingLtSlope[0].y - footingHeight );
            mainTunnelShp.lineTo( footingLtSlope[0].x, footingLtSlope[0].y );

            const mainTunnelExtr1 = addExtr( mainTunnelShp, 'steelblue', mainTunnelLength, 1 );
            showContainer.push( mainTunnelExtr1 );

            // 1.2 본선2(main Tunnel)형상
            const mainTunnelExtr2 = mainTunnelExtr1.clone();
            mainTunnelExtr2.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength + footingConnLength + 3*stairLength + 3*stairLength ) );
            showContainer.push( mainTunnelExtr2 );

            // 1.3 본선접속부(main Connection) 형상
            const mainConnShp = new THREE.Shape();
            mainConnShp.moveTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y );
            mainConnShp.lineTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y );
            mainConnShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + r2Theta1, Math.PI/2 + r1ThetaLt, true );
            mainConnShp.absarc( 0, r1Height, r1Final, Math.PI/2 + r1ThetaLt, Math.PI/2, true );
            mainConnShp.absarc( 0, r1Height, r1Final, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
            mainConnShp.absarc( r4Origin.x, r4Origin.y, r4Final, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r4Theta1, true );
            footingRtReverse.forEach( i => mainConnShp.lineTo( i.x, i.y ) );
            mainConnShp.lineTo( footingRtReverse[footingRtReverse.length-1].x, footingRtReverse[footingRtReverse.length-1].y - footingHeight );
            mainConnShp.absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false );
            mainConnShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false );
            mainConnShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false );
            mainConnShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );

            const mainConnExtr = addExtr( mainConnShp, 'steelblue', footingConnLength + stairLength * 3 + stairLength * 3, 1 ); // 계단길이포함
            mainConnExtr.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength ) );
            // showContainer.push( mainConnExtr );

            // 외측 라이닝 - 연결통로 자를 때 사용
            const outterAreaShp = new THREE.Shape()
                .absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false )
                .absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false )
                .absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false )
                .absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );

            const outterAreaExtr = addExtr( outterAreaShp, 'mediumvioletred', ui.totalLength, 1 );
            // showContainer.push( outterAreaExtr )

            // 내측 라이닝 - 연결통로 자를 때 사용
            const innerAreaShp = new THREE.Shape()
                .moveTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y - 1)
                .lineTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y - 1)
                .absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + r2Theta1, Math.PI/2 + r1ThetaLt, true )
                .absarc( 0, r1Height, r1Final, Math.PI/2 + r1ThetaLt, Math.PI/2, true )
                .lineTo( 0, footingConnSlope[footingConnSlope.length-1].y - 1 )

            const innerAreaExtr = addExtr( innerAreaShp, 'seagreen', ui.totalLength, 1 );
            // showContainer.push( innerAreaExtr )

            // 1.4 본선1 숏크리트 
            const r3Gamma2 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final + ui.shotcrete ) );
            const r3Theta2 = Math.PI/2 - r1ThetaLt + r3Gamma2;
            
            const r5Gamma2 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / ( r5Final + ui.shotcrete ) );
            const r5Theta2 = Math.PI/2 - r1ThetaRt + r5Gamma2;

            const mainScShp = new THREE.Shape();    
            mainScShp.absarc( r5Origin.x, r5Origin.y, r5Final, Math.PI/2 - r1ThetaRt - r5Theta1, Math.PI/2 - r1ThetaRt, false );
            mainScShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2 - r1ThetaRt,  Math.PI/2, false );
            mainScShp.absarc( 0, r1Height, r1Final + liningT0, Math.PI/2,  Math.PI/2 + r1ThetaLt, false );
            mainScShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );
            mainScShp.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt + r3Theta2, Math.PI/2 + r1ThetaLt, true );
            mainScShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2 + r1ThetaLt,  Math.PI/2, true );
            mainScShp.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2,  Math.PI/2 - r1ThetaRt, true );
            mainScShp.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );

            const mainScExtr1 = addExtr( mainScShp, 'skyblue', mainTunnelLength, 1.0 );
            showContainer.push( mainScExtr1 );

            // 1.5 본선2 숏크리트 
            const mainScExtr2 = mainScExtr1.clone();
            mainScExtr2.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength + footingConnLength + 3*stairLength + 3*stairLength ) );
            showContainer.push( mainScExtr2 ); 

            // 1.6 본선접속부 숏크리트 
            const mainConnScExtr = addExtr( mainScShp, 'skyblue', footingConnLength + stairLength * 3 + stairLength * 3, 1 );
            mainConnScExtr.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength ) );
            // showContainer.push( mainConnScExtr );

            // 본선숏크리트 - 연결통로 자를 때 사용
            const scAreaShp = new THREE.Shape()
                .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt + r3Theta2, Math.PI/2 + r1ThetaLt, true )
                .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2 + r1ThetaLt,  Math.PI/2, true )
                .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2,  Math.PI/2 - r1ThetaRt, true )
                .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );

            const scAreaExtr = addExtr( scAreaShp, 'hotpink', ui.totalLength, 1 );
            // showContainer.push( scAreaExtr );


            // 2. 접속부 계단 ////////////////////////////////////////////////////////////////////////////////////////////////////

            // 계단1
            const getPointShp = new THREE.Shape();
            getPointShp.absarc( r2Origin.x, r2Origin.y, r2Final, Math.PI/2 + r1ThetaLt + r2Theta1, Math.PI/2 + r1ThetaLt, true );
            getPointShp.absarc( r3Origin.x, r3Origin.y, r3Final, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta1, false );

            // 계단과 라이닝 접점 x,y 계산
            //  \      R2시작점
            //  |\     
            //  | \    
            //  |--\   접속부 공동구 끝점 
            // R2시작점과 접속부 공동구 끝점과의 길이

            const stairMagin = getPointShp.getPoint(0).x - footingConnSlope[footingConnSlope.length-1].x

            const stair1Shp = new THREE.Shape( stair1Slope );
            stair1Shp.lineTo( stair1Slope[stair1Slope.length-1].x + stairMagin * 3/4, stair1Slope[stair1Slope.length-1].y );
            stair1Shp.lineTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y );
            stair1Shp.lineTo( getPointShp.getPoint(1).x, getPointShp.getPoint(1).y );
            stair1Shp.lineTo( stair1Slope[0].x, stair1Slope[0].y - footingHeight );

            const stair1Extr1 = addExtr( stair1Shp, 'steelblue', stairLength, 0.9 );
            stair1Extr1.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength ) );
            showContainer.push( stair1Extr1 );

            const stair1Extr2 = stair1Extr1.clone();
            stair1Extr2.applyMatrix4( matrix.makeTranslation( 0, 0, footingConnLength + stairLength * 3 + stairLength * 2 ) );
            showContainer.push( stair1Extr2 );

            // 계단2
            const stair2Shp = new THREE.Shape( stair2Slope );
            stair2Shp.lineTo( stair2Slope[stair2Slope.length-1].x + stairMagin * 2/4, stair2Slope[stair2Slope.length-1].y );
            stair2Shp.lineTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y );
            stair2Shp.lineTo( getPointShp.getPoint(1).x, getPointShp.getPoint(1).y );
            stair2Shp.lineTo( stair2Slope[0].x, stair2Slope[0].y - footingHeight );

            const stair2Extr1 = addExtr( stair2Shp, 'steelblue', stairLength, 0.9 );
            stair2Extr1.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength + stairLength ) );
            showContainer.push( stair2Extr1 );

            const stair2Extr2 = stair2Extr1.clone();
            stair2Extr2.applyMatrix4( matrix.makeTranslation( 0, 0, stairLength * 2 + footingConnLength + stairLength ) );
            showContainer.push( stair2Extr2 );

            // 계단3
            const stair3Shp = new THREE.Shape( stair3Slope );
            stair3Shp.lineTo( stair3Slope[stair3Slope.length-1].x + stairMagin * 1/4, stair3Slope[stair3Slope.length-1].y );
            stair3Shp.lineTo( footingConnSlope[footingConnSlope.length-1].x, footingConnSlope[footingConnSlope.length-1].y );
            stair3Shp.lineTo( getPointShp.getPoint(1).x, getPointShp.getPoint(1).y );
            stair3Shp.lineTo( stair3Slope[0].x, stair3Slope[0].y - footingHeight );

            const stair3Extr1 = addExtr( stair3Shp, 'steelblue', stairLength, 0.9 );
            stair3Extr1.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength + stairLength * 2 ) );
            showContainer.push( stair3Extr1 );

            const stair3Extr2 = stair3Extr1.clone();
            stair3Extr2.applyMatrix4( matrix.makeTranslation( 0, 0, stairLength + footingConnLength ) );
            showContainer.push( stair3Extr2 );

            // 접속부 공동구
            const connFootingShp = new THREE.Shape( footingConnSlope );
            connFootingShp.lineTo( getPointShp.getPoint(1).x, getPointShp.getPoint(1).y );

            if ( footingType =='기계환기' ) { 
                connFootingShp.lineTo( getPointShp.getPoint(1).x, getPointShp.getPoint(1).y - 0.14 ); // 접속부 공동구가 공동구높이보다 크기 때문에 0.14만큼 내려줌
                connFootingShp.lineTo( stair1Slope[0].x - 0.550,  stair1Slope[0].y - footingHeight - 0.14 );
                connFootingShp.lineTo( stair1Slope[0].x - 0.550,  stair1Slope[0].y - footingHeight );
            }
            
            connFootingShp.lineTo( footingConnSlope[0].x, footingConnSlope[0].y - footingHeight );
            connFootingShp.lineTo( footingConnSlope[0].x, footingConnSlope[0].y );

            const connFootingExtr = addExtr( connFootingShp, 'steelblue', footingConnLength, 0.9 );
            connFootingExtr.applyMatrix4( matrix.makeTranslation( 0, 0, mainTunnelLength + stairLength * 3  ) );
            showContainer.push( connFootingExtr );


            // 3. 연결통로, 접속부 헌치 ////////////////////////////////////////////////////////////////////////////////////////////////////
            // 3.1 형상

            // a) 대인용 피난연결통로(Pedestrian Cross Passage), 약어 : pPsge

            // 대인용 연결통로 입력값
            const pPsgeR1Final = 1.400;
            const pPsgeR1Theta = Math.PI/2
            const pPsgeR1Origin = new THREE.Vector3( 0.000, 2.000, 0.000 );
            const pPsgeLiningT0 = 0.300; // 피난연결통로 라이닝 두께
            const pPsgePavement = 0.300;
            const pPsgeFootingLeftPt = new THREE.Vector2( -1.400, 0.000 );
            const pPsgeFootingRightPt = new THREE.Vector2( 1.400, 0.000 );
            
            const pConnHaunch = 1.000; // 헌치x축 길이  
            const pConnLiningT0 = 0.300; // 피난연결통로 접속부 라이닝 두께          
            
            // 대인용 연결통로 내측 형상
            const pPsgeInnerShp = new THREE.Shape();
            pPsgeInnerShp.absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final, 0, 2*pPsgeR1Theta, false );
            pPsgeInnerShp.lineTo( pPsgeFootingLeftPt.x, pPsgeFootingLeftPt.y );
            pPsgeInnerShp.lineTo( pPsgeFootingRightPt.x, pPsgeFootingRightPt.y );
            pPsgeInnerShp.lineTo( pPsgeFootingRightPt.x, pPsgeR1Origin.y );
            
            // 대인용 연결통로 외측 형상
            const pPsgeOutterShp = new THREE.Shape();
            pPsgeOutterShp.absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0, 0, 2*pPsgeR1Theta, false );
            pPsgeOutterShp.lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0, pPsgeFootingLeftPt.y - pPsgePavement );
            pPsgeOutterShp.lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0, pPsgeFootingRightPt.y - pPsgePavement );
            pPsgeOutterShp.lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0, pPsgeR1Origin.y )

            // 대인용 연결통로 숏크리트 형상
            const pPsgeScShp = new THREE.Shape();
            pPsgeScShp.moveTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete, pPsgeFootingLeftPt.y - pPsgePavement );
            pPsgeScShp.lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete, pPsgeR1Origin.y );
            pPsgeScShp.absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete, 2*pPsgeR1Theta, 0, true );
            pPsgeScShp.lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete, pPsgeFootingRightPt.y - pPsgePavement );

            // b) 대인용 접속부 (Pedestrian Cross Connection), 약어 : pConn
        
            // 대인용 접속부 R1 계산
            const pConnTopPt = new THREE.Vector2( 0, pPsgeR1Origin.y + pPsgeR1Final );// 대인용 R1원점.y에서 R1값을 더해줌
            const pConnLeftPt = new THREE.Vector2( pPsgeFootingLeftPt.x - pConnHaunch, pPsgeR1Origin.y );
            
            const pConnR1Line = pConnTopPt.distanceTo( pConnLeftPt ) / 2;
            const pConnR1Alpha = Math.atan( ( pConnTopPt.x - pConnLeftPt.x )/( pConnTopPt.y - pConnLeftPt.y ) );
            const pConnR1Final = pConnR1Line / Math.cos( pConnR1Alpha ); //R1 반지름
            const pConnR1Theta = 180 - 2 * pConnR1Alpha; //R2 중심각
            const pConnR1Origin = new THREE.Vector3( 0, pPsgeR1Origin.y + pPsgeR1Final - pConnR1Final, 0 );
            
            // 대인용 접속부 내측 형상
            const pConnInnerShp = new THREE.Shape();
            pConnInnerShp.absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final, 0, 2*pPsgeR1Theta, false );
            pConnInnerShp.lineTo( -pConnR1Final, pPsgeFootingLeftPt.y );
            pConnInnerShp.lineTo( pConnR1Final, pPsgeFootingRightPt.y );
            pConnInnerShp.lineTo( pConnR1Final, pConnR1Origin.y );
            
            // 대인용 접속부 외측 형상
            const pConnOutterShp = new THREE.Shape();
            pConnOutterShp.absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0, 0, 2*pPsgeR1Theta, false );
            pConnOutterShp.lineTo( -pConnR1Final - pConnLiningT0, pPsgeFootingLeftPt.y - pPsgePavement );
            pConnOutterShp.lineTo( pConnR1Final + pConnLiningT0, pPsgeFootingRightPt.y - pPsgePavement );
            pConnOutterShp.lineTo( pConnR1Final + pConnLiningT0, pConnR1Origin.y );

            // 대인용 접속부 숏크리트 형상
            const pConnScShp = new THREE.Shape();
            pConnScShp.moveTo( -pConnR1Final - pConnLiningT0 - ui.psgeShotcrete, pPsgeFootingLeftPt.y - pPsgePavement );
            pConnScShp.lineTo( -pConnR1Final - pConnLiningT0 - ui.psgeShotcrete, pConnR1Origin.y );
            pConnScShp.absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 + ui.psgeShotcrete, 2*pPsgeR1Theta, 0, true );
            pConnScShp.lineTo( pConnR1Final + pConnLiningT0 + ui.psgeShotcrete, pPsgeFootingRightPt.y - pPsgePavement );

            // c) 차량용 피난연결통로(Vehicle Cross Passage), 약어 : vPsge

            // 차량용 연결통로 입력값
            const vPsgeR1Final = 2.810;
            const vPsgeR1Theta = Math.PI/2
            const vPsgeR1Origin = new THREE.Vector3( 0.000, 2.000, 0.000 );
            const vPsgeLiningT0 = 0.300; //피난연결통로 라이닝 두께
            const vPsgeLiningT1 = 0.350; //피난연결통로 공동구 라이닝 두께
            const vPsgePavement = 0.300;
            const vPsgeFootingLeftPt = new THREE.Vector2( -2.350, 0.000 );
            const vPsgeFootingRightPt = new THREE.Vector2( 2.350, 0.000 );

            const vConnHaunch = 1.500; //헌치x축 길이
            const vConnLiningT0 = 0.300; //피난연결통로 접속부 라이닝 두께

            // 차량용 연결통로 R2 계산
            const vPsgeR1Shp = new THREE.Shape();
            vPsgeR1Shp.absarc( vPsgeR1Origin.x, vPsgeR1Origin.y, vPsgeR1Final, 2*vPsgeR1Theta, 0, true ); //R1좌우측 끝점을 알기위해 그려줌 
            const vPsgeR1LeftPt = vPsgeR1Shp.getPoint( 0 );//R1좌측 끝점
            const vPsgeR2Line = vPsgeR1LeftPt.distanceTo( vPsgeFootingLeftPt ) / 2;
            const vPsgeR2Alpha = Math.atan( ( vPsgeFootingLeftPt.x - vPsgeR1LeftPt.x )/( vPsgeFootingLeftPt.y - vPsgeR1LeftPt.y ) );
            const vPsgeR2Beta = vPsgeR1Theta + vPsgeR2Alpha;
            const vPsgeR2Final = vPsgeR2Line / Math.cos( vPsgeR2Beta ); //R2 반지름
            const vPsgeR2Theta = Math.PI - 2 * vPsgeR2Beta; //R2 중심각
            const vPsgeR2Origin = new THREE.Vector3( 0, vPsgeR1Final - vPsgeR2Final, 0 );
            vPsgeR2Origin.applyMatrix4( matrix.makeRotationZ( vPsgeR1Theta ) );
            vPsgeR2Origin.applyMatrix4( matrix.makeTranslation( 0.000, vPsgeR1Origin.y, 0.000 ) ); //R2 원점

            // 차량용 연결통로 R3 계산
            const vPsgeR3Pt = new THREE.Vector3( 0, vPsgeR1Final + vPsgeLiningT0 - vPsgeLiningT1 );
            vPsgeR3Pt.applyMatrix4( matrix.makeRotationZ( vPsgeR1Theta ) );
            vPsgeR3Pt.applyMatrix4( matrix.makeTranslation( 0, vPsgeR1Origin.y, 0 ) );
            const vPsgeR3Line = vPsgeR3Pt.distanceTo( new THREE.Vector3( vPsgeFootingLeftPt.x, vPsgeFootingLeftPt.y, 0.000 ) ) / 2;
            const vPsgeR3Alpha = Math.atan( ( vPsgeFootingLeftPt.x - vPsgeR3Pt.x )/( vPsgeFootingLeftPt.y - vPsgeR3Pt.y ) );
            const vPsgeR3Beta = vPsgeR1Theta + vPsgeR3Alpha;
            const vPsgeR3Subline = vPsgeR3Line / Math.cos( vPsgeR3Beta );
            const vPsgeR3Final = vPsgeR3Subline + vPsgeLiningT1
            const vPsgeR3Origin = new THREE.Vector3( 0, vPsgeR1Final + vPsgeLiningT0 - vPsgeR3Final );
            vPsgeR3Origin.applyMatrix4( matrix.makeRotationZ( vPsgeR1Theta ) );
            vPsgeR3Origin.applyMatrix4( matrix.makeTranslation( 0, vPsgeR1Origin.y, 0 ) );
            const vPsgeR3BottomLength = Math.sqrt( Math.pow( vPsgeR3Final, 2 ) - Math.pow( vPsgeR3Origin.y - ( - vPsgePavement ) ,2  ) );
            const vPsgeR3Theta1 = Math.PI - vPsgeR1Theta - Math.atan( vPsgeR3BottomLength /( vPsgeR3Origin.y -( - vPsgePavement ) ) );  

            // 차량용 연결통로 R4 계산
            const vPsgeR1RightPt = vPsgeR1Shp.getPoint( 1 );//R1우측 끝점
            const vPsgeR4Line = vPsgeR1RightPt.distanceTo( vPsgeFootingRightPt ) / 2;
            const vPsgeR4Alpha = Math.atan( ( vPsgeFootingRightPt.x - vPsgeR1RightPt.x )/( vPsgeFootingRightPt.y - vPsgeR1RightPt.y ) );
            const vPsgeR4Beta = vPsgeR1Theta - vPsgeR4Alpha;
            const vPsgeR4Final = vPsgeR4Line / Math.cos( vPsgeR4Beta ); //R4 반지름
            const vPsgeR4Theta = Math.PI - 2 * vPsgeR4Beta; //R4 중심각
            const vPsgeR4Origin = new THREE.Vector3( 0, vPsgeR1Final - vPsgeR4Final, 0 );
            vPsgeR4Origin.applyMatrix4( matrix.makeRotationZ( -vPsgeR1Theta ) );
            vPsgeR4Origin.applyMatrix4( matrix.makeTranslation( 0.000, vPsgeR1Origin.y, 0.000 ) ); //R4 원점

            // 차량용 연결통로 R5 계산
            const vPsgeR5Pt = new THREE.Vector3( 0, vPsgeR1Final + vPsgeLiningT0 - vPsgeLiningT1 );
            vPsgeR5Pt.applyMatrix4( matrix.makeRotationZ( - vPsgeR1Theta ) );
            vPsgeR5Pt.applyMatrix4( matrix.makeTranslation( 0, vPsgeR1Origin.y, 0 ) );
            const vPsgeR5Line = vPsgeR5Pt.distanceTo( new THREE.Vector3( vPsgeFootingRightPt.x, vPsgeFootingRightPt.y, 0.000 ) ) / 2;
            const vPsgeR5Alpha = Math.atan( ( vPsgeFootingRightPt.x - vPsgeR5Pt.x )/( vPsgeFootingRightPt.y - vPsgeR5Pt.y ) );
            const vPsgeR5Beta = vPsgeR1Theta - vPsgeR5Alpha;
            const vPsgeR5Subline = vPsgeR5Line / Math.cos( vPsgeR5Beta ) ;
            const vPsgeR5Final = vPsgeR5Subline + vPsgeLiningT1;
            const vPsgeR5Origin = new THREE.Vector3( 0, vPsgeR1Final + vPsgeLiningT0 - vPsgeR5Final );
            
            vPsgeR5Origin.applyMatrix4( matrix.makeRotationZ( -vPsgeR1Theta ) );
            vPsgeR5Origin.applyMatrix4( matrix.makeTranslation( 0, vPsgeR1Origin.y, 0 ) );
            const vPsgeR5BottomLength = Math.sqrt( Math.pow( vPsgeR5Final, 2 ) - Math.pow( vPsgeR5Origin.y - ( - vPsgePavement ) ,2  ) );
            const vPsgeR5Theta1 = Math.PI - vPsgeR1Theta - Math.atan( vPsgeR5BottomLength /( vPsgeR5Origin.y -( - vPsgePavement ) ) );

            // 차량용 연결통로 내측 형상
            const vPsgeInnerShp = new THREE.Shape();
            vPsgeInnerShp.absarc( vPsgeR2Origin.x, vPsgeR2Origin.y, vPsgeR2Final, 2*vPsgeR1Theta + vPsgeR2Theta, 2*vPsgeR1Theta, true );
            vPsgeInnerShp.absarc( 0, vPsgeR1Origin.y, vPsgeR1Final, 2*vPsgeR1Theta, 0, true );
            vPsgeInnerShp.absarc( vPsgeR4Origin.x, vPsgeR4Origin.y, vPsgeR4Final, 0, 0 - vPsgeR4Theta, true );

            // 차량용 연결통로 외측 형상
            const vPsgeOutterShp = new THREE.Shape();
            vPsgeOutterShp.absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final, 2*vPsgeR1Theta + vPsgeR3Theta1, 2*vPsgeR1Theta, true );
            vPsgeOutterShp.absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0, 2*vPsgeR1Theta, 0, true );
            vPsgeOutterShp.absarc( vPsgeR5Origin.x, vPsgeR5Origin.y, vPsgeR5Final, 0, 0 - vPsgeR5Theta1, true );

            // 차량용 연결통로 숏크리트 형상
            const vPsgeR3Gamma2 = Math.asin( ( vPsgeR3Origin.y + vPsgePavement ) / ( vPsgeR3Final + ui.psgeShotcrete ) );
            const vPsgeR3Theta2 = Math.PI/2 - vPsgeR1Theta + vPsgeR3Gamma2;
            
            const vPsgeR5Gamma2 = Math.asin( ( vPsgeR5Origin.y + vPsgePavement ) / ( vPsgeR5Final + ui.psgeShotcrete ) );
            const vPsgeR5Theta2 = Math.PI/2 - vPsgeR1Theta + vPsgeR5Gamma2;

            const vPsgeScShp = new THREE.Shape();
            vPsgeScShp.absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete, 2*vPsgeR1Theta + vPsgeR3Theta2, 2*vPsgeR1Theta, true );
            vPsgeScShp.absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete, 2*vPsgeR1Theta, 0, true );
            vPsgeScShp.absarc( vPsgeR5Origin.x, vPsgeR5Origin.y, vPsgeR5Final + ui.psgeShotcrete, 0, 0 - vPsgeR5Theta2, true );            

            // d) 차량용 접속부 (Vehicle Cross Connection), 약어 : vConn

            // 차량용 접속부 R2 계산
            const vConnR2Final = vPsgeR2Final + vConnHaunch;
            const vConnR2Theta = Math.asin( vPsgeR2Origin.y / vConnR2Final );
            const vConnR2Origin = new THREE.Vector3( 0, ( vPsgeR1Final + vConnHaunch ) - vConnR2Final, 0 );
            vConnR2Origin.applyMatrix4( matrix.makeRotationZ( vPsgeR1Theta ) );
            vConnR2Origin.applyMatrix4( matrix.makeTranslation( 0.000, vPsgeR1Origin.y, 0.000 ) );//R2 원점

            // 차량용 접속부 R3 계산
            const vConnR3Final = vConnR2Final + vConnLiningT0;
            const vConnR3Theta = Math.asin( ( vPsgeR2Origin.y + vPsgePavement ) / vConnR3Final );
            const vConnR3Origin = new THREE.Vector3( 0, ( vPsgeR1Final + vConnHaunch + vConnLiningT0 ) - vConnR3Final, 0 );
            vConnR3Origin.applyMatrix4( matrix.makeRotationZ( vPsgeR1Theta ) );
            vConnR3Origin.applyMatrix4( matrix.makeTranslation( 0.000, vPsgeR1Origin.y, 0.000 ) );//R2 원점

            // 차량용 접속부 내측 형상, vConnInner
            const vConnInnerShp = new THREE.Shape();
            vConnInnerShp.absarc( vConnR2Origin.x, vConnR2Origin.y, vConnR2Final, Math.PI + vConnR2Theta, Math.PI, true );
            vConnInnerShp.absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch, vPsgeR1Final, Math.PI, 0, true );
            vConnInnerShp.absarc( -vConnR2Origin.x, vConnR2Origin.y, vConnR2Final, 0, -vConnR2Theta, true );

            // 차량용 접속부 외측 형상, vConnOutter 
            const vConnOutterShp = new THREE.Shape();
            vConnOutterShp.absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final, Math.PI + vConnR3Theta, Math.PI, true );
            vConnOutterShp.absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0, vPsgeR1Final + vConnLiningT0, Math.PI, 0, true );
            vConnOutterShp.absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final, 0, -vConnR3Theta, true );

            // 차량용 접속부 숏크리트 형상
            const vConnR3Gamma2 = Math.asin( ( vConnR3Origin.y + vPsgePavement ) / ( vConnR3Final + ui.psgeShotcrete ) );
            const vConnR3Theta2 = Math.PI/2 - vPsgeR1Theta + vConnR3Gamma2;

            const vConnScShp = new THREE.Shape();
            vConnScShp.absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final + ui.psgeShotcrete, Math.PI + vConnR3Theta2, Math.PI, true );
            vConnScShp.absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete, vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete, Math.PI, 0, true );
            vConnScShp.absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final + ui.psgeShotcrete, 0, -vConnR3Theta2, true );

            // e) 대형차량용 피난연결통로(Heavy Goods Vehicle Cross Passage), 약어 : hPsge
                    
            // 대형차량용 연결통로 입력값
            const hPsgeR1Final = 4.445;
            const hPsgeR1Theta = Math.PI/2;
            const hPsgeR1Origin = new THREE.Vector3( 0.000, 2.005, 0.000 );
            const hPsgeLiningT0 = 0.300; // 피난연결통로 라이닝 두께
            const hPsgeLiningT1 = 0.350; // 피난연결통로 공동구 라이닝 두께
            const hPsgePavement = 0.300;
            const hPsgeFootingLeftPt = new THREE.Vector2( -4.150, 0.000 );
            const hPsgeFootingRightPt = new THREE.Vector2( 4.150, 0.000 );
            const hConnHaunch = 1.500; //헌치x축 길이            

            // 대형차량용 연결통로 R2 계산
            const hPsgeR1Shape = new THREE.Shape();
            hPsgeR1Shape.absarc( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final, 2*hPsgeR1Theta, 0, true ); //R1좌우측 끝점을 알기위해 그려줌 

            const hPsgeR1LeftPt = hPsgeR1Shape.getPoint( 0 );//R1좌측 끝점
            const hPsgeR2Line = hPsgeR1LeftPt.distanceTo( hPsgeFootingLeftPt ) / 2;
            const hPsgeR2Alpha = Math.atan( ( hPsgeFootingLeftPt.x - hPsgeR1LeftPt.x )/( hPsgeFootingLeftPt.y - hPsgeR1LeftPt.y ) );
            const hPsgeR2Beta = hPsgeR1Theta + hPsgeR2Alpha;
            const hPsgeR2Final = hPsgeR2Line / Math.cos( hPsgeR2Beta ); //R2 반지름
            const hPsgeR2Theta = Math.PI - 2 * hPsgeR2Beta; //R2 중심각
            const hPsgeR2Origin = new THREE.Vector3( 0, hPsgeR1Final - hPsgeR2Final, 0 );
            hPsgeR2Origin.applyMatrix4( matrix.makeRotationZ( hPsgeR1Theta ) );
            hPsgeR2Origin.applyMatrix4( matrix.makeTranslation( 0.000, hPsgeR1Origin.y, 0.000 ) ); //R2 원점

            // 대형차량용 연결통로 R3 계산
            const hPsgeR3Pt = new THREE.Vector3( 0, hPsgeR1Final + hPsgeLiningT0 - hPsgeLiningT1 );
            hPsgeR3Pt.applyMatrix4( matrix.makeRotationZ( hPsgeR1Theta ) );
            hPsgeR3Pt.applyMatrix4( matrix.makeTranslation( 0, hPsgeR1Origin.y, 0 ) );

            const hPsgeR3Line = hPsgeR3Pt.distanceTo( new THREE.Vector3( hPsgeFootingLeftPt.x, hPsgeFootingLeftPt.y, 0.000 ) ) / 2;
            const hPsgeR3Alpha = Math.atan( ( hPsgeFootingLeftPt.x - hPsgeR3Pt.x )/( hPsgeFootingLeftPt.y - hPsgeR3Pt.y ) );
            const hPsgeR3Beta = hPsgeR1Theta + hPsgeR3Alpha;
            const hPsgeR3Subline = hPsgeR3Line / Math.cos( hPsgeR3Beta );
            const hPsgeR3Final = hPsgeR3Subline + hPsgeLiningT1
            const hPsgeR3Origin = new THREE.Vector3( 0, hPsgeR1Final + hPsgeLiningT0 - hPsgeR3Final );
            hPsgeR3Origin.applyMatrix4( matrix.makeRotationZ( hPsgeR1Theta ) );
            hPsgeR3Origin.applyMatrix4( matrix.makeTranslation( 0, hPsgeR1Origin.y, 0 ) );
            const hPsgeR3BottomLength = Math.sqrt( Math.pow( hPsgeR3Final, 2 ) - Math.pow( hPsgeR3Origin.y - ( - hPsgePavement ) ,2  ) );
            const hPsgeR3Theta1 = Math.PI - hPsgeR1Theta - Math.atan( hPsgeR3BottomLength /( hPsgeR3Origin.y - ( - hPsgePavement ) ) );

            // 대형차량용 연결통로 내측 형상
            const hPsgeInnerShp = new THREE.Shape();
            hPsgeInnerShp.absarc( hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final, 2*hPsgeR1Theta + hPsgeR2Theta, 2*hPsgeR1Theta, true );
            hPsgeInnerShp.absarc( 0, hPsgeR1Origin.y, hPsgeR1Final, 2*hPsgeR1Theta, 0, true );
            hPsgeInnerShp.absarc( - hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final, 0, 0 - hPsgeR2Theta, true );

            // 대형차량용 연결통로 외측 형상
            const hPsgeOutterShp = new THREE.Shape();
            hPsgeOutterShp.absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final, 2*hPsgeR1Theta + hPsgeR3Theta1, 2*hPsgeR1Theta, true );
            hPsgeOutterShp.absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0, 2*hPsgeR1Theta, 0, true );
            hPsgeOutterShp.absarc( - hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final, 0, 0 - hPsgeR3Theta1, true );

            // 대형차량용 연결통로 숏크리트 형상
            const hPsgeR3Gamma2 = Math.asin( ( hPsgeR3Origin.y + hPsgePavement ) / ( hPsgeR3Final + ui.psgeShotcrete ) );
            const hPsgeR3Theta2 = Math.PI/2 - hPsgeR1Theta + hPsgeR3Gamma2;

            const hPsgeScShp = new THREE.Shape();
            hPsgeScShp.absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete, 2*hPsgeR1Theta + hPsgeR3Theta2, 2*hPsgeR1Theta, true );
            hPsgeScShp.absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete, 2*hPsgeR1Theta, 0, true );
            hPsgeScShp.absarc( - hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete, 0, 0 - hPsgeR3Theta2, true );

            // f) 대형차량용 접속부 (Heavy Goods Vehicle Cross Connection), 약어 : hConn

            // 대형차량용 접속부 입력값
            const hConnLiningT0 = 0.300; //피난연결통로 접속부 라이닝 두께

            // 대형차량용 접속부
            const hConnR1Shp = new THREE.Shape();
            hConnR1Shp.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final+hConnHaunch, hPsgeR1Final, Math.PI/2 + hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta, true); //R1좌우측 끝점을 알기위해 그려줌 

            // 대형차량용 접속부 R2 계산
            const hConnR1LeftPt = hConnR1Shp.getPoint( 0 );//R1좌측 끝점
            const hConnFootingLeftPt = new THREE.Vector2( hPsgeFootingLeftPt.x - hConnHaunch, 0.000 );
            const hConnR2Line = hConnR1LeftPt.distanceTo( hConnFootingLeftPt ) / 2;
            const hConnR2Alpha = Math.atan( ( hConnFootingLeftPt.x - hConnR1LeftPt.x )/( hConnFootingLeftPt.y - hConnR1LeftPt.y ) );
            const hConnR2Beta = hPsgeR1Theta + hConnR2Alpha;
            const hConnR2Final = hConnR2Line / Math.cos( hConnR2Beta ); //R2 반지름
            const hConnR2Theta = Math.PI - 2 * hConnR2Beta; //R2 중심각
            const hConnR2Origin = new THREE.Vector3( 0, hPsgeR1Final + hConnHaunch - hConnR2Final, 0 );
            hConnR2Origin.applyMatrix4( matrix.makeRotationZ( hPsgeR1Theta ) );
            hConnR2Origin.applyMatrix4( matrix.makeTranslation( 0.000, hPsgeR1Origin.y, 0.000 ) ); //R2 원점

            // 대형차량용 접속부 R3 계산
            const hConnR3Final = hConnR2Final + hConnLiningT0;
            const hConnR3Theta = Math.asin( ( hPsgeR2Origin.y + hPsgePavement ) / hConnR3Final );
            const hConnR3Origin = new THREE.Vector3( 0, ( hPsgeR1Final + hConnHaunch + hConnLiningT0 ) - hConnR3Final, 0 );
            hConnR3Origin.applyMatrix4( matrix.makeRotationZ( hPsgeR1Theta ) );
            hConnR3Origin.applyMatrix4( matrix.makeTranslation( 0.000, hPsgeR1Origin.y, 0.000 ) );//R2 원점            
           
            // 대형차량용 접속부 내측 형상, hConnInner
            const hConnInnerShp = new THREE.Shape();
            hConnInnerShp.absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final, Math.PI/2 + hPsgeR1Theta + hConnR2Theta, Math.PI/2 + hPsgeR1Theta, true );
            hConnInnerShp.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final+hConnHaunch, hPsgeR1Final, Math.PI/2 + hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta, true);
            hConnInnerShp.absarc( - hConnR2Origin.x, hConnR2Origin.y, hConnR2Final, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hConnR2Theta, true );

            // 대형차량용 접속부 외측 형상, hConnOutter
            const hConnOutterShp = new THREE.Shape();
            hConnOutterShp.absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0, Math.PI/2 + hPsgeR1Theta + hConnR3Theta, Math.PI/2 + hPsgeR1Theta, true );
            hConnOutterShp.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final+hConnHaunch+hConnLiningT0, hPsgeR1Final + hConnLiningT0, Math.PI/2 + hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta, true);
            hConnOutterShp.absarc( - hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hConnR3Theta, true );

            // 대형차량용 접속부 숏크리트 형상
            const hConnR3Gamma2 = Math.asin( ( hConnR3Origin.y + hPsgePavement ) / ( hConnR3Final + ui.psgeShotcrete ) );
            const hConnR3Theta2 = Math.PI/2 - hPsgeR1Theta + hConnR3Gamma2;

            const hConnScShp = new THREE.Shape();
            hConnScShp.absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0 + ui.psgeShotcrete, Math.PI/2 + hPsgeR1Theta + hConnR3Theta2, Math.PI/2 + hPsgeR1Theta, true );
            hConnScShp.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete, hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete, Math.PI/2 + hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta, true);
            hConnScShp.absarc( - hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0 + ui.psgeShotcrete, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hConnR3Theta2, true );
            
            /*
             * 피난연결통로 타입결정
             * 대인용, 차량용, 대형차량용
             */
            
            let psgeInnerShp, psgeOutterShp, psgeScShp, connInnerShp, connOutterShp, connScShp
            
            if ( ui.crossPsgeType == '대인용') {
                
                psgeInnerShp = pPsgeInnerShp,
                psgeOutterShp = pPsgeOutterShp,
                psgeScShp = pPsgeScShp,
                connInnerShp = pConnInnerShp,
                connOutterShp = pConnOutterShp,
                connScShp = pConnScShp
                
            } else if ( ui.crossPsgeType == '차량용') {
                
                psgeInnerShp = vPsgeInnerShp,
                psgeOutterShp = vPsgeOutterShp,
                psgeScShp = vPsgeScShp,
                connInnerShp = vConnInnerShp,
                connOutterShp = vConnOutterShp,
                connScShp = vConnScShp
                
            } else if ( ui.crossPsgeType == '대형차량용') {
                
                psgeInnerShp = hPsgeInnerShp,
                psgeOutterShp = hPsgeOutterShp,
                psgeScShp = hPsgeScShp,
                connInnerShp = hConnInnerShp,
                connOutterShp = hConnOutterShp,
                connScShp = hConnScShp
                
            }


            // 3.2 연결통로 모델링
            const verticalAngle = THREE.Math.degToRad( ui.verticalAngle );
            const horizontalAngle = THREE.Math.degToRad( ui.horizontalAngle );

            const psgeInnerExtr = addExtr( psgeInnerShp, 'beige', netReinforceL, 1 ); 
            const psgeOutterExtr = addExtr( psgeOutterShp, 'gray', netReinforceL, 1 );
            const psgeScExtr = addExtr( psgeScShp, 'darkgray', netReinforceL, 1 );

            function psgePositionGeometry ( mesh ) {
                mesh.geometry.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) ) // 270도 회전
                    .applyMatrix4( matrix.makeTranslation( -1.5, 0, 0 ) ) // 1.5간격만큼 이격된 거리에서 회하기 위해 1.5만큼 먼저이동시킴
                    .applyMatrix4( matrix.makeRotationZ( THREE.Math.degToRad( ui.verticalAngle ) ) ) // 연결통로를 연직방향으로 회전
                    .applyMatrix4( matrix.makeRotationY( THREE.Math.degToRad( ui.horizontalAngle ) ) ) // 연결통로를 수평방향으로 회전
                    .applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) ); // 위치이동
                return mesh
            }

            // 피난연결통로 구멍 생성
            const psgeSubCsg = new CSG();
            psgeSubCsg.subtract( [ psgeOutterExtr, psgeInnerExtr ] );
            const psgeSubMesh = psgeSubCsg.toMesh();
            psgePositionGeometry( psgeSubMesh );
            showContainer.push( psgeSubMesh );

            // 피난연결통로 숏크리트 모델링
            const psgeScSubCsg = new CSG();
            psgeScSubCsg.subtract( [ psgeScExtr, psgeOutterExtr ] );
            const psgeScSubMesh = psgeScSubCsg.toMesh();
            psgePositionGeometry( psgeScSubMesh );
            showContainer.push( psgeScSubMesh );


            // 3.3 연결통로 접속부 헌치 모델링
            const psgeInnerExtrThin = addExtr( psgeInnerShp, 'crimson', 0.00001, 1 ); // convex하기 위해 얇게 모델링
            psgePositionGeometry( psgeInnerExtrThin );
            // showContainer.push( psgeInnerExtrThin );

            const psgeOutterExtrThin = addExtr( psgeOutterShp, 'crimson', 0.00001, 1 ); // convex하기 위해 얇게 모델링
            psgePositionGeometry( psgeOutterExtrThin );
            // showContainer.push( psgeOutterExtrThin );

            const psgeScExtrThin = addExtr( psgeScShp, 'crimson', 0.00001, 1 ); // convex하기 위해 얇게 모델링
            psgePositionGeometry( psgeScExtrThin );
            // showContainer.push( psgeScExtrThin );
            
            
            /********************************************************************************************************************************************************
             * 포인트를 회전해서 모델링하면 시간이 더 오래 걸림
            const psgeInnerGetpts = psgeInnerShp.getPoints( 100 ); // get Vector2
            const psgeInnerPts = new THREE.BufferGeometry().setFromPoints( psgeInnerGetpts ); // convert Vector3

            psgeInnerPts.rotateY( Math.PI*3/2 );
            psgeInnerPts.translate( -1.5, 0, 0 );
            psgeInnerPts.rotateZ( verticalAngle );
            psgeInnerPts.rotateY( horizontalAngle );
            psgeInnerPts.translate( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 )


            const psgeOutterGetpts = psgeOutterShp.getPoints( 100 ); // get Vector2
            const psgeOutterPts = new THREE.BufferGeometry().setFromPoints( psgeOutterGetpts ); // convert Vector3

            psgeOutterPts.rotateY( Math.PI*3/2 );
            psgeOutterPts.translate( -1.5, 0, 0 );
            psgeOutterPts.rotateZ( verticalAngle );
            psgeOutterPts.rotateY( horizontalAngle );
            psgeOutterPts.translate( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 )
            
            // const particles = new THREE.Points( psgeOutterPts, new THREE.PointsMaterial( { color: 'red', size: 4 } ) );
            // showContainer.push( particles );


            const psgeScGetpts = psgeScShp.getPoints( 100 ); // get Vector2
            const psgeScPts = new THREE.BufferGeometry().setFromPoints( psgeScGetpts ); // convert Vector3

            psgeScPts.rotateY( Math.PI*3/2 );
            psgeScPts.translate( -1.5, 0, 0 );
            psgeScPts.rotateZ( verticalAngle );
            psgeScPts.rotateY( horizontalAngle );
            psgeScPts.translate( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 )
            *******************************************************************************************************************************************************/
            
            function connPositionGeometry ( mesh ) {
                mesh.geometry.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) ) // 270도 회전
                    .applyMatrix4( matrix.makeTranslation( 10/2, 0, 0 ) ) // extrude연장의 중심이 되도록
                    .applyMatrix4( matrix.makeRotationZ( THREE.Math.degToRad( ui.verticalAngle ) ) )
                    .applyMatrix4( matrix.makeRotationY( THREE.Math.degToRad( ui.horizontalAngle ) ) )
                    .applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                return mesh
            }

            const connInnerExtr = addExtr( connInnerShp, 'coral', 10, 1 );
            connPositionGeometry( connInnerExtr );
            // showContainer.push( connInnerExtr );         

            const connOutterExtr = addExtr( connOutterShp, 'royalblue', 10, 1 );
            connPositionGeometry( connOutterExtr );
            // showContainer.push( connOutterExtr );

            const connScExtr = addExtr( connScShp, 'skyblue', 10, 1 );
            connPositionGeometry( connScExtr );
            // showContainer.push( connScExtr );

            // a) 접속부 헌치 내측

            // IntersectCSG
            const connInnerIntCsg = new CSG();
            connInnerIntCsg.intersect( [ connInnerExtr, innerAreaExtr ] );
            const connInnerIntMesh = connInnerIntCsg.toMesh();

            // Intersect point 추출
            const connInnerPts = [];

            for ( let i=0; i < connInnerIntMesh.geometry.attributes.position.count; i++) {
                connInnerPts.push( new THREE.Vector3(
                    connInnerIntMesh.geometry.attributes.position.getX( i ),
                    connInnerIntMesh.geometry.attributes.position.getY( i ),
                    connInnerIntMesh.geometry.attributes.position.getZ( i )
                ));
            }

            for ( let i=0; i < psgeInnerExtrThin.geometry.attributes.position.count; i++) {
                connInnerPts.push( new THREE.Vector3(
                    psgeInnerExtrThin.geometry.attributes.position.getX( i ),
                    psgeInnerExtrThin.geometry.attributes.position.getY( i ),
                    psgeInnerExtrThin.geometry.attributes.position.getZ( i )
                ));
            }

            // for ( let i=0; i < psgeInnerPts.attributes.position.count; i++) {
            //     connInnerPts.push( new THREE.Vector3(
            //         psgeInnerPts.attributes.position.getX( i ),
            //         psgeInnerPts.attributes.position.getY( i ),
            //         psgeInnerPts.attributes.position.getZ( i )
            //     ));
            // }

            // convex로 모델링
            const connInnerConvexGeo = new ConvexGeometry( connInnerPts );
            const connInnerConvexMat = new THREE.MeshStandardMaterial( {color: 'darkblue', opacity: 1, transparent: true, clippingPlanes: [ clippingPlane ] } );
            const connInnerConvexMesh = new THREE.Mesh( connInnerConvexGeo, connInnerConvexMat );
            // showContainer.push( connInnerConvexMesh );
   
            // b) 접속부 헌치 외측

            // intersectCSG
            const connOutterIntCsg = new CSG();
            connOutterIntCsg.intersect( [ connOutterExtr, innerAreaExtr ] );
            const connOutterIntMesh = connOutterIntCsg.toMesh();
            // showContainer.push( connOutterIntMesh );

            // Intersect point 추출
            const connOutterPts = [];

            for ( let i=0; i < connOutterIntMesh.geometry.attributes.position.count; i++) {
                connOutterPts.push( new THREE.Vector3(
                    connOutterIntMesh.geometry.attributes.position.getX( i ),
                    connOutterIntMesh.geometry.attributes.position.getY( i ),
                    connOutterIntMesh.geometry.attributes.position.getZ( i )
                ));
            }

            for ( let i=0; i < psgeOutterExtrThin.geometry.attributes.position.count; i++) {
                connOutterPts.push( new THREE.Vector3(
                    psgeOutterExtrThin.geometry.attributes.position.getX( i ),
                    psgeOutterExtrThin.geometry.attributes.position.getY( i ),
                    psgeOutterExtrThin.geometry.attributes.position.getZ( i )
                ));
            }

            // for ( let i=0; i < psgeOutterPts.attributes.position.count; i++) {
            //     connOutterPts.push( new THREE.Vector3(
            //         psgeOutterPts.attributes.position.getX( i ),
            //         psgeOutterPts.attributes.position.getY( i ),
            //         psgeOutterPts.attributes.position.getZ( i )
            //     ));
            // };            

            // convex로 모델링
            const connOutterConvexGeo = new ConvexGeometry( connOutterPts );
            const connOutterConvexMat = new THREE.MeshStandardMaterial( {color: 'paleturquoise', opacity: 1, transparent: true, clippingPlanes: [ clippingPlane ] } );
            const connOutterConvexMesh = new THREE.Mesh( connOutterConvexGeo, connOutterConvexMat );
            // showContainer.push( connOutterConvexMesh );
            
            // c) 접속부 헌치 숏크리트

            // IntersectCSG
            const connScIntCsg = new CSG();
            connScIntCsg.intersect( [ connScExtr, innerAreaExtr ] );
            const connScIntMesh = connScIntCsg.toMesh();

            // Intersect point 추출
            const connScPts = [];

            for ( let i=0; i < connScIntMesh.geometry.attributes.position.count; i++) {
                connScPts.push( new THREE.Vector3(
                    connScIntMesh.geometry.attributes.position.getX( i ),
                    connScIntMesh.geometry.attributes.position.getY( i ),
                    connScIntMesh.geometry.attributes.position.getZ( i )
                ));
            }

            for ( let i=0; i < psgeScExtrThin.geometry.attributes.position.count; i++) {
                connScPts.push( new THREE.Vector3(
                    psgeScExtrThin.geometry.attributes.position.getX( i ),
                    psgeScExtrThin.geometry.attributes.position.getY( i ),
                    psgeScExtrThin.geometry.attributes.position.getZ( i )
                ));
            }

            // for ( let i=0; i < psgeScPts.attributes.position.count; i++) {
            //     connScPts.push( new THREE.Vector3(
            //         psgeScPts.attributes.position.getX( i ),
            //         psgeScPts.attributes.position.getY( i ),
            //         psgeScPts.attributes.position.getZ( i )
            //     ));
            // };   

            // convex로 모델링
            const connScConvexGeo = new ConvexGeometry( connScPts );
            const connScConvexMat = new THREE.MeshStandardMaterial( { color: 'mediumturquoise', opacity: 1, transparent: true, clippingPlanes: [ clippingPlane ] } );
            const connScConvexMesh = new THREE.Mesh( connScConvexGeo, connScConvexMat );
            // showContainer.push( connScConvexMesh );


            // 4. 최종모델링 ////////////////////////////////////////////////////////////////////////////////////////////////////

            // 4.1 최종 차집합

            // 연결통로 접속부 헌치
            const connSub1Csg = new CSG();
            connSub1Csg.subtract( [ connOutterConvexMesh, connInnerConvexMesh, innerAreaExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
            const connSub1Mesh = connSub1Csg.toMesh();
            showContainer.push( connSub1Mesh );

            // 연결통로 접속부 헌치 숏크리트
            const connScSubCsg = new CSG();
            connScSubCsg.subtract( [ connScConvexMesh, connOutterConvexMesh, outterAreaExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
            const connScSubMesh = connScSubCsg.toMesh();
            showContainer.push( connScSubMesh );

            // 본선 접속부 hole
            const mainConnSubCsg = new CSG();
            mainConnSubCsg.subtract( [ mainConnExtr, connOutterConvexMesh ] );
            const mainConnSubMesh = mainConnSubCsg.toMesh();
            showContainer.push( mainConnSubMesh );


            // 본선 접속부 숏크리트 hole
            const mainConnScSubCsg = new CSG();
            mainConnScSubCsg.subtract( [ mainConnScExtr, connScConvexMesh ] );
            const mainConnScSubMesh = mainConnScSubCsg.toMesh();
            showContainer.push( mainConnScSubMesh );


            // 피난연결통로 포장


            // 4.2 공동구 뚜껑
            let coverLeftB0, coverRightB0, coverL, coverS;
            const coverT = 0.060;

            switch ( footingType ) {

                case '자연환기' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[15].x - footingRtType[8].x );

                    coverL = 0.480;
                    coverS = 0.500; // spacing

                    break;

                case '기계환기' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[15].x - footingRtType[8].x );
              
                    coverL = 0.250;
                    coverS = 0.250; // spacing

                    break;

                case '기계환기(물분무)' :

                    coverLeftB0 = -( footingLtType[15].x - footingLtType[8].x );
                    coverRightB0 = ( footingRtType[16].x - footingRtType[8].x );

                    coverL = 0.250;
                    coverS = 0.250; // spacing

                    break;

            }

            const coverLeftB1 = ( ( coverLeftB0 - 0.020 ) - ( 0.025 + 0.150 +0.025 ) ) / 2;

            const coverSlabLtShp = new THREE.Shape();
            coverSlabLtShp.moveTo( 0, 0 );
            coverSlabLtShp.lineTo( 0, coverL );
            coverSlabLtShp.lineTo( - coverLeftB1, coverL );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025, coverL -0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150, coverL -0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150 - 0.025, coverL );
            coverSlabLtShp.lineTo( - coverLeftB0 + 0.020, coverL );
            coverSlabLtShp.lineTo( - coverLeftB0 + 0.020, 0 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150 - 0.025, 0 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025 - 0.150, 0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1 - 0.025, 0.025 );
            coverSlabLtShp.lineTo( - coverLeftB1, 0 );
            coverSlabLtShp.lineTo( 0, 0 );

            const coverSlabLtExtr = addExtr( coverSlabLtShp, 'powderblue', coverT, 0.9 );
            coverSlabLtExtr.rotateX( Math.PI/2 )

            const coverRightB1 = ( ( coverRightB0 - 0.020 ) - ( 0.025 + 0.150 +0.025 ) ) / 2;

            const coverSlabRtShp = new THREE.Shape();
            coverSlabRtShp.moveTo( 0, 0 );
            coverSlabRtShp.lineTo( 0, coverL );
            coverSlabRtShp.lineTo( coverRightB1, coverL );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025, coverL -0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150, coverL -0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150 + 0.025, coverL );
            coverSlabRtShp.lineTo( coverRightB0 - 0.020, coverL );
            coverSlabRtShp.lineTo( coverRightB0 - 0.020, 0 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150 + 0.025, 0 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025 + 0.150, 0.025 );
            coverSlabRtShp.lineTo( coverRightB1 + 0.025, 0.025 );
            coverSlabRtShp.lineTo( coverRightB1, 0 );
            coverSlabRtShp.lineTo( 0, 0 );

            const coverSlabRtExtr = addExtr( coverSlabRtShp, 'powderblue', coverT, 0.9 );
            coverSlabRtExtr.rotateX( Math.PI/2 )            

            // 본선 공동구 뚜껑 배치
            for ( let i=0; i*coverS<mainTunnelLength; i++ ) {

                const covercloneLt1 = coverSlabLtExtr.clone();
                covercloneLt1.position.set( footingLtType[8].x + concreteLt.x - 0.010, footingLtType[8].y + concreteLt.y, i*coverS );
                showContainer.push( covercloneLt1 );

                const covercloneLt2 = coverSlabLtExtr.clone();
                covercloneLt2.position.set( footingLtType[8].x + concreteLt.x - 0.010, footingLtType[8].y + concreteLt.y, ui.totalLength - mainTunnelLength + i*coverS );
                showContainer.push( covercloneLt2 );

            }

            for ( let i=0; i*coverS<ui.totalLength; i++ ) {        

                const covercloneRt = coverSlabRtExtr.clone();
                covercloneRt.position.set( footingRtType[8].x + concreteRt.x + 0.010, footingRtType[8].y + concreteRt.y, i*coverS );
                showContainer.push( covercloneRt );

            }            

            // 계단부 공동구 뚜껑 배치
            if ( footingType == '자연환기' ) {

                // 계단1
                const coveStair1 = coverSlabLtExtr.clone();
                coveStair1.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, mainTunnelLength );
                showContainer.push( coveStair1 );

                const coveStair1_Clone2 = coverSlabLtExtr.clone();
                coveStair1_Clone2.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, ui.totalLength - mainTunnelLength - stairLength );
                showContainer.push( coveStair1_Clone2 );
                
                // 계단2
                const coveStair2 = coverSlabLtExtr.clone();
                coveStair2.position.set( stair2Slope[7].x - 0.010, stair2Slope[7].y, mainTunnelLength + stairLength );
                showContainer.push( coveStair2 );

                const coveStair2_Clone2 = coverSlabLtExtr.clone();
                coveStair2_Clone2.position.set( stair2Slope[7].x - 0.010, stair2Slope[7].y, ui.totalLength - mainTunnelLength - 2*stairLength );
                showContainer.push( coveStair2_Clone2 );

                // 계단3
                const coveStair3 = coverSlabLtExtr.clone();
                coveStair3.position.set( stair3Slope[6].x - 0.010, stair3Slope[6].y, mainTunnelLength + 2*stairLength );
                showContainer.push( coveStair3 );

                const coveStair3_Clone2 = coverSlabLtExtr.clone();
                coveStair3_Clone2.position.set( stair3Slope[6].x - 0.010, stair3Slope[6].y, ui.totalLength - mainTunnelLength - 3*stairLength );
                showContainer.push( coveStair3_Clone2 );


            } else {

                // 기계환기
                
                // 계단1
                const coveStair1 = coverSlabLtExtr.clone();
                coveStair1.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, mainTunnelLength );
                showContainer.push( coveStair1 );

                const coveStair1_Clone1 = coverSlabLtExtr.clone();
                coveStair1_Clone1.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, mainTunnelLength + coverS );
                showContainer.push( coveStair1_Clone1 );

                const coveStair1_Clone2 = coverSlabLtExtr.clone();
                coveStair1_Clone2.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, ui.totalLength - mainTunnelLength - stairLength );
                showContainer.push( coveStair1_Clone2 );

                const coveStair1_Clone3 = coverSlabLtExtr.clone();
                coveStair1_Clone3.position.set( stair1Slope[8].x - 0.010, stair1Slope[8].y, ui.totalLength - mainTunnelLength - stairLength + coverS );
                showContainer.push( coveStair1_Clone3 );
                
                // 계단2
                const coveStair2 = coverSlabLtExtr.clone();
                coveStair2.position.set( stair2Slope[9].x - 0.010, stair2Slope[9].y, mainTunnelLength + stairLength );
                showContainer.push( coveStair2 );

                const coveStair2_Clone1 = coverSlabLtExtr.clone();
                coveStair2_Clone1.position.set( stair2Slope[9].x - 0.010, stair2Slope[9].y, mainTunnelLength + stairLength + coverS );
                showContainer.push( coveStair2_Clone1 );

                const coveStair2_Clone2 = coverSlabLtExtr.clone();
                coveStair2_Clone2.position.set( stair2Slope[9].x - 0.010, stair2Slope[9].y, ui.totalLength - mainTunnelLength - 2*stairLength );
                showContainer.push( coveStair2_Clone2 );

                const coveStair2_Clone3 = coverSlabLtExtr.clone();
                coveStair2_Clone3.position.set( stair2Slope[9].x - 0.010, stair2Slope[9].y, ui.totalLength - mainTunnelLength - 2*stairLength + coverS );
                showContainer.push( coveStair2_Clone3 );

                // 계단3
                const coveStair3 = coverSlabLtExtr.clone();
                coveStair3.position.set( stair3Slope[7].x - 0.010, stair3Slope[7].y, mainTunnelLength + 2*stairLength );
                showContainer.push( coveStair3 );

                const coveStair3_Clone1 = coverSlabLtExtr.clone();
                coveStair3_Clone1.position.set( stair3Slope[7].x - 0.010, stair3Slope[7].y, mainTunnelLength + 2*stairLength + coverS );
                showContainer.push( coveStair3_Clone1 );

                const coveStair3_Clone2 = coverSlabLtExtr.clone();
                coveStair3_Clone2.position.set( stair3Slope[7].x - 0.010, stair3Slope[7].y, ui.totalLength - mainTunnelLength - 3*stairLength );
                showContainer.push( coveStair3_Clone2 );

                const coveStair3_Clone3 = coverSlabLtExtr.clone();
                coveStair3_Clone3.position.set( stair3Slope[7].x - 0.010, stair3Slope[7].y, ui.totalLength - mainTunnelLength - 3*stairLength + coverS );
                showContainer.push( coveStair3_Clone3 );

            }


            // 4.3 본선접속부 공동구 덮개 배치
            if ( ui.crossPsgeType == '대인용' ) {

                for ( let i=0; i*coverS<footingConnLength; i++ ) {        

                    const coverConn = coverSlabLtExtr.clone();
                    coverConn.position.set( footingConn[5].x + concreteLt.x - 0.010, footingConn[5].y + concreteLt.y, mainTunnelLength + 3*stairLength + i*coverS );
                    showContainer.push( coverConn );

                }

            } else {

                // 스틸플레이트
                const steelPlateLen = 0.500;

                const steelPlateShp = new THREE.Shape();
                steelPlateShp.moveTo( 0, 0 );
                steelPlateShp.lineTo( 0, steelPlateLen );
                steelPlateShp.lineTo( -coverLeftB0, steelPlateLen );
                steelPlateShp.lineTo( -coverLeftB0, 0 );
                steelPlateShp.lineTo( 0, 0 );
                
                const plateHole1 = new THREE.Path();
                plateHole1.absarc( -0.070, 0.070, 0.015, 0, 2*Math.PI, false );

                const plateHole2 = new THREE.Path();
                plateHole2.absarc( -0.070, steelPlateLen-0.070, 0.015, 0, 2*Math.PI, false );            

                const plateHole3 = new THREE.Path();
                plateHole3.absarc( -coverLeftB0 + 0.070, steelPlateLen-0.070, 0.015, 0, 2*Math.PI, false ); 

                const plateHole4 = new THREE.Path();
                plateHole4.absarc( -coverLeftB0 + 0.070, 0.070, 0.015, 0, 2*Math.PI, false );

                steelPlateShp.holes.push( plateHole1 );
                steelPlateShp.holes.push( plateHole2 );
                steelPlateShp.holes.push( plateHole3 );
                steelPlateShp.holes.push( plateHole4 );

                const steelPlateExtr = addExtr( steelPlateShp, 'coral', 0.030, 0.9 );
                steelPlateExtr.rotateX( Math.PI/2 )

                for ( let i=0; i*steelPlateLen<footingConnLength; i++ ) {        

                    const steelPlateClone = steelPlateExtr.clone();
                    steelPlateClone.position.set( footingConn[5].x + concreteLt.x, footingConn[5].y + concreteLt.y, mainTunnelLength + 3*stairLength + i*steelPlateLen );
                    showContainer.push( steelPlateClone );

                }

            }


            if ( ui.category =='보강도') {

                /****************************************************************************************************
                 * 보강도 contents
                 * 
                 * <록볼트>
                 * 1. 록볼트 제원
                 * 2. 본선 록볼트
                 * 3. 피난연결통로 록볼트
                 * 4. 접속부 헌치 록볼트
                 * 
                 * <본선 강지보공(Steel Rib)>
                 * 1. 환봉형상(환봉1, 환봉2)
                 * 2. 환봉 옵셋거리
                 * 3. 영역계산(환봉1, 환봉2)
                 * 4. 환봉모델링
                 * 5. 부등변 앵글 좌우측배치
                 * 6. 스파이더 좌우측배치
                 * 7. 연결고리 좌우측배치
                 * 8. 바닥부 모델링
                 * 9. 지보보강록볼트
                 * 
                 * <피난연결통로 강지보공(passage SteelRib)
                 * 
                 ****************************************************************************************************/

                // 1. 록볼트 제원 ////////////////////////////////////////////////////////////////////////////////////////////////////
                const rockboltShp = new THREE.Shape();
                rockboltShp.absarc( 0, 0, 0.025/2, 0, Math.PI * 2, false );

                // 본선 록볼트 
                const rbGeo = new THREE.ExtrudeBufferGeometry( rockboltShp, { steps : 1, depth : ui.rbLength,  bevelEnabled : false} );
                const rbmat = new THREE.MeshStandardMaterial( {color: 'darkcyan'} );

                const rbCircSpacing = ui.rbCircSpacing/2;

                // 접속부 록볼트
                const psgeRbGeo = new THREE.ExtrudeBufferGeometry( rockboltShp, { steps : 1, depth : ui.psgeRbLength,  bevelEnabled : false} );
                const psgeRbmat = new THREE.MeshStandardMaterial( {color: 'plum'} );

                const psgeRbCircSpacing = ui.psgeRbCircSpacing/2;

                // 접속부 헌치 록볼트
                const connRbGeo = new THREE.ExtrudeBufferGeometry( rockboltShp, { steps : 1, depth : ui.psgeRbLength,  bevelEnabled : false} );
                const connRbmat = new THREE.MeshStandardMaterial( {color: 'orange'} );
                

                // 1. 본선 록볼트 ////////////////////////////////////////////////////////////////////////////////////////////////////

                if ( ui.rbZone != '없음' ) {

                    // 록볼트 생성 경로
                    const rbPathLeft = new THREE.Shape();
                    rbPathLeft.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                    rbPathLeft.absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta2, false );
                    
                    const rbPathRight = new THREE.Shape();
                    rbPathRight.absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 - r1ThetaRt, true );
                    rbPathRight.absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta2, true );

                    // 록볼트 컨테이너
                    const rbLeftContainer = [];
                    const rbRightContainer = [];

                    // 록볼트 센터 생성
                    let rbCenter

                    {

                        // 록볼트 횡간격으로 나누기
                        const segment = rbPathLeft.getPointAt( 0 );

                        const rbMesh = new THREE.Mesh( rbGeo, rbmat );

                        rbMesh.rotation.x = -Math.PI/2;
                        rbMesh.position.y = segment.y;

                        rbCenter = rbMesh;

                    }

                    // 록볼트 좌우측 생성
                    rbDraw( rbPathLeft, rbCircSpacing, +1, rbGeo, rbmat, rbLeftContainer );
                    rbDraw( rbPathRight, rbCircSpacing, -1, rbGeo, rbmat, rbRightContainer );

                    // 마지막 록볼트 삭제
                    if ( ui.rbLtLastDel == true ) { rbLeftContainer.pop() }
                    if ( ui.rbRtLastDel == true ) { rbRightContainer.pop() }

                    // 록볼트 좌측 배치
                    const rbLtGroup = new THREE.Group();
                
                    rbLeftContainer.forEach( i => rbLtGroup.add( i ) );
                    
                    switch ( ui.crossPsgeType ) {

                        case '대인용' : {

                            // 원형
                            const holeR = pConnR1Final + pConnLiningT0 + ui.psgeShotcrete;
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = pConnR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;
                            
                            for ( let i=0; i*ui.longSpacing + 0.5*ui.longSpacing < ui.totalLength; i++) {

                                const rbGroupClone = rbLtGroup.clone();

                                if ( holeX - holeR <= i*ui.longSpacing + 0.5*ui.longSpacing && i*ui.longSpacing + 0.5*ui.longSpacing <= holeX + holeR ) {

                                    for ( let j=0; j < rbGroupClone.children.length; j++ ) {

                                        if ( holeR >=  Math.sqrt( Math.pow( ( i*ui.longSpacing + 0.5*ui.longSpacing- holeX ), 2 ) + Math.pow( ( rbGroupClone.children[j].position.y - holeY ), 2 ) ) ) {

                                            for ( let k= rbGroupClone.children.length; k >= j; k-- ) {

                                                rbGroupClone.remove( rbGroupClone.children[k] )

                                            }

                                        }

                                    }

                                }

                                rbGroupClone.position.set( 0, 0, i*ui.longSpacing + 0.5*ui.longSpacing )
                                showContainer.push( rbGroupClone )

                            }

                            break;

                        }

                        case '차량용' : {

                            // 타원형
                            const aa = vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete; // 타원 장축
                            const bb = vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete; // 타원 단축
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = vPsgeR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;

                            for ( let i=0; i*ui.longSpacing + 0.5*ui.longSpacing < ui.totalLength; i++) {

                                const rbGroupClone = rbLtGroup.clone();
                                const boundaryY = Math.sqrt( bb*bb - (  bb*bb * Math.pow( ( i*ui.longSpacing + 0.5*ui.longSpacing - holeX ),2 ) / (aa*aa) ) ) + holeY;
                                
                                if ( holeX - aa <= i*ui.longSpacing + 0.5*ui.longSpacing && i*ui.longSpacing + 0.5*ui.longSpacing <= holeX + aa ) {

                                    for ( let j=0; j < rbGroupClone.children.length; j++ ) {

                                        if ( rbGroupClone.children[j].position.y <= boundaryY ) {

                                            for ( let k= rbGroupClone.children.length; k >= j; k-- ) {

                                                rbGroupClone.remove( rbGroupClone.children[k] )

                                            }

                                        }

                                    }

                                }

                                rbGroupClone.position.set( 0, 0, i*ui.longSpacing + 0.5*ui.longSpacing )
                                showContainer.push( rbGroupClone )

                            }

                            break;
                            
                        }

                        case '대형차량용' : {

                            // 타원형
                            const aa = hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete; // 타원 장축
                            const bb = hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete; // 타원 단축
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = hPsgeR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;

                            for ( let i=0; i*ui.longSpacing + 0.5*ui.longSpacing < ui.totalLength; i++) {

                                const rbGroupClone = rbLtGroup.clone();
                                const boundaryY = Math.sqrt( bb*bb - ( bb*bb * Math.pow( ( i*ui.longSpacing + 0.5*ui.longSpacing - holeX ),2 ) / (aa*aa) ) ) + holeY;

                                if ( holeX - aa <= i*ui.longSpacing + 0.5*ui.longSpacing && i*ui.longSpacing + 0.5*ui.longSpacing <= holeX + aa ) {

                                    for ( let j=0; j < rbGroupClone.children.length; j++ ) {

                                        if ( rbGroupClone.children[j].position.y <= boundaryY ) {

                                            for ( let k= rbGroupClone.children.length; k >= j; k-- ) {

                                                rbGroupClone.remove( rbGroupClone.children[k] )

                                            }

                                        }

                                    }

                                }

                                rbGroupClone.position.set( 0, 0, i*ui.longSpacing + 0.5*ui.longSpacing )
                                showContainer.push( rbGroupClone )

                            }

                            break;

                        }

                    }

                    // 록볼트 우측 배치
                    const rbRtGroup = new THREE.Group();
                    
                    rbRightContainer.forEach( i => rbRtGroup.add( i ) );

                    rbRtGroup.add( rbCenter );
                    
                    for ( let i=0; i*ui.longSpacing + 0.5*ui.longSpacing < ui.totalLength; i++) {

                        const rbGroupClone = rbRtGroup.clone();
                        rbGroupClone.position.set( 0, 0, i*ui.longSpacing + 0.5*ui.longSpacing )
                        showContainer.push( rbGroupClone )

                    }

                }


                // 3. 피난연결통로 록볼트 ////////////////////////////////////////////////////////////////////////////////////////////////////

                if ( ui.psgeRbZone != '없음' ) { 

                    // 연결통로 록볼트 생성 경로        
                    let psgeRbLeftShp, psgeRbRightShp

                    switch ( ui.crossPsgeType ) {

                        case ('대인용') : {

                            psgeRbLeftShp = new THREE.Shape();
                            psgeRbLeftShp.absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false );
                            psgeRbLeftShp.lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete, pPsgeFootingLeftPt.y - pPsgePavement );

                            psgeRbRightShp = new THREE.Shape();
                            psgeRbRightShp.absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true );
                            psgeRbRightShp.lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete, pPsgeFootingRightPt.y - pPsgePavement );

                            break;
                        }

                        case ('차량용') : {

                            psgeRbLeftShp = new THREE.Shape();
                            psgeRbLeftShp.absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false );
                            psgeRbLeftShp.absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta2, false );

                            psgeRbRightShp = new THREE.Shape();
                            psgeRbRightShp.absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true );
                            psgeRbRightShp.absarc( vPsgeR5Origin.x, vPsgeR5Origin.y, vPsgeR5Final + ui.psgeShotcrete, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR5Theta2, true );     

                            break;

                        }

                        case ('대형차량용') : {

                            psgeRbLeftShp = new THREE.Shape();
                            psgeRbLeftShp.absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false );
                            psgeRbLeftShp.absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete, Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta2, false );
                            
                            psgeRbRightShp = new THREE.Shape();
                            psgeRbRightShp.absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true );
                            psgeRbRightShp.absarc( - hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta2, true );

                            break;

                        }

                    }

                    // 연결통로 록볼트 컨테이너
                    const psgeRbLeftCotainer = [];
                    const psgeRbRightCotainer = [];

                    // 연결통로 록볼트 센터 생성
                    let psgeRbCenter

                    {

                        // 연결통로 록볼트 횡간격으로 나누기
                        const segment = psgeRbLeftShp.getPointAt( 0 );

                        const rbMesh = new THREE.Mesh( psgeRbGeo, psgeRbmat );
                        rbMesh.rotation.x = -Math.PI/2;
                        rbMesh.position.y = segment.y

                        psgeRbCenter = rbMesh;

                    };

                    // 연결통로 록볼트 좌우측 생성
                    rbDraw( psgeRbLeftShp, psgeRbCircSpacing, +1, psgeRbGeo, psgeRbmat, psgeRbLeftCotainer );
                    rbDraw( psgeRbRightShp, psgeRbCircSpacing, -1, psgeRbGeo, psgeRbmat, psgeRbRightCotainer );

                    // 연결통로 록볼트 1cycle, 2cycle
                    const psgeRbGroup1 = new THREE.Group();
                    const psgeRbGroup2 = new THREE.Group();
                    
                    for( let i=0; i < psgeRbLeftCotainer.length; i++ ) {

                        if( i % 2 == 0 ) {

                            psgeRbGroup1.add( psgeRbLeftCotainer[ i ] );

                        } else {

                            psgeRbGroup2.add( psgeRbLeftCotainer[ i ] );

                        }

                    }

                    for( let i=0; i < psgeRbRightCotainer.length; i++ ) {

                        if( i % 2 == 0 ) {

                            psgeRbGroup1.add( psgeRbRightCotainer[ i ] );

                        } else {

                            psgeRbGroup2.add( psgeRbRightCotainer[ i ] );

                        }

                    }

                    // 연결통로 록볼트 센터 추가
                    psgeRbGroup2.add( psgeRbCenter );  

                    // 연결통로 추가보강구간 배치
                    for ( let i=0; i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing < netReinforceL ; i++) {

                        const rbGroupClone1 = psgeRbGroup1.clone();
                        rbGroupClone1.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                        rbGroupClone1.applyMatrix4( matrix.makeTranslation( -1.5 -( i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing ), 0, 0 ) );
                        rbGroupClone1.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                        rbGroupClone1.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                        rbGroupClone1.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                        showContainer.push( rbGroupClone1 )

                        const rbGroupClone2 = psgeRbGroup2.clone();
                        rbGroupClone2.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                        rbGroupClone2.applyMatrix4( matrix.makeTranslation( -1.5 -( i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing ), 0, 0 ) );
                        rbGroupClone2.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                        rbGroupClone2.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                        rbGroupClone2.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );               
                        showContainer.push( rbGroupClone2 )

                    }

                    // // 연결통로 록볼트 배치
                    // for ( let i=0; i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing < (psgeLength-netReinforceL) ; i++) {

                    //     if ( i % 2 == 0 ) {

                    //         const rbGroupClone1 = psgeRbGroup1.clone();
                    //         rbGroupClone1.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                    //         rbGroupClone1.applyMatrix4( matrix.makeTranslation( -1.5 -( i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing ) - netReinforceL, 0, 0 ) );
                    //         rbGroupClone1.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                    //         rbGroupClone1.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                    //         rbGroupClone1.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );

                    //         showContainer.push( rbGroupClone1 )

                    //     } else {

                    //         const rbGroupClone2 = psgeRbGroup2.clone();
                    //         rbGroupClone2.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                    //         rbGroupClone2.applyMatrix4( matrix.makeTranslation( -1.5 -( i*ui.psgeLongSpacing + 0.5*ui.psgeLongSpacing ) - netReinforceL, 0, 0 ) );
                    //         rbGroupClone2.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                    //         rbGroupClone2.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                    //         rbGroupClone2.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );

                    //         showContainer.push( rbGroupClone2 )

                    //     }

                    // }

                    // 연결통로 보강범위 가이드 라인
                    const psgeScLine = addLine( psgeScShp, 'black' );
                    psgeScLine.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                    psgeScLine.applyMatrix4( matrix.makeTranslation( -1.5 - netReinforceL, 0, 0 ) );
                    psgeScLine.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                    psgeScLine.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                    psgeScLine.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );

                    showContainer.push( psgeScLine );


                    // 4. 접속부 헌치 록볼트 ////////////////////////////////////////////////////////////////////////////////////////////////////

                    // 4.1 raycast가 위치할 경로 : 접속부 헌치 보다 약간 큰 가상의 경로 생성
                    let connLeftPath, connRightPath

                    const offsetDist = 0.01;
                    const bottomOffset = 0.2; // 바닥에서 좀 띄워줌

                    switch ( ui.crossPsgeType ) {

                        case ('대인용') : {

                            connLeftPath = new THREE.Shape();
                            connLeftPath.absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false );
                            connLeftPath.lineTo( -pConnR1Final - pConnLiningT0 - ui.psgeShotcrete - offsetDist, pPsgeFootingLeftPt.y - pPsgePavement + bottomOffset );
                            
                            connRightPath = new THREE.Shape();
                            connRightPath.absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true );
                            connRightPath.lineTo( pConnR1Final + pConnLiningT0 + ui.psgeShotcrete + offsetDist, pPsgeFootingRightPt.y - pPsgePavement + bottomOffset );

                            break;
                        }

                        case ('차량용') : {

                            const vConnR3Gamma3 = Math.asin( ( vConnR3Origin.y + vPsgePavement - bottomOffset ) / ( vConnR3Final + ui.psgeShotcrete + offsetDist ) );
                            const vConnR3Theta3 = Math.PI/2 - vPsgeR1Theta + vConnR3Gamma3;

                            connLeftPath = new THREE.Shape();
                            connLeftPath.absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + offsetDist, vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false );
                            connLeftPath.absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final + ui.psgeShotcrete + offsetDist, Math.PI, Math.PI + vConnR3Theta3, false );

                            connRightPath = new THREE.Shape();
                            connRightPath.absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + offsetDist, vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true );
                            connRightPath.absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final + ui.psgeShotcrete + offsetDist, 0, -vConnR3Theta3, true );

                            break;

                        }

                        case ('대형차량용') : {

                            const hConnR3Gamma3 = Math.asin( ( hConnR3Origin.y + hPsgePavement - bottomOffset ) / ( hConnR3Final + ui.psgeShotcrete  + offsetDist) );
                            const hConnR3Theta3 = Math.PI/2 - hPsgeR1Theta + hConnR3Gamma3;

                            connLeftPath = new THREE.Shape();
                            connLeftPath.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + offsetDist, hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false );
                            connLeftPath.absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hConnR3Theta3, false );
                            
                            connRightPath = new THREE.Shape();
                            connRightPath.absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + offsetDist, hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true );
                            connRightPath.absarc( - hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + hConnLiningT0 + ui.psgeShotcrete + offsetDist, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hConnR3Theta3, true );
                            
                            break;

                        }

                    }

                    // 4.2 접속부 헌치 록볼트 생성
                    const divideSpacing = 0.1;
                    
                    for ( let i=0; i<5; i++ ) {

                        // raycast 타켓생성
                        const scGeometry = connScSubMesh.geometry.clone();
                        scGeometry.translate( -(-r2Final + r2Origin.x), -(footingConnSlope[footingConnSlope.length-1].y), -(mainTunnelLength + footingConnLength/2 + stairLength*3) );
                        scGeometry.rotateZ( verticalAngle );
                        scGeometry.rotateY( horizontalAngle );
                        scGeometry.rotateY( Math.PI/2 );
                        scGeometry.translate( 0, 0, -0.75 + i*ui.psgeLongSpacing );

                        const scMesh = new THREE.Mesh( scGeometry, connOutterConvexMat );
                        // showContainer.push( scMesh )


                        // 좌측
                        const connLeftPathPoints = []; // raycast로 경로Point 생성

                        for ( let j=0; j*divideSpacing < connLeftPath.getLength(); j++ ) {
                        
                            const segment = connLeftPath.getPointAt( j*divideSpacing / connLeftPath.getLength() );
                            const tangent = connLeftPath.getTangentAt( j*divideSpacing / connLeftPath.getLength() );
                            
                            const raycast = new THREE.Raycaster();
                            raycast.set( new THREE.Vector3( segment.x, segment.y, 0 ), new THREE.Vector3( -tangent.y, tangent.x, 0 ).normalize() );
                            const intersectLeft = raycast.intersectObject( scMesh )
                            
                            if( intersectLeft.length != 0 ) {
                                
                                connLeftPathPoints.push( new THREE.Vector3( intersectLeft[0].point.x, intersectLeft[0].point.y, 0 ) );

                            }
                            
                        }

                        if( connLeftPathPoints.length != 0 ) {
                            
                            const raycastLine = new THREE.Shape( connLeftPathPoints ); // 경로 Points => Line으로 변경

                            const connRbGroup = new THREE.Group();

                            for ( let j=1; j*psgeRbCircSpacing <= raycastLine.getLength(); j++) {

                                const segment = raycastLine.getPointAt( j * psgeRbCircSpacing / raycastLine.getLength() );
                                const tangent = raycastLine.getTangentAt( j * psgeRbCircSpacing / raycastLine.getLength() );

                                const angle = Math.atan2( tangent.y, tangent.x );

                                const rbMesh = new THREE.Mesh( connRbGeo, connRbmat );
                                rbMesh.rotation.x = Math.PI/2;

                                const blockSystem = new THREE.Object3D(); // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                                blockSystem.add( rbMesh );
                                blockSystem.position.set ( segment.x, segment.y, 0);
                                blockSystem.rotation.z = angle;
                                
                                connRbGroup.add( blockSystem );

                            }

                            // 록볼트 센터 생성
                            const segment = raycastLine.getPointAt( 0 );

                            const rbMesh = new THREE.Mesh( connRbGeo, connRbmat );
                            rbMesh.rotation.x = -Math.PI/2;
                            rbMesh.position.y = segment.y;

                            connRbGroup.add( rbMesh )

                            // 접속부 록볼트 이동
                            connRbGroup.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                            connRbGroup.applyMatrix4( matrix.makeTranslation( -0.75 + i*ui.psgeLongSpacing, 0, 0 ) );
                            connRbGroup.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                            connRbGroup.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                            connRbGroup.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );

                            // 접속부 록볼트가 3개 초과인 경우(센터포함) 생성
                            if( connRbGroup.children.length > 3 ) { showContainer.push( connRbGroup ) }

                        }


                        // 우측
                        const connRightPathPoints = []; // raycast로 경로Point 생성

                        for ( let j=0; j*divideSpacing < connRightPath.getLength(); j++ ) {
                        
                            const segment = connRightPath.getPointAt( j*divideSpacing / connRightPath.getLength() );
                            const tangent = connRightPath.getTangentAt( j*divideSpacing / connRightPath.getLength() );
                            
                            const raycast = new THREE.Raycaster();
                            raycast.set( new THREE.Vector3( segment.x, segment.y, 0 ), new THREE.Vector3( tangent.y, -tangent.x, 0 ).normalize() );
                            const intersectRight = raycast.intersectObject( scMesh )
                            
                            if( intersectRight.length != 0 ) {
                                
                                connRightPathPoints.push( new THREE.Vector3( intersectRight[0].point.x, intersectRight[0].point.y, 0 ) );

                            }
                            
                        }

                        if( connRightPathPoints.length != 0 ) {

                            const raycastLine = new THREE.Shape( connRightPathPoints ); // 경로Point => Line으로 변경

                            const connRbGroup = new THREE.Group();

                            for ( let j=1; j*psgeRbCircSpacing <= raycastLine.getLength(); j++) {

                                const segment = raycastLine.getPointAt( j * psgeRbCircSpacing / raycastLine.getLength() );
                                const tangent = raycastLine.getTangentAt( j * psgeRbCircSpacing / raycastLine.getLength() );

                                const angle = Math.atan2( -tangent.y, -tangent.x );

                                const rbMesh = new THREE.Mesh( connRbGeo, connRbmat );
                                rbMesh.rotation.x = Math.PI/2;

                                const blockSystem = new THREE.Object3D(); // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                                blockSystem.add( rbMesh );
                                blockSystem.position.set ( segment.x, segment.y, 0);
                                blockSystem.rotation.z = angle;
                                
                                connRbGroup.add( blockSystem );

                            }

                            // 접속부 록볼트 이동
                            connRbGroup.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                            connRbGroup.applyMatrix4( matrix.makeTranslation( -0.75 + i*ui.psgeLongSpacing, 0, 0 ) );
                            connRbGroup.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                            connRbGroup.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                            connRbGroup.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                            
                            // 접속부 록볼트가 2개 초과인 경우(센터 미포함) 생성
                            if( connRbGroup.children.length > 2 ) { showContainer.push( connRbGroup ) }

                        }

                    }

                }


                // 본선 강지보(Steel Rib) ////////////////////////////////////////////////////////////////////////////////////////////////////

                // 1. 환봉형상(환봉1, 환봉2), 2. 환봉 옵셋거리 ////////////////////////////////////////////////////////////////////////////////////////////////////
                if( ui.steelribType != '없음' ) {

                    let rBar1Shp, rBar2Shp
                    
                    let rBar1Dist, rBar2Dist
                    
                    if( ui.steelribType == 'LG-50' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape();
                        rBar1Shp.absarc( 0, 0, 0.030/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape();
                        rBar2Shp.absarc( 0, 0, 0.020/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.030/2;
                        rBar2Dist = 0.030 + 0.050 + 0.020/2;
                        
                    } else if ( ui.steelribType == 'LG-70' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape();
                        rBar1Shp.absarc( 0, 0, 0.030/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape();
                        rBar2Shp.absarc( 0, 0, 0.020/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.030/2;
                        rBar2Dist = 0.030 + 0.070 + 0.020/2;
                        
                    } else if ( ui.steelribType == 'LG-95' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape();
                        rBar1Shp.absarc( 0, 0, 0.032/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape();
                        rBar2Shp.absarc( 0, 0, 0.022/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.032/2;
                        rBar2Dist = 0.032 + 0.095 + 0.022/2;
                        
                    } else if ( ui.steelribType == 'H-100' ) {
                    
                        // 1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo( -0.050,  0.050 )
                            .lineTo( -0.050,  0.042 )
                            .lineTo( -0.003 , 0.042 )
                            .lineTo( -0.003, -0.042 )
                            .lineTo( -0.050, -0.042 )
                            .lineTo( -0.050, -0.050 )
                            .lineTo(  0.050, -0.050 )
                            .lineTo(  0.050, -0.042 )
                            .lineTo(  0.003, -0.042 )
                            .lineTo(  0.003,  0.042 )
                            .lineTo(  0.050,  0.042 )
                            .lineTo(  0.050,  0.050 )
                            .lineTo( -0.050,  0.050 );
                        
                        // 2. H형강 옵셋
                        rBar1Dist = 0.100/2;
                        
                    } else if ( ui.steelribType == 'H-125' ) {
                        
                        // 1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo ( -0.0625,  0.0625 )
                            .lineTo ( -0.0625,  0.0535 )
                            .lineTo ( -0.0033,  0.0535 )
                            .lineTo ( -0.0033, -0.0535 )
                            .lineTo ( -0.0625, -0.0535 )
                            .lineTo ( -0.0625, -0.0625 )
                            .lineTo (  0.0625, -0.0625 )
                            .lineTo (  0.0625, -0.0535 )
                            .lineTo (  0.0033, -0.0535 )
                            .lineTo (  0.0033,  0.0535 )
                            .lineTo (  0.0625,  0.0535 )
                            .lineTo (  0.0625,  0.0625 )
                            .lineTo ( -0.0625,  0.0625 );
                        
                        //2. H형강 옵셋
                        rBar1Dist = 0.125/2;  
                        
                    } else if ( ui.steelribType == 'H-150' ) {
                                    
                        //1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo ( -0.0750,  0.0750 )
                            .lineTo ( -0.0750,  0.0650 )
                            .lineTo ( -0.0035,  0.0650 )
                            .lineTo ( -0.0035, -0.0650 )
                            .lineTo ( -0.0750, -0.0650 )
                            .lineTo ( -0.0750, -0.0750 )
                            .lineTo (  0.0750, -0.0750 )
                            .lineTo (  0.0750, -0.0650 )
                            .lineTo (  0.0035, -0.0650 )
                            .lineTo (  0.0035,  0.0650 )
                            .lineTo (  0.0750,  0.0650 )
                            .lineTo (  0.0750,  0.0750 )
                            .lineTo ( -0.0750,  0.0750 );
                        
                        // 2. H형강 옵셋
                        rBar1Dist = 0.150/2;  
                        
                    }
                    


                    // 3. 영역별 경로 계산 ////////////////////////////////////////////////////////////////////////////////////////////////////
                    
                    // 상반부 각도계산
                    const upperHalfLeftTheta = Math.asin( ( r3Origin.y - springLineEL ) / ( r3Final + ui.shotcrete ) );
                    
                    const upperHalfLeft = new THREE.Shape()
                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete, Math.PI/2 + r1ThetaLt, Math.PI + upperHalfLeftTheta, false );

                    const upperHalfRightTheta = Math.asin( ( r5Origin.y - springLineEL ) / ( r5Final + ui.shotcrete ) );
                    
                    const upperHalfRight = new THREE.Shape()
                        .absarc(  0, r1Height, r1Final + liningT0 + ui.shotcrete, Math.PI/2, Math.PI/2 - r1ThetaRt, true )
                        .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete, Math.PI/2 - r1ThetaRt, 0 - upperHalfRightTheta, true );
                    
                    // 스프링 라인
                    const springLineShp = new THREE.Shape()
                        .moveTo( upperHalfLeft.getPoint( 1 ).x , upperHalfLeft.getPoint( 1 ).y )
                        .lineTo( 0 , springLineEL )
                        .lineTo( upperHalfRight.getPoint( 1 ).x , upperHalfRight.getPoint( 1 ).y );

                    // 환봉1 R3 중심각 계산
                    const r3Gamma3 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final + ui.shotcrete - rBar1Dist ) );
                    const r3Theta3 = Math.PI/2 - r1ThetaLt + r3Gamma3;
                    
                    // 환봉1 R5 중심각 계산
                    const r5Gamma3 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / ( r5Final + ui.shotcrete - rBar1Dist ) );
                    const r5Theta3 = Math.PI/2 - r1ThetaRt + r5Gamma3;
                    
                    // 환봉2 R3 중심각 계산
                    const r3Gamma4 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final + ui.shotcrete - rBar2Dist ) );
                    const r3Theta4 = Math.PI/2 - r1ThetaLt + r3Gamma4;
                    
                    // 환봉2 R5 중심각 계산
                    const r5Gamma4 = Math.asin( ( r5Origin.y - ( concreteRt.y - footingHeight ) ) / ( r5Final + ui.shotcrete - rBar2Dist ) );
                    const r5Theta4 = Math.PI/2 - r1ThetaRt + r5Gamma4;


                    // r1범위
                    const r1Range = new THREE.Shape()
                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                    

                    let rBar1ArchLeft, rBar1ArchRight, rBar1ShoulderLeft, rBar1ShoulderRight, rBar1BottomHalfLeft, rBar1BottomHalfRight, rBar1FullFaceLeft, rBar1FullFaceRight
                    let rBar2ArchLeft, rBar2ArchRight, rBar2ShoulderLeft, rBar2ShoulderRight, rBar2BottomHalfLeft, rBar2BottomHalfRight, rBar2FullFaceLeft, rBar2FullFaceRight


                    for ( let i=0; i*ui.longSpacing < ui.totalLength; i++) {
                        // case 2) 일반적인 본선터널 케이스

                        // a. 환봉1 영역 구분
                        // a.1 아치부
                        rBar1ArchLeft = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                        
                        rBar1ArchRight = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - r1ThetaRt, true );

                        // a.2 어깨부
                        rBar1ShoulderLeft = new THREE.Shape()
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + upperHalfLeftTheta, false );
                        
                        rBar1ShoulderRight = new THREE.Shape()
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar1Dist, Math.PI/2 - r1ThetaRt, 0 - upperHalfRightTheta, true );
                        
                        // a.3 하반부
                        rBar1BottomHalfLeft = new THREE.Shape()
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI + upperHalfLeftTheta, Math.PI/2 + r1ThetaLt + r3Theta3, false );
                        
                        rBar1BottomHalfRight = new THREE.Shape()
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar1Dist, 0 - upperHalfRightTheta, Math.PI/2 - r1ThetaRt - r5Theta3, true );
                        
                        // a.4 전단면
                        rBar1FullFaceLeft = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta3, false );

                        rBar1FullFaceRight = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - r1ThetaRt, true )
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar1Dist, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta3, true );
                        
                        
                        // b. 환봉2 영역 구분
                        // b.1 아치부
                        rBar2ArchLeft = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                        
                        rBar2ArchRight = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - r1ThetaLt, true );
                        
                        // b.2 어깨부
                        rBar2ShoulderLeft = new THREE.Shape()
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + upperHalfLeftTheta, false );
                        
                        rBar2ShoulderRight = new THREE.Shape()
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar2Dist, Math.PI/2 - r1ThetaRt, 0 - upperHalfRightTheta, true );
                        
                        // b.3 하반부
                        rBar2BottomHalfLeft = new THREE.Shape()
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI + upperHalfLeftTheta, Math.PI/2 + r1ThetaLt + r3Theta4, false );
                        
                        rBar2BottomHalfRight = new THREE.Shape()
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar2Dist, 0 - upperHalfLeftTheta, Math.PI/2 - r1ThetaRt - r5Theta4, true );
                        
                        // b.4 전단면
                        rBar2FullFaceLeft = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                            .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta4, false );

                        rBar2FullFaceRight = new THREE.Shape()
                            .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - r1ThetaRt, true )
                            .absarc( r5Origin.x, r5Origin.y, r5Final + ui.shotcrete - rBar2Dist, Math.PI/2 - r1ThetaRt, Math.PI/2 - r1ThetaRt - r5Theta4, true );


                        // 지보보강록볼트 여부
                        let supportRBValue = 0; // 지보보강록볼트 설치하지 않음

                        if ( ui.crossPsgeType == '대인용' ) {

                            // 원형
                            const holeR = pConnR1Final + pConnLiningT0 + ui.psgeShotcrete;
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = pConnR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;

                            if ( holeX - holeR <= i*ui.longSpacing && i*ui.longSpacing <= holeX + holeR ) { 

                                supportRBValue = 1; // 지보보강록볼트 설치

                                // case 1) 본선의 연결통로 접속부에 강지보를 설치해야 하는 경우

                                const deltaY = Math.sqrt( holeR*holeR - (holeX-i*ui.longSpacing)*(holeX-i*ui.longSpacing) );

                                if ( holeY + deltaY >= r1Range.getPoint(1).y ) { 

                                    // case 1-1) 연결통로 접속부 상단이 본선 R1에 있는 경우

                                    const theta = Math.acos( ( (deltaY + holeY) - r1Height ) / ( r1Final + liningT0 + ui.shotcrete - rBar1Dist ) );

                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = undefined

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = rBar1ArchLeft


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // b.2 전체
                                    rBar2FullFaceLeft = rBar2ArchLeft

                                } else {
                                    
                                    // case 1-2) 연결통로 접속부 상단이 본선 R3에 있는 경우

                                    const theta = Math.asin( ( r3Origin.y - (deltaY + holeY) ) / ( r3Final + ui.shotcrete - rBar1Dist ) );

                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                                    
                                    // b.2 어깨부
                                    rBar2ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // b.3 전체
                                    rBar2FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                }

                            }

                        } else if ( ui.crossPsgeType == '차량용' ) {

                            // 타원형
                            const aa = vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete; // 타원 장축
                            const bb = vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete; // 타원 단축
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = vPsgeR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;

                            if ( holeX - aa <= i*ui.longSpacing && i*ui.longSpacing <= holeX + aa ) {
                            
                                supportRBValue = 1; // 지보보강록볼트 설치

                                const y1 = Math.sqrt( bb*bb - ( bb*bb * Math.pow( ( i*ui.longSpacing - holeX ),2 ) / (aa*aa) ) ) + holeY; // 타원방정식

                                if ( y1 >= r1Range.getPoint(1).y ) { 
                                    
                                    // case 1-1) 연결통로 접속부 상단이 본선 R1에 있는 경우

                                    // console.log( `case 1-1 ${i}` )

                                    const theta = Math.acos( ( y1 - r1Height ) / ( r1Final + liningT0 + ui.shotcrete - rBar1Dist ) ); // 원과 다름
                        
                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = undefined

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = rBar1ArchLeft


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // b.2 전체
                                    rBar2FullFaceLeft = rBar2ArchLeft                                

                                } else { 
                                    
                                    // case 1-2) 연결통로 접속부 상단이 본선 R3에 있는 경우

                                    // console.log( `case 1-2 ${i}` )

                                    const theta = Math.asin( ( r3Origin.y - y1 ) / ( r3Final + ui.shotcrete - rBar1Dist ) );

                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                                    
                                    // b.2 어깨부
                                    rBar2ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // b.3 전체
                                    rBar2FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                }
                            }

                        } else if ( ui.crossPsgeType == '대형차량용' ) {

                            // 타원형
                            const aa = hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete; // 타원 장축
                            const bb = hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete; // 타원 단축
                            const holeX = mainTunnelLength + footingConnLength/2 + stairLength*3;
                            const holeY = hPsgeR1Origin.y + footingConnSlope[footingConnSlope.length-1].y;

                            if ( holeX - aa <= i*ui.longSpacing && i*ui.longSpacing <= holeX + aa ) {
                            
                                supportRBValue = 1; // 지보보강록볼트 설치

                                const y1 = Math.sqrt( bb*bb - ( bb*bb * Math.pow( ( i*ui.longSpacing - holeX ),2 ) / (aa*aa) ) ) + holeY; // 타원방정식

                                if ( y1 >= r1Range.getPoint(1).y ) { 
                                    
                                    // case 1-1) 연결통로 접속부 상단이 본선 R1에 있는 경우

                                    // console.log( `case 1-1 ${i}` )

                                    const theta = Math.acos( ( y1 - r1Height ) / ( r1Final + liningT0 + ui.shotcrete - rBar1Dist ) ); // 원과 다름
                        
                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = undefined

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = rBar1ArchLeft


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + theta, false );

                                    // b.2 전체
                                    rBar2FullFaceLeft = rBar2ArchLeft                                

                                } else { 
                                    
                                    // case 1-2) 연결통로 접속부 상단이 본선 R3에 있는 경우

                                    // console.log( `case 1-2 ${i}` )

                                    const theta = Math.asin( ( r3Origin.y - y1 ) / ( r3Final + ui.shotcrete - rBar1Dist ) );

                                    // a. 환봉 1 영역

                                    // a.1 아치부
                                    rBar1ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );

                                    // a.2 어깨부
                                    rBar1ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // a.3 하반부
                                    rBar1BottomHalfLeft = undefined

                                    // a.4 전체
                                    rBar1FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar1Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );


                                    // b. 환봉2 영역 구분

                                    // b.1 아치부
                                    rBar2ArchLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false );
                                    
                                    // b.2 어깨부
                                    rBar2ShoulderLeft = new THREE.Shape()
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                    // b.3 전체
                                    rBar2FullFaceLeft = new THREE.Shape()
                                        .absarc( 0, r1Height, r1Final + liningT0 + ui.shotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                                        .absarc( r3Origin.x, r3Origin.y, r3Final + ui.shotcrete - rBar2Dist, Math.PI/2 + r1ThetaLt, Math.PI + theta, false );

                                }
                            }

                        }

    
                        // 4. 환봉모델링 ////////////////////////////////////////////////////////////////////////////////////////////////////
                        // addExtru : 직선방향으로 돌출
                        // addSweep : curve에 따라 돌출
                        // 경로를 점으로 바꾸고 점을 Curve로 바꿈
                        // addArr => addPath => addSweep

                        const steelRibGroup = new THREE.Group();

                        const rBar1LfArr = addArr( rBar1FullFaceLeft );
                        const rBar1LfPath = addPath( rBar1LfArr );
                        const rBar1LfSweep = addSweep( rBar1Shp, 'steelblue', rBar1LfPath, 0.9 );

                        rBar1LfSweep.position.set( 0, 0, i * ui.longSpacing );
                        steelRibGroup.add( rBar1LfSweep );


                        const rBar1RhArr = addArr( rBar1FullFaceRight );
                        const rBar1RhPath = addPath( rBar1RhArr );
                        const rBar1RhSweep = addSweep( rBar1Shp, 'steelblue', rBar1RhPath, 0.9 );
                        
                        rBar1RhSweep.position.set( 0, 0, i * ui.longSpacing );
                        steelRibGroup.add( rBar1RhSweep );


                        // H형강은 하나만 모델링, 격자지보는 환봉1, 환봉2 x2 총 3개를 모델링함 
                        if( ui.steelribType == 'LG-50' ||  ui.steelribType == 'LG-70' || ui.steelribType == 'LG-95') {  
                        
                            const rBar2Lf1Arr = addArr( rBar2FullFaceLeft );
                            const rBar2Lf1Path = addPath( rBar2Lf1Arr );
                            const rBar2Lf1Sweep = addSweep( rBar2Shp, 'darkslateblue', rBar2Lf1Path, 0.9 );

                            const rBar2Rh1Arr = addArr( rBar2FullFaceRight );
                            const rBar2Rh1Path = addPath( rBar2Rh1Arr );
                            const rBar2Rh1Sweep = addSweep( rBar2Shp, 'darkslateblue', rBar2Rh1Path, 0.9 );

                            const rBar2Lf2Clone = rBar2Lf1Sweep.clone();
                            const rBar2Rh2Clone = rBar2Rh1Sweep.clone();

                            
                            //         o        환봉1
                            //        / \
                            //       /   \  
                            //      /_____\
                            //     o       o    환봉2 x2 .position으로 환봉의 위치

                            if( ui.steelribType == 'LG-50' ) { 

                                rBar2Lf1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.04 );
                                rBar2Lf2Clone.position.set( 0, 0, i * ui.longSpacing - 0.04 );

                                rBar2Rh1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.04 );
                                rBar2Rh2Clone.position.set( 0, 0, i * ui.longSpacing - 0.04 );
                                        

                            } else if ( ui.steelribType == 'LG-70' ) {

                                rBar2Lf1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.06 );
                                rBar2Lf2Clone.position.set( 0, 0, i * ui.longSpacing - 0.06 );

                                rBar2Rh1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.06 );
                                rBar2Rh2Clone.position.set( 0, 0, i * ui.longSpacing - 0.06 );

                            } else if ( ui.steelribType == 'LG-95' ) { 

                                rBar2Lf1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.079 );
                                rBar2Lf2Clone.position.set( 0, 0, i * ui.longSpacing - 0.079 );

                                rBar2Rh1Sweep.position.set( 0, 0, i * ui.longSpacing + 0.079 );
                                rBar2Rh2Clone.position.set( 0, 0, i * ui.longSpacing - 0.079 );

                            }

                            steelRibGroup.add( rBar2Lf1Sweep );
                            steelRibGroup.add( rBar2Lf2Clone );

                            steelRibGroup.add( rBar2Rh1Sweep );
                            steelRibGroup.add( rBar2Rh2Clone );

                        }

                        showContainer.push( steelRibGroup );


                        // 5. 부등변 앵글 좌우측배치, 6. 스파이더 좌우측배치, 7. 연결고리 좌우측배치, 8. 바닥부 모델링, 9 지보보강록볼트 ////////////////////////////
                        if( ui.steelribType == 'LG-50' ) {
                            
                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '50a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );

                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( '50a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( '50a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( '50a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( '50a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '50s.glb', rBar1ArchLeft, -1 );
                            spiderArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchLeft );

                            const spiderShoulderLeft = installSpider( '50s.glb', rBar1ShoulderLeft, -1 );
                            spiderShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderLeft );

                            const spiderBottomLeft = installSpider( '50s.glb', rBar1BottomHalfLeft, -1 );
                            spiderBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomLeft );    
                            
                            const spiderArchRight = installSpider( '50s.glb', rBar1ArchRight, 1 );
                            spiderArchRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchRight );

                            const spiderShoulderRight = installSpider( '50s.glb', rBar1ShoulderRight, 1 );
                            spiderShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderRight );                   

                            const spiderBottomRight = installSpider( '50s.glb', rBar1BottomHalfRight, 1 );
                            spiderBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '50c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '50c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );
                            

                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.150, 0.050, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.150, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                            } else {

                                const plateRight = installPlate( 0.150, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.030/2+0.050+0.020 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }
                            
                        } else if ( ui.steelribType == 'LG-70' ) {
                            
                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '70a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( '70a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( '70a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( '70a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( '70a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '70s.glb', rBar1ArchLeft, -1 );
                            spiderArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchLeft );

                            const spiderShoulderLeft = installSpider( '70s.glb', rBar1ShoulderLeft, -1 );
                            spiderShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderLeft );

                            const spiderBottomLeft = installSpider( '70s.glb', rBar1BottomHalfLeft, -1 );
                            spiderBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomLeft );    
                            
                            const spiderArchRight = installSpider( '70s.glb', rBar1ArchRight, 1 );
                            spiderArchRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchRight );

                            const spiderShoulderRight = installSpider( '70s.glb', rBar1ShoulderRight, 1 );
                            spiderShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderRight );                   

                            const spiderBottomRight = installSpider( '70s.glb', rBar1BottomHalfRight, 1 );
                            spiderBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '70c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '70c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );
                            
                            
                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.170, 0.050, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.170, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                            } else {

                                const plateRight = installPlate( 0.170, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.030/2 + 0.070 + 0.020 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }

                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('chocolate');
                            rBar1RhSweep.material.color.set('chocolate');
                            
                        } else if ( ui.steelribType == 'LG-95' ) {
                            
                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '95a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( '95a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( '95a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( '95a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( '95a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '95s.glb', rBar1ArchLeft, -1 );
                            spiderArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchLeft );

                            const spiderShoulderLeft = installSpider( '95s.glb', rBar1ShoulderLeft, -1 );
                            spiderShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderLeft );

                            const spiderBottomLeft = installSpider( '95s.glb', rBar1BottomHalfLeft, -1 );
                            spiderBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomLeft );    
                            
                            const spiderArchRight = installSpider( '95s.glb', rBar1ArchRight, 1 );
                            spiderArchRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderArchRight );

                            const spiderShoulderRight = installSpider( '95s.glb', rBar1ShoulderRight, 1 );
                            spiderShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderShoulderRight );                   

                            const spiderBottomRight = installSpider( '95s.glb', rBar1BottomHalfRight, 1 );
                            spiderBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '95c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '95c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );


                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.210, 0.050, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.210, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                            } else {

                                const plateRight = installPlate( 0.210, -0.050, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.032/2 + 0.095 + 0.022 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }

                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('darkslateblue');
                            rBar1RhSweep.material.color.set('darkslateblue');
                            
                        } else if ( ui.steelribType == 'H-100' ) {
                            
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H100a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( 'H100a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( 'H100a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( 'H100a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( 'H100a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );
                            
                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H100c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H100c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );


                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.150, 0.000, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.150, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                            } else {

                                const plateRight = installPlate( 0.150, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.100/2 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }

                            
                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('darkcyan');
                            rBar1RhSweep.material.color.set('darkcyan');
                            
                        } else if ( ui.steelribType == 'H-125' ) {
                            
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H125a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( 'H125a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( 'H125a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( 'H125a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( 'H125a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H125c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H125c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );
                            

                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.175, 0.000, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.175, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                            } else {

                                const plateRight = installPlate( 0.175, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.125/2 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }
                            
                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set(0x82caaf);
                            rBar1RhSweep.material.color.set(0x82caaf);
                            
                        } else if ( ui.steelribType == 'H-150' ) {
                        
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H150a.glb', rBar1ArchLeft, -1 );
                            angleArchLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleArchLeft );

                            const angleShoulderLeft = installAngle( 'H150a.glb', rBar1ShoulderLeft, -1 );
                            angleShoulderLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderLeft );

                            const angleBottomLeft = installAngle( 'H150a.glb', rBar1BottomHalfLeft, -1 );
                            angleBottomLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomLeft );

                            const angleShoulderRight = installAngle( 'H150a.glb', rBar1ShoulderRight, 1 );
                            angleShoulderRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleShoulderRight );

                            const angleBottomRight = installAngle( 'H150a.glb', rBar1BottomHalfRight, 1 );
                            angleBottomRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H150c.glb', rBar1FullFaceLeft, -1 );
                            couplerLeft.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H150c.glb', rBar1FullFaceRight, 1 );
                            couplerRight.position.set( 0, 0, i*ui.longSpacing );
                            showContainer.push( couplerRight );
                            

                            if ( supportRBValue == 0 ) { 

                                // 8. 바닥부 모델링
                                const plateLeft = installPlate( 0.175, 0.000, rBar1FullFaceLeft );
                                plateLeft.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateLeft );

                                const plateRight = installPlate( 0.175, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );
                            
                            } else {

                                const plateRight = installPlate( 0.175, 0.000, rBar1FullFaceRight );
                                plateRight.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( plateRight );

                                // 9. 지보보강록볼트
                                const reinforceRB = installReinForceRB( rBar1FullFaceLeft, -1, 0.150/2 );
                                reinforceRB.position.set( 0, 0, i*ui.longSpacing );
                                showContainer.push( reinforceRB );
                                
                            }


                        } 

                    }

                }


                // 연결통로 강지보공(passage SteelRib) ////////////////////////////////////////////////////////////////////////////////////////////////////

                // 1. 환봉형상(환봉1, 환봉2), 2. 환봉 옵셋거리 ////////////////////////////////////////////////////////////////////////////////////////////////////
                if( ui.psgeSteelribType != '없음' ) {

                    let rBar1Shp, rBar2Shp
                        
                    let rBar1Dist, rBar2Dist
                        
                    if( ui.psgeSteelribType == 'LG-50' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.030/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.020/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.030/2;
                        rBar2Dist = 0.030 + 0.050 + 0.020/2;
                        
                    } else if ( ui.psgeSteelribType == 'LG-70' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.030/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.020/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.030/2;
                        rBar2Dist = 0.030 + 0.070 + 0.020/2;
                        
                    } else if ( ui.psgeSteelribType == 'LG-95' ) {
                        
                        // 1. 환봉형상
                        rBar1Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.032/2, 0, Math.PI * 2, false );
                        
                        rBar2Shp = new THREE.Shape()
                            .absarc( 0, 0, 0.022/2, 0, Math.PI * 2, false );
                        
                        // 2. 환봉옵셋
                        rBar1Dist = 0.032/2;
                        rBar2Dist = 0.032 + 0.095 + 0.022/2;
                        
                    } else if ( ui.psgeSteelribType == 'H-100' ) {
                    
                        // 1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo( -0.050,  0.050 )
                            .lineTo( -0.050,  0.042 )
                            .lineTo( -0.003 , 0.042 )
                            .lineTo( -0.003, -0.042 )
                            .lineTo( -0.050, -0.042 )
                            .lineTo( -0.050, -0.050 )
                            .lineTo(  0.050, -0.050 )
                            .lineTo(  0.050, -0.042 )
                            .lineTo(  0.003, -0.042 )
                            .lineTo(  0.003,  0.042 )
                            .lineTo(  0.050,  0.042 )
                            .lineTo(  0.050,  0.050 )
                            .lineTo( -0.050,  0.050 );
                        
                        // 2. H형강 옵셋
                        rBar1Dist = 0.100/2;
                        
                    } else if ( ui.psgeSteelribType == 'H-125' ) {
                        
                        // 1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo ( -0.0625,  0.0625 )
                            .lineTo ( -0.0625,  0.0535 )
                            .lineTo ( -0.0033,  0.0535 )
                            .lineTo ( -0.0033, -0.0535 )
                            .lineTo ( -0.0625, -0.0535 )
                            .lineTo ( -0.0625, -0.0625 )
                            .lineTo (  0.0625, -0.0625 )
                            .lineTo (  0.0625, -0.0535 )
                            .lineTo (  0.0033, -0.0535 )
                            .lineTo (  0.0033,  0.0535 )
                            .lineTo (  0.0625,  0.0535 )
                            .lineTo (  0.0625,  0.0625 )
                            .lineTo ( -0.0625,  0.0625 );
                        
                        //2. H형강 옵셋
                        rBar1Dist = 0.125/2;  
                        
                    } else if ( ui.psgeSteelribType == 'H-150' ) {
                                    
                        //1. H형강 형상
                        rBar1Shp = new THREE.Shape()
                            .moveTo ( -0.0750,  0.0750 )
                            .lineTo ( -0.0750,  0.0650 )
                            .lineTo ( -0.0035,  0.0650 )
                            .lineTo ( -0.0035, -0.0650 )
                            .lineTo ( -0.0750, -0.0650 )
                            .lineTo ( -0.0750, -0.0750 )
                            .lineTo (  0.0750, -0.0750 )
                            .lineTo (  0.0750, -0.0650 )
                            .lineTo (  0.0035, -0.0650 )
                            .lineTo (  0.0035,  0.0650 )
                            .lineTo (  0.0750,  0.0650 )
                            .lineTo (  0.0750,  0.0750 )
                            .lineTo ( -0.0750,  0.0750 );
                        
                        // 2. H형강 옵셋
                        rBar1Dist = 0.150/2;  
                        
                    }

                    // 3. 연결통로 강지보공 생성 경로 ////////////////////////////////////////////////////////////////////////////////////////////////////
                    let psgeBar1ArchLeftShp, psgeBar1BottomLeftShp, psgeBar1ArchRightShp, psgeBar1BottomRightShp, psgeBar1FullLeftShp, psgeBar1FullRightShp
                    let psgeBar2ArchLeftShp, psgeBar2BottomLeftShp, psgeBar2ArchRightShp, psgeBar2BottomRightShp, psgeBar2FullLeftShp, psgeBar2FullRightShp

                    switch ( ui.crossPsgeType ) {

                        case ('대인용') : {

                            // 환봉1 경로 계산
                            psgeBar1ArchLeftShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false );

                            psgeBar1BottomLeftShp = new THREE.Shape()
                                .moveTo( psgeBar1ArchLeftShp.getPoint(1).x, psgeBar1ArchLeftShp.getPoint(1).y )
                                .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete + rBar1Dist, pPsgeFootingLeftPt.y - pPsgePavement );

                            psgeBar1FullLeftShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false )
                                .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete + rBar1Dist, pPsgeFootingLeftPt.y - pPsgePavement );

                            psgeBar1ArchRightShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true );

                            psgeBar1BottomRightShp = new THREE.Shape()
                                .moveTo( psgeBar1ArchRightShp.getPoint(1).x, psgeBar1ArchRightShp.getPoint(1).y )
                                .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, pPsgeFootingRightPt.y - pPsgePavement );

                            psgeBar1FullRightShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true )
                                .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, pPsgeFootingRightPt.y - pPsgePavement );

                            // 환봉2 경로 계산
                            psgeBar2ArchLeftShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false );

                            psgeBar2BottomLeftShp = new THREE.Shape()
                                .moveTo( psgeBar2ArchLeftShp.getPoint(1).x, psgeBar2ArchLeftShp.getPoint(1).y )
                                .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete + rBar2Dist, pPsgeFootingLeftPt.y - pPsgePavement );

                            psgeBar2FullLeftShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false )
                                .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 - ui.psgeShotcrete + rBar2Dist, pPsgeFootingLeftPt.y - pPsgePavement );

                            psgeBar2ArchRightShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true );

                            psgeBar2BottomRightShp = new THREE.Shape()
                                .moveTo( psgeBar2ArchRightShp.getPoint(1).x, psgeBar2ArchRightShp.getPoint(1).y )
                                .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, pPsgeFootingRightPt.y - pPsgePavement );

                            psgeBar2FullRightShp = new THREE.Shape()
                                .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true )
                                .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, pPsgeFootingRightPt.y - pPsgePavement );

                            break;

                        }

                        case ('차량용') : {

                            // 환봉1 중심각 계산
                            const vPsgeR3Gamma3 = Math.asin( ( vPsgeR3Origin.y + vPsgePavement ) / ( vPsgeR3Final + ui.psgeShotcrete - rBar1Dist ) );
                            const vPsgeR3Theta3 = Math.PI/2 - vPsgeR1Theta + vPsgeR3Gamma3;
                            const vPsgeR5Gamma3 = Math.asin( ( vPsgeR5Origin.y + vPsgePavement ) / ( vPsgeR5Final + ui.psgeShotcrete - rBar1Dist ) );
                            const vPsgeR5Theta3 = Math.PI/2 - vPsgeR1Theta + vPsgeR5Gamma3;
                            
                            // 환봉2 중심각 계산
                            const vPsgeR3Gamma4 = Math.asin( ( vPsgeR3Origin.y + vPsgePavement ) / ( vPsgeR3Final + ui.psgeShotcrete - rBar2Dist ) );
                            const vPsgeR3Theta4 = Math.PI/2 - vPsgeR1Theta + vPsgeR3Gamma4;
                            const vPsgeR5Gamma4 = Math.asin( ( vPsgeR5Origin.y + vPsgePavement ) / ( vPsgeR5Final + ui.psgeShotcrete - rBar2Dist ) );
                            const vPsgeR5Theta4 = Math.PI/2 - vPsgeR1Theta + vPsgeR5Gamma4;  

                            // 환봉1 경로 계산
                            psgeBar1ArchLeftShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false );

                            psgeBar1BottomLeftShp = new THREE.Shape()
                                .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete - rBar1Dist,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta3, false );

                            psgeBar1FullLeftShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false )
                                .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete - rBar1Dist,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta3, false );

                            psgeBar1ArchRightShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true );

                            psgeBar1BottomRightShp = new THREE.Shape()
                                .absarc( -vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR5Final + ui.psgeShotcrete - rBar1Dist, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR3Theta3, true );

                            psgeBar1FullRightShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true )
                                .absarc( -vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR5Final + ui.psgeShotcrete - rBar1Dist, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR3Theta3, true );

                            // 환봉2 경로 계산
                            psgeBar2ArchLeftShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false );

                            psgeBar2BottomLeftShp = new THREE.Shape()
                                .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete - rBar2Dist,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta4, false );

                            psgeBar2FullLeftShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false )
                                .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final + ui.psgeShotcrete - rBar2Dist,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta4, false );

                            psgeBar2ArchRightShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true );

                            psgeBar2BottomRightShp = new THREE.Shape()
                                .absarc( -vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR5Final + ui.psgeShotcrete - rBar2Dist, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR3Theta4, true );

                            psgeBar2FullRightShp = new THREE.Shape()
                                .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true )
                                .absarc( -vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR5Final + ui.psgeShotcrete - rBar2Dist, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR3Theta4, true );

                            break;

                        }

                        case ('대형차량용') : {

                            // 환봉1 중심각 계산
                            const hPsgeR3Gamma3 = Math.asin( ( hPsgeR3Origin.y + hPsgePavement ) / ( hPsgeR3Final + ui.psgeShotcrete - rBar1Dist ) );
                            const hPsgeR3Theta3 = Math.PI/2 - hPsgeR1Theta + hPsgeR3Gamma3;

                            // 환봉2 중심각 계산
                            const hPsgeR3Gamma4 = Math.asin( ( hPsgeR3Origin.y + hPsgePavement ) / ( hPsgeR3Final + ui.psgeShotcrete - rBar2Dist ) );
                            const hPsgeR3Theta4 = Math.PI/2 - hPsgeR1Theta + hPsgeR3Gamma4;

                            // 환봉1 경로 계산
                            psgeBar1ArchLeftShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false );

                            psgeBar1BottomLeftShp = new THREE.Shape()
                                .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar1Dist,  Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta3, false );

                            psgeBar1FullLeftShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false )
                                .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar1Dist,  Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta3, false );

                            psgeBar1ArchRightShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true );

                            psgeBar1BottomRightShp = new THREE.Shape()
                                .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar1Dist, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta3, true );

                            psgeBar1FullRightShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar1Dist, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true )
                                .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar1Dist, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta3, true );

                            // 환봉2 경로 계산
                            psgeBar2ArchLeftShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false );

                            psgeBar2BottomLeftShp = new THREE.Shape()
                                .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar2Dist,  Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta4, false );

                            psgeBar2FullLeftShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false )
                                .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar2Dist,  Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta4, false );

                            psgeBar2ArchRightShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true );

                            psgeBar2BottomRightShp = new THREE.Shape()
                                .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar2Dist, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta4, true );
                            
                            psgeBar2FullRightShp = new THREE.Shape()
                                .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 + ui.psgeShotcrete - rBar2Dist, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true )
                                .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final + ui.psgeShotcrete - rBar2Dist, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta4, true );

                            break;

                        }

                    }

                    // 4. 환봉모델링 ////////////////////////////////////////////////////////////////////////////////////////////////////
                    // addExtru : 직선방향으로 돌출
                    // addSweep : curve에 따라 돌출
                    // 경로를 점으로 바꾸고 점을 Curve로 바꿈
                    // addArr => addPath => addSweep

                    const psgeSteelRibGroup = new THREE.Group();

                    const rBar1LfArr = addArr( psgeBar1FullLeftShp );
                    const rBar1LfPath = addPath( rBar1LfArr );
                    const rBar1LfSweep = addSweep( rBar1Shp, 'steelblue', rBar1LfPath, 0.9 );
                    psgeSteelRibGroup.add( rBar1LfSweep );

                    const rBar1RhArr = addArr( psgeBar1FullRightShp );
                    const rBar1RhPath = addPath( rBar1RhArr );
                    const rBar1RhSweep = addSweep( rBar1Shp, 'steelblue', rBar1RhPath, 0.9 );
                    psgeSteelRibGroup.add( rBar1RhSweep );

                    // H형강은 하나만 모델링, 격자지보는 환봉1, 환봉2 x2 총 3개를 모델링함 
                    if( ui.psgeSteelribType == 'LG-50' ||  ui.psgeSteelribType == 'LG-70' || ui.psgeSteelribType == 'LG-95') {  
                        
                        const rBar2Lf1Arr = addArr( psgeBar2FullLeftShp );
                        const rBar2Lf1Path = addPath( rBar2Lf1Arr );
                        const rBar2Lf1Sweep = addSweep( rBar2Shp, 'darkslateblue', rBar2Lf1Path, 0.9 );

                        const rBar2Rh1Arr = addArr( psgeBar2FullRightShp );
                        const rBar2Rh1Path = addPath( rBar2Rh1Arr );
                        const rBar2Rh1Sweep = addSweep( rBar2Shp, 'darkslateblue', rBar2Rh1Path, 0.9 );

                        const rBar2Lf2Clone = rBar2Lf1Sweep.clone();
                        const rBar2Rh2Clone = rBar2Rh1Sweep.clone();
                        
                        //         o        환봉1
                        //        / \
                        //       /   \  
                        //      /_____\
                        //     o       o    환봉2 x2 .position으로 환봉의 위치

                        if( ui.psgeSteelribType == 'LG-50' ) { 

                            rBar2Lf1Sweep.position.set( 0, 0, +0.04 );
                            rBar2Lf2Clone.position.set( 0, 0, -0.04 );

                            rBar2Rh1Sweep.position.set( 0, 0, +0.04 );
                            rBar2Rh2Clone.position.set( 0, 0, -0.04 );
                                    

                        } else if ( ui.psgeSteelribType == 'LG-70' ) {

                            rBar2Lf1Sweep.position.set( 0, 0, +0.06 );
                            rBar2Lf2Clone.position.set( 0, 0, -0.06 );

                            rBar2Rh1Sweep.position.set( 0, 0, +0.06 );
                            rBar2Rh2Clone.position.set( 0, 0, -0.06 );

                        } else if ( ui.psgeSteelribType == 'LG-95' ) { 

                            rBar2Lf1Sweep.position.set( 0, 0, +0.079 );
                            rBar2Lf2Clone.position.set( 0, 0, -0.079 );

                            rBar2Rh1Sweep.position.set( 0, 0, +0.079 );
                            rBar2Rh2Clone.position.set( 0, 0, -0.079 );

                        }

                        psgeSteelRibGroup.add( rBar2Lf1Sweep );
                        psgeSteelRibGroup.add( rBar2Lf2Clone );

                        psgeSteelRibGroup.add( rBar2Rh1Sweep );
                        psgeSteelRibGroup.add( rBar2Rh2Clone );

                    }

                    // 연결통로 강지보 배치
                    for ( let i=0; i*ui.psgeLongSpacing <= netReinforceL ; i++) {

                        const psgeSteelRibGroupClone = psgeSteelRibGroup.clone();
                        psgeSteelRibGroupClone.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                        psgeSteelRibGroupClone.applyMatrix4( matrix.makeTranslation( -1.5 -i*ui.psgeLongSpacing, 0, 0 ) );
                        psgeSteelRibGroupClone.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                        psgeSteelRibGroupClone.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                        psgeSteelRibGroupClone.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                        showContainer.push( psgeSteelRibGroupClone )

                    }


                    function psgePositionMultiSet( mesh, num ) {
                        mesh.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                        mesh.applyMatrix4( matrix.makeTranslation( -1.5 -num*ui.psgeLongSpacing, 0, 0 ) );
                        mesh.applyMatrix4( matrix.makeRotationZ( verticalAngle ) );
                        mesh.applyMatrix4( matrix.makeRotationY( horizontalAngle ) );
                        mesh.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                        return mesh
                    }

                    for ( let i=0; i*ui.psgeLongSpacing <= netReinforceL ; i++) {

                        // 5. 부등변 앵글 좌우측배치, 6. 스파이더 좌우측배치, 7. 연결고리 좌우측배치, 8. 바닥부 모델링 /////////////////////////////
                        if( ui.psgeSteelribType == 'LG-50' ) {

                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '50a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( '50a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( '50a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '50s.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( spiderArchLeft, i );
                            showContainer.push( spiderArchLeft );

                            const spiderBottomLeft = installSpider( '50s.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( spiderBottomLeft, i );
                            showContainer.push( spiderBottomLeft );    
                            
                            const spiderArchRight = installSpider( '50s.glb', psgeBar1ArchRightShp, 1 );
                            psgePositionMultiSet( spiderArchRight, i );
                            showContainer.push( spiderArchRight );                  

                            const spiderBottomRight = installSpider( '50s.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( spiderBottomRight, i );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '50c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '50c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );
                            
                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.150, 0.050, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.150, -0.050, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );
                            
                        } else if ( ui.psgeSteelribType == 'LG-70' ) {
                            
                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '70a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( '70a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( '70a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '70s.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( spiderArchLeft, i );
                            showContainer.push( spiderArchLeft );

                            const spiderBottomLeft = installSpider( '70s.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( spiderBottomLeft, i );
                            showContainer.push( spiderBottomLeft );

                            const spiderArchRight = installSpider( '70s.glb', psgeBar1ArchRightShp, 1 );
                            psgePositionMultiSet( spiderArchRight, i );
                            showContainer.push( spiderArchRight );                  

                            const spiderBottomRight = installSpider( '70s.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( spiderBottomRight, i );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '70c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '70c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );
                            
                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.170, 0.050, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.170, -0.050, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );
                            
                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('chocolate')
                            rBar1RhSweep.material.color.set('chocolate')                
                            
                        } else if ( ui.psgeSteelribType == 'LG-95' ) {
                            
                            // 5. 부등변 앵글 배치
                            const angleArchLeft = installAngle( '95a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( '95a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( '95a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 배치
                            const spiderArchLeft = installSpider( '95s.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( spiderArchLeft, i );
                            showContainer.push( spiderArchLeft );

                            const spiderBottomLeft = installSpider( '95s.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( spiderBottomLeft, i );
                            showContainer.push( spiderBottomLeft );

                            const spiderArchRight = installSpider( '95s.glb', psgeBar1ArchRightShp, 1 );
                            psgePositionMultiSet( spiderArchRight, i );
                            showContainer.push( spiderArchRight );                  

                            const spiderBottomRight = installSpider( '95s.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( spiderBottomRight, i );
                            showContainer.push( spiderBottomRight );   

                            // 7. 연결고리 배치
                            const couplerLeft = installCoupler ( '95c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( '95c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );

                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.210, 0.050, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.210, -0.050, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );

                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('darkslateblue')
                            rBar1RhSweep.material.color.set('darkslateblue')   
                            
                        } else if ( ui.psgeSteelribType == 'H-100' ) {
                            
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H100a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( 'H100a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( 'H100a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );
                            
                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H100c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H100c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );

                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.150, 0.000, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.150, 0.000, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );
                            
                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set('darkcyan')
                            rBar1RhSweep.material.color.set('darkcyan')                
                            
                        } else if ( ui.psgeSteelribType == 'H-125' ) {
                            
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H125a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( 'H125a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( 'H125a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H125c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H125c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );
                            
                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.175, 0.000, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.175, 0.000, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );
                            
                            // 환봉1 색상변경
                            rBar1LfSweep.material.color.set(0x82caaf)
                            rBar1RhSweep.material.color.set(0x82caaf)                  
                            
                        } else if ( ui.psgeSteelribType == 'H-150' ) {
                        
                            // 5. 부등변 앵글 좌우측배치
                            const angleArchLeft = installAngle( 'H150a.glb', psgeBar1ArchLeftShp, -1 );
                            psgePositionMultiSet( angleArchLeft, i );
                            showContainer.push( angleArchLeft );

                            const angleBottomLeft = installAngle( 'H150a.glb', psgeBar1BottomLeftShp, -1 );
                            psgePositionMultiSet( angleBottomLeft, i );
                            showContainer.push( angleBottomLeft );

                            const angleBottomRight = installAngle( 'H150a.glb', psgeBar1BottomRightShp, 1 );
                            psgePositionMultiSet( angleBottomRight, i );
                            showContainer.push( angleBottomRight );

                            // 6. 스파이더 좌우측배치
                            // 없음

                            // 7. 연결고리 좌우측배치
                            const couplerLeft = installCoupler ( 'H150c.glb', psgeBar1FullLeftShp, -1 );
                            psgePositionMultiSet( couplerLeft, i );
                            showContainer.push( couplerLeft );

                            const couplerRight = installCoupler ( 'H150c.glb', psgeBar1FullRightShp, 1 );
                            psgePositionMultiSet( couplerRight, i );
                            showContainer.push( couplerRight );
                            
                            // 8. 바닥부 모델링
                            const plateLeft = installPlate( 0.175, 0.000, psgeBar1FullLeftShp );
                            psgePositionMultiSet( plateLeft, i );
                            showContainer.push( plateLeft );

                            const plateRight = installPlate( 0.175, 0.000, psgeBar1FullRightShp );
                            psgePositionMultiSet( plateRight, i );
                            showContainer.push( plateRight );
                        
                        } 

                    }

                }

            }




            /****************************************************************************************************
             * 구조도 contents
             *
             * <본선>
             * 1. 주철근 형상
             * 2. 주철근 경로생성
             * 
             * 
             * <연결통로 주철근>
             * 1. 연결통로 주철근 형상
             * 2. 연결통로 주철근 경로생성
             * 3. 접속부 헌치 주철근 포인트 위치이동( Shp > Pts > Move & Rotate )
             * 4. 접속부 헌치 철근위치 Ray 원본
             * 5. 접속부 헌치 주철근 위치 메쉬 생성
             * 6. 접속부 헌치 보다 약간 큰 가상의 경로 생성
             * 7. 접속부 헌치 주철근 모델링
             * 8. 연결통로 주철근 모델링
             *
             * <연결통로 배력철근>
             * 1. 연결통로 배력철근 경로생성
             * 2. 접속부 헌치 배력철근 외측 convex
             * 3. 접속부 헌치 배력철근 외측 모델링
             *      3.1 배력철근 위치 결정
             *      3.2 배력철근 포인트 위치이동
             *      3.3 접속부 철근 위치 ray 원본( 본선 라이닝 내측까지 )
             *      3.4 접속부 철근 위치 ray 보정( 본선 배력철근 내측까지 )
             *      3.5 정착길이 ray 원본( 본선 배력철근 내측까지 )
             *      3.6 정착길이 ray 보정( MultiplyScalar )
             *      3.7 접속부 헌치 구간 1/3, 2/3점 생성
             *      3.8 접속부 헌치 구간 1/3, 2/3점 ray( 접속부 헌치 배력철근 외측 convex까지 )
             *      3.9 연결통로-접속부 헌치 배력철근 모델링
             * 4. 접속부 헌치 배력철근 내측 convex
             * 5. 접속부 헌치 배력철근 내측 모델링
             *      ( 접속부 헌치 배력철근 외측과 거의 비슷함 )
             ****************************************************************************************************/
            

            if ( ui.category =='구조도') {


                // <본선 구조도> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                // 1. 본선 주철근(Main Rebar)
                // 1.1 본선 주철근 형상
                const main1Shp = new THREE.Shape()
                    .absarc( 0, 0, ui.mainCompDia/2, 0, Math.PI * 2, false );
                
                const main2Shp = new THREE.Shape()
                    .absarc( 0, 0, ui.mainTensDia/2, 0, Math.PI * 2, false );
                

                // 1.2 본선 주철근 최대 직경 결정
                const mainMaxDia = Math.max( ui.mainCompDia, ui.mainTensDia );


                // 2. 본선 주철근 경로 생성   
                // 2.1 외측 경로
                const r3Gamma5 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final - ui.coverDepth ) );
                const r3Theta5 = Math.PI/2 - r1ThetaLt + r3Gamma5;
                
                const mainOutLtPath = new THREE.Shape()
                    .absarc( 0, r1Height, r1Final + liningT0 - ui.coverDepth, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                    .absarc( r3Origin.x, r3Origin.y, r3Final - ui.coverDepth, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta5, false );

                const mainOutLtExtr = addExtr( mainOutLtPath, 'darkblue', ui.totalLength, 0.9 );
                // showContainer.push( mainOutLtExtr )
                

                // 2.2 내측 경로
                // 배력철근 중심선
                const distrCtrLine = ui.coverDepth + mainMaxDia/2 + ui.distrDia/2

                // r2각도 재계산
                const r2Theta2 = Math.asin( ( r2Origin.y - footingLtSlope[footingLtSlope.length-1].y ) / ( r2Final + distrCtrLine ) ) + Math.PI/2 - r1ThetaLt;

                const distrInLtShp = new THREE.Shape()
                    .absarc( 0, r1Height, r1Final + distrCtrLine, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                    .absarc( r2Origin.x, r2Origin.y, r2Final + distrCtrLine, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r2Theta2, false )
                    .lineTo( footingConnSlope[footingConnSlope.length-1].x - distrCtrLine, footingConnSlope[footingConnSlope.length-1].y )
                    .lineTo( footingConnSlope[footingConnSlope.length-1].x - distrCtrLine, footingConnSlope[0].y - footingHeight )

                const distrInLtExtr = addExtr( distrInLtShp, 'pink', ui.totalLength, 0.5 );
                // showContainer.push( distrInLtExtr );

                const r3Gamma3 = Math.asin( ( r3Origin.y - ( concreteLt.y - footingHeight ) ) / ( r3Final - distrCtrLine ) );
                const r3Theta3 = Math.PI/2 - r1ThetaLt + r3Gamma2;
                
                const distrOutLtShp = new THREE.Shape()
                    .absarc( 0, r1Height, r1Final + liningT0 - distrCtrLine, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                    .absarc( r3Origin.x, r3Origin.y, r3Final - distrCtrLine, Math.PI/2 + r1ThetaLt, Math.PI/2 + r1ThetaLt + r3Theta3, false );

                const distrOutLtExtr = addExtr( distrOutLtShp, 'gold', ui.totalLength, 1 );
                // showContainer.push( distrOutLtExtr );





                // <연결통로 구조도> ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                // 시공이음
                const psgeJointH1 = 0.150; // 공동구 끝단에서 높이

                // 정착길이
                const psgeAnchorRebarL = 1.000;

                // 연결통로 위치 이동
                function psgePositionSet ( mesh ) {
                    mesh.applyMatrix4( matrix.makeRotationY( Math.PI*3/2 ) );
                    mesh.applyMatrix4( matrix.makeTranslation( -1.5, 0, 0 ) );
                    mesh.applyMatrix4( matrix.makeRotationZ( THREE.Math.degToRad( ui.verticalAngle ) ) );
                    mesh.applyMatrix4( matrix.makeRotationY( THREE.Math.degToRad( ui.horizontalAngle ) ) );
                    mesh.applyMatrix4( matrix.makeTranslation( -r2Final + r2Origin.x, footingConnSlope[footingConnSlope.length-1].y, mainTunnelLength + footingConnLength/2 + stairLength*3 ) );
                    return mesh
                }

                // 1. 연결통로 주철근
                // 1.1 연결통로 주철근 형상
                const psgeMain1Shp = new THREE.Shape()
                    .absarc( 0, 0, ui.psgeMainCompDia/2, 0, Math.PI * 2, false );
                
                const psgeMain2Shp = new THREE.Shape()
                    .absarc( 0, 0, ui.psgeMainTensDia/2, 0, Math.PI * 2, false );
                
                // 1.2 연결통로 주철근 최대 직경 결정
                const psgeMainMaxDia = Math.max( ui.psgeMainCompDia, ui.psgeMainTensDia );


                // 2. 연결통로 주철근 경로생성
                let psgeMainOutShp, connMainOutShp, psgeMainInShp, connMainInShp

                switch ( ui.crossPsgeType ) {

                    case ('대인용') : {
                        
                        // 연결통로 외측
                        psgeMainOutShp = new THREE.Shape()
                            .moveTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 + ui.psgeCoverDepth, pPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 + ui.psgeCoverDepth, pPsgeR1Origin.y )
                            .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 - ui.psgeCoverDepth, pPsgeFootingRightPt.y + psgeJointH1 );
                            
                        // 접속부 헌치 외측
                        connMainOutShp = new THREE.Shape()
                            .moveTo( -pConnR1Final - pConnLiningT0 + ui.psgeCoverDepth, pPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( -pConnR1Final - pConnLiningT0 + ui.psgeCoverDepth, pConnR1Origin.y )
                            .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( pConnR1Final + pConnLiningT0 - ui.psgeCoverDepth, pPsgeFootingRightPt.y + psgeJointH1 );

                        // 연결통로 내측
                        psgeMainInShp = new THREE.Shape()
                            .moveTo( pPsgeFootingLeftPt.x - ui.psgeCoverDepth, pPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( pPsgeFootingLeftPt.x - ui.psgeCoverDepth, pPsgeR1Origin.y )
                            .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( pPsgeFootingRightPt.x + ui.psgeCoverDepth, pPsgeFootingRightPt.y + psgeJointH1 );                        

                        // 접속부 헌치 내측
                        connMainInShp = new THREE.Shape()
                            .moveTo( -pConnR1Final - ui.psgeCoverDepth, pPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( -pConnR1Final - ui.psgeCoverDepth, pConnR1Origin.y )
                            .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( pConnR1Final + ui.psgeCoverDepth, pPsgeFootingRightPt.y + psgeJointH1 );

                        break;

                    }

                    case ('차량용') : {
                        
                        // 연결통로 외측
                        const vPsgeR3Gamma5 = Math.asin( ( vPsgeR3Origin.y - psgeJointH1 ) / ( vPsgeR3Final - ui.psgeCoverDepth ) );
                        const vPsgeR3Theta5 = Math.PI/2 - vPsgeR1Theta + vPsgeR3Gamma5;
                        
                        psgeMainOutShp = new THREE.Shape()
                            .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final - ui.psgeCoverDepth, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta5, Math.PI/2 + vPsgeR1Theta, true )
                            .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR5Final - ui.psgeCoverDepth, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR3Theta5, true );

                        // 접속부 헌치 외측
                        const vConnR3Theta5 =  Math.asin( ( vConnR3Origin.y - psgeJointH1 ) / ( vConnR3Final - ui.psgeCoverDepth ) );

                        connMainOutShp = new THREE.Shape()
                            .absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - ui.psgeCoverDepth, Math.PI/2 + vPsgeR1Theta + vConnR3Theta5, Math.PI/2 + vPsgeR1Theta, true )
                            .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 - ui.psgeCoverDepth, vPsgeR1Final + vConnLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - ui.psgeCoverDepth, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vConnR3Theta5, true );

                        // 연결통로 내측
                        const vPsgeR2Theta33 = Math.asin( ( vPsgeR2Origin.y - psgeJointH1 ) / ( vPsgeR2Final + ui.psgeCoverDepth ) );
                        const vPsgeR4Theta33 = Math.asin( ( vPsgeR4Origin.y - psgeJointH1 ) / ( vPsgeR4Final + ui.psgeCoverDepth ) );

                        psgeMainInShp = new THREE.Shape()
                            .absarc( vPsgeR2Origin.x, vPsgeR2Origin.y, vPsgeR2Final + ui.psgeCoverDepth, Math.PI/2 + vPsgeR1Theta + vPsgeR2Theta33, Math.PI/2 + vPsgeR1Theta, true )
                            .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( vPsgeR4Origin.x, vPsgeR4Origin.y, vPsgeR4Final + ui.psgeCoverDepth, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR4Theta33, true )

                        // 접속부 헌치 내측
                        const vConnR2Theta33 =  Math.asin( ( vConnR2Origin.y - psgeJointH1 ) / ( vConnR2Final + ui.psgeCoverDepth ) );

                        connMainInShp = new THREE.Shape()
                            .absarc( vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + ui.psgeCoverDepth, Math.PI + vConnR2Theta33, Math.PI, true )
                            .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + ui.psgeCoverDepth, vPsgeR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + ui.psgeCoverDepth, 0, 0 - vConnR2Theta33, true )

                        break;

                    }

                    case ('대형차량용') : {
                        
                        // 연결통로 외측
                        const hPsgeR3Gamma5 = Math.asin( ( hPsgeR3Origin.y - psgeJointH1 ) / ( hPsgeR3Final - ui.psgeCoverDepth ) );
                        const hPsgeR3Theta5 = Math.PI/2 - hPsgeR1Theta + hPsgeR3Gamma5;

                        psgeMainOutShp = new THREE.Shape()
                            .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - ui.psgeCoverDepth, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta5,  Math.PI/2 + hPsgeR1Theta, true )
                            .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - ui.psgeCoverDepth, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta5, true );

                        // 접속부 헌치 외측
                        const hConnR3Theta5 = Math.asin( ( hConnR3Origin.y - psgeJointH1 ) / ( hConnR3Final - ui.psgeCoverDepth ) );

                        connMainOutShp = new THREE.Shape()
                            .absarc( hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - ui.psgeCoverDepth, Math.PI/2 + hPsgeR1Theta + hConnR3Theta5, Math.PI/2 + hPsgeR1Theta, true )
                            .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 - ui.psgeCoverDepth, hPsgeR1Final + hConnLiningT0 - ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - ui.psgeCoverDepth, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hConnR3Theta5, true );

                        // 연결통로 내측
                        const hPsgeR2Theta33 = Math.asin( ( hPsgeR2Origin.y - psgeJointH1 ) / ( hPsgeR2Final + ui.psgeCoverDepth ) );

                        psgeMainInShp = new THREE.Shape()
                            .absarc( hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final + ui.psgeCoverDepth, Math.PI/2 + hPsgeR1Theta + hPsgeR2Theta33, Math.PI/2 + hPsgeR1Theta, true )
                            .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final + ui.psgeCoverDepth, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR2Theta33, true ); 

                        // 접속부 헌치 내측
                        const hConnR2Theta33 =  Math.asin( ( hConnR2Origin.y - psgeJointH1 ) / ( hConnR2Final + ui.psgeCoverDepth ) );

                        connMainInShp = new THREE.Shape()
                            .absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + ui.psgeCoverDepth, Math.PI + hConnR2Theta33, Math.PI, true )
                            .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + ui.psgeCoverDepth, hPsgeR1Final + ui.psgeCoverDepth, Math.PI, 0, true )
                            .absarc( -hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + ui.psgeCoverDepth, 0, 0 - hConnR2Theta33, true )

                        break;

                    }

                }


                // 3. 접속부 헌치 주철근 포인트 위치이동( Shp=>Pts=>Move&Rotate)
                // 3.1 외측
                const psgeMainOutGetpts = psgeMainOutShp.getPoints( 100 ); // get Vector2
                const psgeMainOutPts = psgeMainOutGetpts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const psgeMainOutRotPts = psgeMainOutPts.map( i => psgePositionSet(i) );   

                const connMainOutGetPts = connMainOutShp.getPoints( 100 ); // get Vector2
                const connMainOutPts = connMainOutGetPts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const connMainOutRotPts = connMainOutPts.map( i => psgePositionSet(i) );

                // 3.2 내측
                const psgeMainInGetpts = psgeMainInShp.getPoints( 100 ); // get Vector2
                const psgeMainInPts = psgeMainInGetpts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const psgeMainInRotPts = psgeMainInPts.map( i => psgePositionSet(i) );   

                const connMainInGetPts = connMainInShp.getPoints( 100 ); // get Vector2
                const connMainInPts = connMainInGetPts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const connMainInRotPts = connMainInPts.map( i => psgePositionSet(i) );
                

                // 4. 접속부 헌치 철근위치 ray
                // 4.1 외측
                const connMainOutRayPts = [];

                for ( let i=0; i < connMainOutRotPts.length; i++ ) {

                    // raycast
                    const raycast = new THREE.Raycaster();
                    raycast.set( connMainOutRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                    const intersect = raycast.intersectObject( innerAreaExtr );
                    
                    connMainOutRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                }            

                // point를 합쳐줌
                const connMainOutConvexArr = [ ...psgeMainOutRotPts, ...connMainOutRayPts ];

                // 4.2 내측
                const connMainInRayPts = [];

                for ( let i=0; i < connMainInRotPts.length; i++ ) {

                    // raycast
                    const raycast = new THREE.Raycaster();
                    raycast.set( connMainInRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                    const intersect = raycast.intersectObject( innerAreaExtr );
                    
                    connMainInRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                }            

                // point를 합쳐줌
                const connMainInConvexArr = [ ...psgeMainInRotPts, ...connMainInRayPts ];            


                // 5. 접속부 헌치 주철근 convex
                // 5.1 외측
                // 5.1.1 convex로 모델링
                const connMainOutConvexGeo = new ConvexGeometry( connMainOutConvexArr );
                const connMainOutConvexMat = new THREE.MeshStandardMaterial( {color: 'darkslateblue', opacity: 0.9, transparent: true } );
                const connMainOutConvexMesh = new THREE.Mesh( connMainOutConvexGeo, connMainOutConvexMat );
                // showContainer.push( connMainOutConvexMesh );

                // 5.1.2 외측 라이닝 - 연결통로 자를 때 사용
                const outterCutShp = new THREE.Shape()
                    .absarc( 0, r1Height, r1Final + liningT0 - distrCtrLine, Math.PI/2,  Math.PI/2 + r1ThetaLt, false )
                    .absarc( r3Origin.x, r3Origin.y, r3Final - distrCtrLine, Math.PI/2 + r1ThetaLt, Math.PI, false )
                    .lineTo( r3Origin.x - r3Final + distrCtrLine, -2 );

                const outterCutExtr = addExtr( outterCutShp, 'ghostwhite', ui.totalLength, 0.9 );
                // showContainer.push( outterCutExtr )

                // 5.1.3 CSG.subtract
                const connMainOutCsg = new CSG();
                connMainOutCsg.subtract( [ connMainOutConvexMesh, outterCutExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
                const connMainOutMesh = connMainOutCsg.toMesh();
                // showContainer.push( connMainOutMesh );

                // 5.2 내측
                // 5.2.1 convex로 모델링
                const connMainInConvexGeo = new ConvexGeometry( connMainInConvexArr );
                const connMainInConvexMat = new THREE.MeshStandardMaterial( {color: 'hotpink', opacity: 0.9, transparent: true } );
                const connMainInConvexMesh = new THREE.Mesh( connMainInConvexGeo, connMainInConvexMat );
                // showContainer.push( connMainInConvexMesh );

                // 5.2.2 내측 라이닝 - 연결통로 자를 때 사용
                const innerCutShp = new THREE.Shape()
                .absarc( 0, r1Height, r1Final + distrCtrLine, Math.PI/2, Math.PI/2 + r1ThetaLt, false )
                .absarc( r2Origin.x, r2Origin.y, r2Final + distrCtrLine, Math.PI/2 + r1ThetaLt, Math.PI, false )    
                .lineTo( r2Origin.x - r2Final - distrCtrLine, - 2)

                const innerCutExtr = addExtr( innerCutShp, 'seagreen', ui.totalLength, 0.9 );
                // showContainer.push( innerCutExtr )

                // 5.2.3 CSG.subtract
                const connMainInCsg = new CSG();
                connMainInCsg.subtract( [ connMainInConvexMesh, innerCutExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
                const connMainInMesh = connMainInCsg.toMesh();
                // showContainer.push( connMainInMesh );
            
                
                // 6. 접속부 헌치보다 약간 큰 가상의 경로 생성
                let connMainPath

                switch ( ui.crossPsgeType ) {

                    case ('대인용') : {

                        connMainPath = new THREE.Shape()
                            .moveTo( -pConnR1Final - pConnLiningT0 - ui.psgeShotcrete - ui.psgeCoverDepth, pPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( -pConnR1Final - pConnLiningT0 - ui.psgeShotcrete - ui.psgeCoverDepth, pConnR1Origin.y )
                            .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( pConnR1Final + pConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, pPsgeFootingRightPt.y + psgeJointH1 );

                            break;

                    }

                    case ('차량용') : {

                        connMainPath = new THREE.Shape()
                            .moveTo( -(vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth), vPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( -(vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth), vPsgeR1Origin.y )
                            .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, vPsgeR1Final + vConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( vPsgeR1Final + vConnHaunch + vConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, vPsgeFootingRightPt.y + psgeJointH1 );

                        break;

                    }

                    case ('대형차량용') : {

                        connMainPath = new THREE.Shape()
                            .moveTo( -(hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth), hPsgeFootingLeftPt.y + psgeJointH1 )
                            .lineTo( -(hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth), hPsgeR1Origin.y )
                            .absellipse( hPsgeR1Origin.x, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, hPsgeR1Final + hConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, Math.PI, 0, true )
                            .lineTo( hPsgeR1Final + hConnHaunch + hConnLiningT0 + ui.psgeShotcrete + ui.psgeCoverDepth, hPsgeFootingRightPt.y + psgeJointH1 );

                        break;

                    }

                }


                // 7. 접속부 헌치 주철근 모델링
                arrayConnMain( connMainPath, connMainOutMesh, 0x96ceb4 );
                arrayConnMain( connMainPath, connMainInMesh, 'deeppink' );

                function arrayConnMain( path, targetMesh, color ) {

                    const segArr = [];
                    const tanArr = [];

                    const divideNum = 50;

                    for ( let i=0; i < divideNum+1 ; i++ ) { 

                        // 갯수로 나누기
                        const segment = path.getPointAt( i/divideNum );
                        segArr.push( new THREE.Vector3( segment.x, segment.y, 0) )

                        // tangent 기록
                        const tangent = path.getTangentAt( i/divideNum );
                        tanArr.push( new THREE.Vector3( tangent.x, tangent.y, 0) )

                    }

                    // 접속부 헌치 위치이동
                    const segArrRot = segArr.map( i => psgePositionSet(i)
                        .applyMatrix4( matrix.makeTranslation( -ui.psgeCtc/2, 0, 0 ) 
                    ) );

                    // 포인트를 이동하면서 ray하여 주철근생성
                    for ( let i=0; i< 5/ui.psgeCtc; i++ ) { /*** 접속부 길이 5m로 일단 설정해놓음. 길면 시간 오래걸림 ***/

                        const connMainFinalPts = [];

                        const segArrTransl = segArrRot.map( pts => pts.applyMatrix4( matrix.makeTranslation( ui.psgeCtc, 0, 0 ) ) );

                        for ( let j=0; j< segArrTransl.length; j++ ) {
                            
                            const raycast = new THREE.Raycaster();
                            raycast.set( new THREE.Vector3( segArrTransl[j].x, segArrTransl[j].y, segArrTransl[j].z ), new THREE.Vector3( 0, -tanArr[j].x, tanArr[j].y ).normalize() );
                            const intersectLeft = raycast.intersectObject( targetMesh )

                            if( intersectLeft.length != 0 ) {
                                
                                connMainFinalPts.push( new THREE.Vector3( intersectLeft[0].point.x, intersectLeft[0].point.y, intersectLeft[0].point.z ) );

                            }

                        }

                        if( connMainFinalPts.length != 0 ) {

                            const connMainLtPath = addPath( connMainFinalPts )
                            const connMainLtSweep = addSweep( main1Shp, color, connMainLtPath, 0.9 )
                            showContainer.push( connMainLtSweep ) 

                        }

                    }

                }


                // 8. 연결통로 주철근 모델링
                // addExtru : 직선방향으로 돌출
                // addSweep : curve에 따라 돌출
                // 경로를 점으로 바꾸고 점을 Curve로 바꿈
                // addArr => addPath => addSweep

                arrayPsgeMain( psgeMainOutShp, 0x96ceb4 )
                arrayPsgeMain( psgeMainInShp, 'deeppink' )

                function arrayPsgeMain ( path, color ) {

                    const psgeMainGroup = new THREE.Group();

                    const psgeMainArr = addArr( path );
                    const psgeMainPath = addPath( psgeMainArr );
                    const psgeMainSweep = addSweep( psgeMain1Shp, color, psgeMainPath, 0.9 );
                    psgePositionSet( psgeMainSweep );

                    psgeMainGroup.add( psgeMainSweep );

                    // 연결통로 주철근 배치      
                    for ( let i=0; i * ui.psgeCtc + 0.5 * ui.psgeCtc <= netReinforceL; i++ ) {
                        
                        const psgeMainGroupClone = psgeMainGroup.clone();
                        psgeMainGroupClone.position.set( -i * ui.psgeCtc - 0.5 * ui.psgeCtc, 0, 0 );
                        showContainer.push( psgeMainGroupClone );

                    }

                }



                // 연결통로 배력철근 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // psgeAnchLtRayPts(v) | psgeConnLtRayPts(v) |
                // psgeAnchLtPts       | psgeConnLtPts       | psgeStartLtPts(v)
                //                                           | psgeEndLtPts(v)

                // 1. 연결통로 배력철근 경로

                // 배력철근
                const distrGroup = new THREE.Group();

                // 배력철근 중심선
                const psgeDistrCtrLine = ui.psgeCoverDepth + psgeMainMaxDia/2 + ui.psgeDistrDia/2;

                // 1.1 대인용 피난연결통로 경로

                // 대인용 외측 경로(기준선)
                const pPsgeDistrOutLtShp = new THREE.Shape()
                    .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 + pPsgeR1Theta, false )
                    .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 + psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 );

                const pPsgeDistrOutRtShp = new THREE.Shape()
                    .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 - pPsgeR1Theta, true )
                    .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 - psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 );

                const pPsgeDistrOutShp = new THREE.Shape()
                    .moveTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 + psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 )
                    .lineTo( pPsgeFootingLeftPt.x - pPsgeLiningT0 + psgeDistrCtrLine, pPsgeR1Origin.y )
                    .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + pPsgeLiningT0 - psgeDistrCtrLine, Math.PI, 0, true )
                    .lineTo( pPsgeFootingRightPt.x + pPsgeLiningT0 - psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 );

                // 대인용 내측 경로
                const pPsgeDistrInShp = new THREE.Shape()
                    .moveTo( pPsgeFootingLeftPt.x - psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 )
                    .lineTo( pPsgeFootingLeftPt.x - psgeDistrCtrLine, pPsgeR1Origin.y )
                    .absarc( pPsgeR1Origin.x, pPsgeR1Origin.y, pPsgeR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .lineTo( pPsgeFootingRightPt.x + psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 );


                // 1.2 대인용 접속부 헌치 배력철근 경로

                // 대인용 접속부 헌치 외측 경로
                const pConnDistrOutLtShp = new THREE.Shape()
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI, false )
                    .lineTo( -pConnR1Final - pConnLiningT0 + psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 );

                const pConnDistrOutRtShp = new THREE.Shape()
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 - psgeDistrCtrLine, Math.PI/2, 0, true )
                    .lineTo( pConnR1Final + pConnLiningT0 - psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 );

                const pConnDistrOutShp = new THREE.Shape()
                    .moveTo( -pConnR1Final - pConnLiningT0 + psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 )
                    .lineTo( -pConnR1Final - pConnLiningT0 + psgeDistrCtrLine, pConnR1Origin.y )
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 - psgeDistrCtrLine, Math.PI, 0, true )
                    .lineTo( pConnR1Final + pConnLiningT0 - psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 )
                    // .lineTo( pConnR1Final + pConnLiningT0 - psgeDistrCtrLine + 0.1, pPsgeFootingRightPt.y + psgeJointH1 )
                    // .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + pConnLiningT0 - psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .lineTo( -pConnR1Final - pConnLiningT0 + psgeDistrCtrLine - 0.1, pPsgeFootingLeftPt.y + psgeJointH1 );

                // 대인용 접속부 헌치 내측 경로
                const pConnDistrInLtShp = new THREE.Shape()
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + psgeDistrCtrLine, Math.PI/2, Math.PI, false )
                    .lineTo( -pConnR1Final - psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 );

                const pConnDistrInRtShp = new THREE.Shape()
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + psgeDistrCtrLine, Math.PI/2, 0, true )
                    .lineTo( pConnR1Final + psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 );                 

                const pConnDistrInShp = new THREE.Shape()
                    .moveTo( -pConnR1Final - psgeDistrCtrLine, pPsgeFootingLeftPt.y + psgeJointH1 )
                    .lineTo( -pConnR1Final - psgeDistrCtrLine, pConnR1Origin.y )
                    .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .lineTo( pConnR1Final + psgeDistrCtrLine, pPsgeFootingRightPt.y + psgeJointH1 )
                    // .lineTo( pConnR1Final + psgeDistrCtrLine + 0.1, pPsgeFootingRightPt.y + psgeJointH1 )
                    // .absarc( pConnR1Origin.x, pConnR1Origin.y, pConnR1Final + psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .lineTo( -pConnR1Final - psgeDistrCtrLine - 0.1, pPsgeFootingLeftPt.y + psgeJointH1 );


                // 1.3 차량용 연결통로 경로

                // 차량용 외측 경로(기준선)
                const vPsgeR3Theta3 = Math.asin( ( vPsgeR3Origin.y - psgeJointH1 ) / ( vPsgeR3Final - psgeDistrCtrLine ) );
                const vPsgeR5Theta3 = Math.asin( ( vPsgeR5Origin.y - psgeJointH1 ) / ( vPsgeR5Final - psgeDistrCtrLine ) );

                const vPsgeDistrOutLtShp = new THREE.Shape()
                    .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 + vPsgeR1Theta, false )
                    .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final - psgeDistrCtrLine,  Math.PI/2 + vPsgeR1Theta, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta3, false );

                const vPsgeDistrOutRtShp = new THREE.Shape()
                    .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 - vPsgeR1Theta, true )
                    .absarc( vPsgeR5Origin.x, vPsgeR5Origin.y, vPsgeR5Final - psgeDistrCtrLine, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR5Theta3, true );

                const vPsgeDistrOutShp = new THREE.Shape()
                    .absarc( vPsgeR3Origin.x, vPsgeR3Origin.y, vPsgeR3Final - psgeDistrCtrLine, Math.PI/2 + vPsgeR1Theta + vPsgeR3Theta3, Math.PI/2 + vPsgeR1Theta, true )
                    .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + vPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2 + vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta, true )
                    .absarc( vPsgeR5Origin.x, vPsgeR5Origin.y, vPsgeR5Final - psgeDistrCtrLine, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR5Theta3, true );

                // 차량용 내측 경로
                const vPsgeR2Theta3 = Math.asin( ( vPsgeR2Origin.y - psgeJointH1 ) / ( vPsgeR2Final + psgeDistrCtrLine ) );
                const vPsgeR4Theta3 = Math.asin( ( vPsgeR4Origin.y - psgeJointH1 ) / ( vPsgeR4Final + psgeDistrCtrLine ) );

                const vPsgeDistrInShp = new THREE.Shape()
                    .absarc( vPsgeR2Origin.x, vPsgeR2Origin.y, vPsgeR2Final + psgeDistrCtrLine, Math.PI/2 + vPsgeR1Theta + vPsgeR2Theta3, Math.PI/2 + vPsgeR1Theta, true )
                    .absarc( 0, vPsgeR1Origin.y, vPsgeR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( vPsgeR4Origin.x, vPsgeR4Origin.y, vPsgeR4Final + psgeDistrCtrLine, Math.PI/2 - vPsgeR1Theta, Math.PI/2 - vPsgeR1Theta - vPsgeR4Theta3, true )


                // 1.4 차량용 접속부 헌치 배력철근 경로

                // 차량용 접속부 헌치 외측 경로
                const vConnR3Theta3 =  Math.asin( ( vConnR3Origin.y - psgeJointH1 ) / ( vConnR3Final - psgeDistrCtrLine ) );

                const vConnDistrOutLtShp = new THREE.Shape()
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 - psgeDistrCtrLine, vPsgeR1Final + vConnLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI, false )
                    .absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine, Math.PI, Math.PI + vConnR3Theta3, false );

                const vConnDistrOutRtShp = new THREE.Shape()
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 - psgeDistrCtrLine, vPsgeR1Final + vConnLiningT0 - psgeDistrCtrLine, Math.PI/2, 0, true )
                    .absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine, 0, 0 - vConnR3Theta3, true );

                const vConnDistrOutShp = new THREE.Shape()
                    .absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine, Math.PI + vConnR3Theta3, Math.PI, true )
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 - psgeDistrCtrLine, vPsgeR1Final + vConnLiningT0 - psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine, 0, 0 - vConnR3Theta3, true )
                    // .absarc( -vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine + 0.1, 0 - vConnR3Theta3, 0, false )
                    // .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + vConnLiningT0 - psgeDistrCtrLine + 0.1, vPsgeR1Final + vConnLiningT0 - psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .absarc( vConnR3Origin.x, vConnR3Origin.y, vConnR3Final - psgeDistrCtrLine + 0.1, Math.PI, Math.PI + vConnR3Theta3, false );

                // 차량용 접속부 헌치 내측 경로
                const vConnR2Theta3 =  Math.asin( ( vConnR2Origin.y - psgeJointH1 ) / ( vConnR2Final + psgeDistrCtrLine ) );

                const vConnDistrInLtShp = new THREE.Shape()
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + psgeDistrCtrLine, vPsgeR1Final + psgeDistrCtrLine, Math.PI/2, Math.PI, false )    
                    .absarc( vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine, Math.PI, Math.PI + vConnR2Theta3, false );

                const vConnDistrInRtShp = new THREE.Shape()
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + psgeDistrCtrLine, vPsgeR1Final + psgeDistrCtrLine, Math.PI/2, 0, true )
                    .absarc( -vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine, 0, 0 - vConnR2Theta3, true );

                const vConnDistrInShp = new THREE.Shape()
                    .absarc( vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine, Math.PI + vConnR2Theta3, Math.PI, true )
                    .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + psgeDistrCtrLine, vPsgeR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( -vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine, 0, 0 - vConnR2Theta3, true )
                    // .absarc( -vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine + 0.1, 0 - vConnR2Theta3, 0, false )
                    // .absellipse( 0, vPsgeR1Origin.y, vPsgeR1Final + vConnHaunch + psgeDistrCtrLine + 0.1, vPsgeR1Final + psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .absarc( vConnR2Origin.x, vConnR2Origin.y, vConnR2Final + psgeDistrCtrLine + 0.1, Math.PI, Math.PI + vConnR2Theta3, false );


                // 1.5 대형차량용 연결통로 경로

                // 대형차량용 외측 경로(기준선)
                const hPsgeR3Theta3 = Math.asin( ( hPsgeR3Origin.y - psgeJointH1 ) / ( hPsgeR3Final - psgeDistrCtrLine ) );

                const hPsgeDistrOutLtShp = new THREE.Shape()
                    .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 + hPsgeR1Theta, false )
                    .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - psgeDistrCtrLine, Math.PI/2 + hPsgeR1Theta, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta3, false );

                const hPsgeDistrOutRtShp = new THREE.Shape()
                    .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI/2 - hPsgeR1Theta, true )
                    .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - psgeDistrCtrLine, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta3, true ); 

                const hPsgeDistrOutShp = new THREE.Shape()
                    .absarc( hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - psgeDistrCtrLine, Math.PI/2 + hPsgeR1Theta + hPsgeR3Theta3, Math.PI/2 + hPsgeR1Theta, true )
                    .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + hPsgeLiningT0 - psgeDistrCtrLine, Math.PI/2 + hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta, true )
                    .absarc( -hPsgeR3Origin.x, hPsgeR3Origin.y, hPsgeR3Final - psgeDistrCtrLine, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR3Theta3, true ); 

                // 대형차량용 내측 경로
                const hPsgeR2Theta3 = Math.asin( ( hPsgeR2Origin.y - psgeJointH1 ) / ( hPsgeR2Final + psgeDistrCtrLine ) );

                const hPsgeDistrInShp = new THREE.Shape()
                    .absarc( hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final + psgeDistrCtrLine, Math.PI/2 + hPsgeR1Theta + hPsgeR2Theta3, Math.PI/2 + hPsgeR1Theta, true )
                    .absarc( 0, hPsgeR1Origin.y, hPsgeR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( -hPsgeR2Origin.x, hPsgeR2Origin.y, hPsgeR2Final + psgeDistrCtrLine, Math.PI/2 - hPsgeR1Theta, Math.PI/2 - hPsgeR1Theta - hPsgeR2Theta3, true ); 


                // 1.6 대형차량용 접속부 헌치 배력철근 경로

                // 대형차량용 접속부 헌치 외측 경로
                const hConnR3Theta3 =  Math.asin( ( hConnR3Origin.y - psgeJointH1 ) / ( hConnR3Final - psgeDistrCtrLine ) );

                const hConnDistrOutLtShp = new THREE.Shape()
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 - psgeDistrCtrLine, hPsgeR1Final + hConnLiningT0 - psgeDistrCtrLine, Math.PI/2, Math.PI, false )
                    .absarc( hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine, Math.PI, Math.PI + hConnR3Theta3, false );

                const hConnDistrOutRtShp = new THREE.Shape()
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 - psgeDistrCtrLine, hPsgeR1Final + hConnLiningT0 - psgeDistrCtrLine, Math.PI/2, 0, true )
                    .absarc( -hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine, 0, 0 - hConnR3Theta3, true );

                const hConnDistrOutShp = new THREE.Shape()
                    .absarc( hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine, Math.PI + hConnR3Theta3, Math.PI, true )
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 - psgeDistrCtrLine, hPsgeR1Final + hConnLiningT0 - psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( -hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine, 0, 0 - hConnR3Theta3, true )
                    // .absarc( -hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine + 0.1, Math.PI/2 - hPsgeR1Theta - hConnR3Theta3, Math.PI/2 - hPsgeR1Theta, false )
                    // .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + hConnLiningT0 - psgeDistrCtrLine + 0.1, hPsgeR1Final + hConnLiningT0 - psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .absarc( hConnR3Origin.x, hConnR3Origin.y, hConnR3Final - psgeDistrCtrLine + 0.1, Math.PI, Math.PI + hConnR3Theta3, false );

                // 대형차량용 접속부 헌치 내측 경로
                const hConnR2Theta3 =  Math.asin( ( hConnR2Origin.y - psgeJointH1 ) / ( hConnR2Final + psgeDistrCtrLine ) );

                const hConnDistrInLtShp = new THREE.Shape()
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + psgeDistrCtrLine, hPsgeR1Final + psgeDistrCtrLine, Math.PI/2, Math.PI, false )
                    .absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine, Math.PI, Math.PI + hConnR2Theta3, false );  

                const hConnDistrInRtShp = new THREE.Shape()
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + psgeDistrCtrLine, hPsgeR1Final + psgeDistrCtrLine, Math.PI/2, 0, true )
                    .absarc( -hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine, 0, 0 - hConnR2Theta3, true );

                const hConnDistrInShp = new THREE.Shape()
                    .absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine, Math.PI + hConnR2Theta3, Math.PI, true )
                    .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + psgeDistrCtrLine, hPsgeR1Final + psgeDistrCtrLine, Math.PI, 0, true )
                    .absarc( -hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine, 0, 0 - hConnR2Theta3, true )
                    // .absarc( -hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine + 0.1, 0 - hConnR2Theta3, 0, false )
                    // .absellipse( 0, hPsgeR1Origin.y, hPsgeR1Final + hConnHaunch + psgeDistrCtrLine + 0.1, hPsgeR1Final + psgeDistrCtrLine + 0.1, 0, Math.PI, false )
                    // .absarc( hConnR2Origin.x, hConnR2Origin.y, hConnR2Final + psgeDistrCtrLine + 0.1, Math.PI, Math.PI + hConnR2Theta3, false );



                // 피난연결통로 경로 타입 ( 대인용, 차량용, 대형차량용 )
                let psgeDistrOutLtShp, psgeDistrOutRtShp, psgeDistrOutShp
                let psgeDistrInShp
                let connDistrOutLtShp, connDistrOutRtShp, connDistrOutShp
                let connDistrInLtShp, connDistrInRtShp, connDistrInShp

                if ( ui.crossPsgeType == '대인용') {
                    
                    psgeDistrOutLtShp = pPsgeDistrOutLtShp
                    psgeDistrOutRtShp = pPsgeDistrOutRtShp
                    psgeDistrOutShp = pPsgeDistrOutShp

                    psgeDistrInShp = pPsgeDistrInShp

                    connDistrOutLtShp = pConnDistrOutLtShp
                    connDistrOutRtShp = pConnDistrOutRtShp
                    connDistrOutShp = pConnDistrOutShp

                    connDistrInLtShp  = pConnDistrInLtShp
                    connDistrInRtShp  = pConnDistrInRtShp
                    connDistrInShp  = pConnDistrInShp

                } else if ( ui.crossPsgeType == '차량용') {

                    psgeDistrOutLtShp = vPsgeDistrOutLtShp
                    psgeDistrOutRtShp = vPsgeDistrOutRtShp
                    psgeDistrOutShp = vPsgeDistrOutShp

                    psgeDistrInShp = vPsgeDistrInShp

                    connDistrOutLtShp = vConnDistrOutLtShp
                    connDistrOutRtShp = vConnDistrOutRtShp
                    connDistrOutShp = vConnDistrOutShp

                    connDistrInLtShp  = vConnDistrInLtShp
                    connDistrInRtShp  = vConnDistrInRtShp
                    connDistrInShp  = vConnDistrInShp

                } else if ( ui.crossPsgeType == '대형차량용') {
                    
                    psgeDistrOutLtShp = hPsgeDistrOutLtShp
                    psgeDistrOutRtShp = hPsgeDistrOutRtShp
                    psgeDistrOutShp = hPsgeDistrOutShp

                    psgeDistrInShp = hPsgeDistrInShp

                    connDistrOutLtShp = hConnDistrOutLtShp
                    connDistrOutRtShp = hConnDistrOutRtShp
                    connDistrOutShp = hConnDistrOutShp

                    connDistrInLtShp  = hConnDistrInLtShp
                    connDistrInRtShp  = hConnDistrInRtShp
                    connDistrInShp  = hConnDistrInShp

                }


                // 배력철근 기준선
                const psgeDistrOutLtLine = addLine( psgeDistrOutLtShp, 'red' );
                const psgeDistrOutRtLine = addLine( psgeDistrOutRtShp, 'forestgreen' );
                
                // showContainer.push( psgeDistrOutLtLine );
                // showContainer.push( psgeDistrOutRtLine );


                // 철근교차위치를 찾기 위해 정밀하게 모델링
                const psgeDistrInExtr = addExtrHD( psgeDistrInShp, 'limegreen', mainTunnelLength, 0.8 );
                // showContainer.push( psgeDistrInExtr );





                // 삭제 예정
                // function arrayDistrOut( path, connHaunchMesh, direction, rayMainInMesh, rayDistrExtr, center ) { // ( 기준선, 접속부헌치메쉬, 방향, ray본선라이닝내측메쉬, ray본선배력외측메쉬, 센터포함여부(0:OK, 1:No) )

                //     // 배력철근 위치결정
                //     const psgeStartPts = []; // 연결통로
                //     const psgeConnPts = []; // 연결통로-본선 접속부 
                //     const psgeAnchPts = []; // 본선 접속부 정착장
                    

                //     for ( let i=center; i*ui.psgeDistrSpacing < path.getLength(); i++ ) {
                        
                //         // 일정길이로 나누기
                //         const segment = path.getPointAt( i*ui.psgeDistrSpacing / path.getLength() );
                //         const tangent = path.getTangentAt( i*ui.psgeDistrSpacing / path.getLength() );

                //         psgeStartPts.push( new THREE.Vector3( segment.x, segment.y ) );

                //         // raycast
                //         const raycast = new THREE.Raycaster();

                //         const angle = Math.atan2( direction * -tangent.y, direction * -tangent.x );

                //         if ( direction * angle <= Math.PI/2 ) { // 연결통로 상반부

                //             raycast.set( new THREE.Vector3( segment.x, segment.y, 0 ), new THREE.Vector3( direction * tangent.y, direction * -tangent.x, 0 ).normalize() ); 
                //             const intersect = raycast.intersectObject( connHaunchMesh );

                //             if ( intersect.length != 0 ) {

                //                 // 연결통로-본선 접속부 헌치 포인트
                //                 psgeConnPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y ) );

                //                 // 본선 접속부 정착장 포인트
                //                 psgeAnchPts.push( new THREE.Vector3( intersect[0].point.x + 0.1*direction*tangent.y, intersect[0].point.y - 0.1*direction*tangent.x ) );

                //             }
                            
                //         } else { // 연결통로 하반부

                //             raycast.set( new THREE.Vector3( segment.x, segment.y, 0 ), new THREE.Vector3( direction*-1, 0, 0 ).normalize() );
                //             const intersect = raycast.intersectObject( connHaunchMesh );

                //             if ( intersect.length != 0 ) {
                            
                //                 // 연결통로-본선 접속부 헌치 포인트
                //                 psgeConnPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y ) );

                //                 // 본선 접속부 정착장 포인트
                //                 psgeAnchPts.push( new THREE.Vector3( intersect[0].point.x - direction*0.1, intersect[0].point.y ) );

                //             }

                //         }

                //     }


                




                // 2. 접속부 헌치 배력철근 외측 convex
                // 2.1 접속부 헌치 배력철근 포인트 위치 이동
                const psgeDistrOutGetpts = psgeDistrOutShp.getPoints( 100 ); // get Vector2
                const psgeDistrOutPts = psgeDistrOutGetpts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const psgeDistrOutRotPts = psgeDistrOutPts.map( i => psgePositionSet(i) );   

                const connDistrOutGetPts = connDistrOutShp.getPoints( 100 ); // get Vector2
                const connDistrOutPts = connDistrOutGetPts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const connDistrOutRotPts = connDistrOutPts.map( i => psgePositionSet(i) );

                // 2.2 접속부 헌치 철근위치 ray 원본
                const connDistrOutRayPts = [];

                for ( let i=0; i < connDistrOutRotPts.length; i++ ) {

                    // raycast
                    const raycast = new THREE.Raycaster();
                    raycast.set( connDistrOutRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                    const intersect = raycast.intersectObject( innerAreaExtr );
                    
                    connDistrOutRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                }            

                // 2.3 point를 합쳐줌
                const connDistrOutConvexArr = [ ...psgeDistrOutRotPts, ...connDistrOutRayPts ];

                // 2.4 convex로 모델링
                const connDistrOutConvexGeo = new ConvexGeometry( connDistrOutConvexArr );
                const connDistrOutConvexMat = new THREE.MeshStandardMaterial( {color: 'lightseagreen', opacity: 0.9, transparent: true, side : THREE.DoubleSide } );
                const connDistrOutConvexMesh = new THREE.Mesh( connDistrOutConvexGeo, connDistrOutConvexMat );

                // 2.5 CSG.subtract
                const connDistrOutCsg = new CSG();
                connDistrOutCsg.subtract( [ connDistrOutConvexMesh, innerCutExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
                const connDistrOutMesh = connDistrOutCsg.toMesh();
                // showContainer.push( connDistrOutMesh );


                // 3. 연결통로-접속부 배력철근 외측 모델링
                arrayDistrOutRev1( psgeDistrOutLtShp, connDistrOutLtShp, 1, distrOutLtExtr, 0 ); // 좌측 외측( 기준선, 접속부헌치메쉬, 방향(좌측:1), ray본선라이닝내측메쉬, 센터포함여부(0:OK) )
                arrayDistrOutRev1( psgeDistrOutRtShp, connDistrOutRtShp, -1, distrOutLtExtr, 1 ); // 우측 외측( 기준선, 접속부헌치메쉬, 방향(우측:-1), ray본선라이닝내측메쉬, 센터포함여부(1:No) )

                function arrayDistrOutRev1( path, connDistrOutShp, direction, rayDistrExtr, center ) { // ( 기준선, 접속부헌치메쉬, 방향, ray본선라이닝내측메쉬, 센터포함여부(0:OK, 1:No) )

                    // 3.1 배력철근 위치결정
                    const psgeStartPts = []; // 연결통로
                    const psgeConnPts = []; // 연결통로-본선 접속부 
                    const psgeAnchPts = []; // 본선 접속부 정착장

                    const tanValue = [];

                    for ( let i=0; i*ui.psgeDistrSpacing < path.getLength(); i++ ) {
                        
                        // 길이로 나누기
                        const segment = path.getPointAt( i*ui.psgeDistrSpacing / path.getLength() );
                        const tangent = path.getTangentAt( i*ui.psgeDistrSpacing / path.getLength() );
                        
                        psgeStartPts.push( new THREE.Vector3( segment.x, segment.y ) );
                        tanValue.push( new THREE.Vector3( tangent.x, tangent.y, 0 ) );

                    }

                    for ( let i=0; i< psgeStartPts.length ; i++ ) { 

                        // 갯수로 나누기
                        const segment = connDistrOutShp.getPointAt( i/(psgeStartPts.length-1) );
                        const tangent = connDistrOutShp.getTangentAt( i/(psgeStartPts.length-1) );
                    
                        // 연결통로-본선 접속부 
                        psgeConnPts.push( new THREE.Vector3( segment.x, segment.y ) );

                        // 본선 접속부 정착장 포인트
                        psgeAnchPts.push( new THREE.Vector3( segment.x + 0.1*direction*tangent.y, segment.y - 0.1*direction*tangent.x ) );                    

                    }

                    // showPts( psgeStartPts, 'cadetblue' )
                    // showPts( psgeConnPts, 'cyan' )

                    // 3.2 배력철근 포인트 위치 이동
                    const psgeStartRotPts = psgeStartPts.map( i => psgePositionSet(i) );
                    const psgeConnRotPts = psgeConnPts.map( i => psgePositionSet(i) );
                    const psgeAnchRotPts = psgeAnchPts.map( i => psgePositionSet(i) );  
                    const psgeEndRotPts = psgeStartRotPts.map( i => i.clone().applyMatrix4( matrix.makeTranslation( -netReinforceL, 0, 0 ) ) );

                    // 3.3 접속부 철근위치 ray 원본( 본선 내측까지 )
                    const psgeConnRayPts = [];

                    for ( let i=0; i < psgeConnRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        raycast.set( psgeConnRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                        const intersect = raycast.intersectObject( innerAreaExtr );
                        
                        psgeConnRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 3.4 접속부 철근위치 ray 보정( 본선 배력철근 내측으로 )
                    const psgeConnRayPts22 = [];

                    for ( let i=0; i < psgeConnRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( psgeConnRayPts[i].x - psgeStartRotPts[i].x, psgeConnRayPts[i].y - psgeStartRotPts[i].y, psgeConnRayPts[i].z - psgeStartRotPts[i].z ).normalize();
                        raycast.set( psgeStartRotPts[i], normalize );
                        const intersect = raycast.intersectObject( rayDistrExtr );
                        
                        psgeConnRayPts22.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 3.5 정착길이 ray 원본
                    const psgeAnchRayPts = [];

                    for ( let i=0; i < psgeAnchRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        raycast.set( psgeAnchRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                        const intersect = raycast.intersectObject( rayDistrExtr );
                        
                        psgeAnchRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 3.6 정착길이 ray 보정
                    const psgeAnchRayPts22 = [];

                    for ( let i=0; i < psgeAnchRayPts.length; i++ ) {

                        const v1 = psgeConnRayPts22[i].clone();
                        const v2 = psgeAnchRayPts[i].clone();
                        const v3 = new THREE.Vector3();
                        const len = psgeAnchorRebarL;

                        // v3.subVectors( v2, v1 ).multiplyScalar( 1 + ( len / v3.length() ) ).add( v1 );

                        v3.subVectors( v2, v1 ).normalize ().multiplyScalar( len ).add( v1 );

                        psgeAnchRayPts22.push( v3 );

                    }

                    // 3.7.1 접속부 헌치 1/3점
                    const oneThirdPts = [];

                    for ( let i=0; i < psgeStartRotPts.length; i++ ) {

                        const oneThird = new THREE.Vector3()
                        oneThird.lerpVectors( psgeStartRotPts[i], psgeConnRayPts22[i], 1/3 )
                        
                        oneThirdPts.push( oneThird  );

                    }

                    // 3.7.2 접속부 헌치 2/3점
                    const twoThirdsPts = [];

                    for ( let i=0; i < psgeStartRotPts.length; i++ ) {

                        const twoThirds = new THREE.Vector3()
                        twoThirds.lerpVectors( psgeStartRotPts[i], psgeConnRayPts22[i], 2/3 )
                        
                        twoThirdsPts.push( twoThirds  );

                    }

                    //3.8.1 접속부 헌치 1/3점 ray 
                    const oneThirdPtsRay = [];
                    for ( let i=0; i < oneThirdPts.length; i++ ) {
                        
                        // raycast
                        // clock false, Left = out ( y, -x ), In ( -y, x );
                        // clock true, Right = out ( -y, x ), In ( y, -x );
                        // intersectObject = type : mesh, no line;
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( 0, direction*-tanValue[i].x, direction*tanValue[i].y ).normalize(); // x값 => z값
                        raycast.set( oneThirdPts[i], normalize );
                        const intersect = raycast.intersectObject( connDistrOutMesh );

                        if ( intersect.length != 0 ) {
                        
                            // Out
                            oneThirdPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        } else {
                            
                            // In
                            const normalize2 = new THREE.Vector3( 0, direction*tanValue[i].x, direction*-tanValue[i].y ).normalize(); // x값 => z값
                            raycast.set( oneThirdPts[i], normalize2 );
                            const intersect = raycast.intersectObject( connDistrOutMesh );
                            oneThirdPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        }
                        
                    }
                
                    // showPts( oneThirdPtsRay, 'green')

                    // 3.8.2 접속부 헌치 2/3점 ray 
                    const twoThirdsPtsRay = [];
                    for ( let i=0; i < twoThirdsPts.length; i++ ) {
                        
                        // raycast
                        // clock false, Left = out ( y, -x ), In ( -y, x );
                        // clock true, Right = out ( -y, x ), In ( y, -x );
                        // intersectObject = type : mesh, no line;
                        const raycast = new THREE.Raycaster();                    
                        const normalize = new THREE.Vector3( 0, direction*-tanValue[i].x, direction*tanValue[i].y ).normalize(); // x값 => z값
                        raycast.set( twoThirdsPts[i], normalize );
                        const intersect = raycast.intersectObject( connDistrOutMesh );

                        if ( intersect.length != 0 ) {
                        
                            // Out
                            twoThirdsPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        } else {
                            
                            // In
                            const normalize2 = new THREE.Vector3( 0, direction*tanValue[i].x, direction*-tanValue[i].y ).normalize(); // x값 => z값
                            raycast.set( twoThirdsPts[i], normalize2 );
                            const intersect = raycast.intersectObject( connDistrOutMesh );
                            twoThirdsPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        }
                        
                    }
                
                    // showPts( twoThirdsPtsRay, 'green')

                    // 3.9 접속부 헌치 배력철근 배치
                    for ( let i=center; i < psgeStartRotPts.length; i++ ) {
                        
                        const haunchDistrPath = new THREE.CurvePath();
                        const p1 = psgeEndRotPts[i]
                        const p2 = psgeStartRotPts[i]
                        const p3 = oneThirdPtsRay[i]
                        const p4 = twoThirdsPtsRay[i]
                        const p5 = psgeConnRayPts22[i]
                        const p6 = psgeAnchRayPts22[i]

                        const L1 = new THREE.LineCurve3( p1, p2 );
                        const L2 = new THREE.LineCurve3( p2, p3 );
                        const L3 = new THREE.LineCurve3( p3, p4 );
                        const L4 = new THREE.LineCurve3( p4, p5 );
                        const L5 = new THREE.LineCurve3( p5, p6 );

                        haunchDistrPath.add( L1 );
                        haunchDistrPath.add( L2 );
                        haunchDistrPath.add( L3 );
                        haunchDistrPath.add( L4 );
                        haunchDistrPath.add( L5 );

                        // 배력철근 형상 distr Rebar, 
                        const main1Shp = new THREE.Shape()
                            .absarc( 0, 0, ui.psgeDistrDia/2, 0, Math.PI * 2, false );

                        const haunchDistrSweep = addSweep( main1Shp, 0xff6f69, haunchDistrPath, 1 );
                        showContainer.push( haunchDistrSweep )

                    }

                }


                // 4. 접속부 헌치 배력철근 내측 convex
                // 4.1 접속부 헌치 배력철근 포인트 위치 이동
                const psgeDistrInGetpts = psgeDistrInShp.getPoints( 100 ); // get Vector2
                const psgeDistrInPts = psgeDistrInGetpts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const psgeDistrInRotPts = psgeDistrInPts.map( i => psgePositionSet(i) );   

                const connDistrInGetPts = connDistrInShp.getPoints( 100 ); // get Vector2
                const connDistrInPts = connDistrInGetPts.map( i => new THREE.Vector3(i.x, i.y, 0) ) // convert Vector3
                const connDistrInRotPts = connDistrInPts.map( i => psgePositionSet(i) );

                // 4.2 접속부 헌치 철근위치 ray 원본
                const connDistrInRayPts = [];

                for ( let i=0; i < connDistrInRotPts.length; i++ ) {

                    // raycast
                    const raycast = new THREE.Raycaster();
                    raycast.set( connDistrInRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                    const intersect = raycast.intersectObject( innerAreaExtr );
                    
                    connDistrInRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                }            

                // 4.3 point를 합쳐줌
                const connDistrInConvexArr = [ ...psgeDistrInRotPts, ...connDistrInRayPts ];
        
                // 4.4 convex로 모델링
                const connDistrInConvexGeo = new ConvexGeometry( connDistrInConvexArr );
                const connDistrInConvexMat = new THREE.MeshStandardMaterial( {color: 'beige', opacity: 0.9, transparent: true, side : THREE.DoubleSide } );
                const connDistrInConvexMesh = new THREE.Mesh( connDistrInConvexGeo, connDistrInConvexMat );

                // 4.5 CSG.subtract
                const connDistrInCsg = new CSG();
                connDistrInCsg.subtract( [ connDistrInConvexMesh, innerCutExtr ] ); // 맨 앞에 메쉬를 자름, 다음에 오는 메쉬는 사용도구
                const connDistrInMesh = connDistrInCsg.toMesh();
                // showContainer.push( connDistrInMesh );



                // 5. 연결통로-접속부 배력철근 내측 모델링
                arrayDistrInRev1( psgeDistrOutLtShp, psgeDistrInExtr, connDistrInLtShp, 1, distrInLtExtr, 0 ); // 좌측, 방향( 반시계 : 1), center( 포함 : 0 )
                arrayDistrInRev1( psgeDistrOutRtShp, psgeDistrInExtr, connDistrInRtShp, -1, distrInLtExtr, 1 ); // 우측, 방향( 시계 : -1), center( 미포함 : 1 )

                function arrayDistrInRev1( path, psgeInMesh, connDistrInShp, direction, rayDistrExtr, center ) { 
                // ( 배력기준선, 연결통로내측메쉬, 접속부배력경로, 방향, ray본선원본메쉬, 센터포함여부(0:OK, 1:No) )

                    // 5.1 배력철근 위치결정
                    const psgeStartPts = []; // 연결통로 내측
                    const psgeConnPts = []; // 연결통로-본선 접속부 
                    const psgeAnchPts = []; // 본선 접속부 정착장             
                    
                    const tanValue = [];

                    for ( let i=0; i*ui.psgeDistrSpacing < path.getLength(); i++ ) {
                        
                        // 길이로 나누기
                        const segment = path.getPointAt( i*ui.psgeDistrSpacing / path.getLength() );
                        const tangent = path.getTangentAt( i*ui.psgeDistrSpacing / path.getLength() );

                        // raycast
                        const raycast = new THREE.Raycaster();

                        raycast.set( new THREE.Vector3( segment.x, segment.y, 0 ), new THREE.Vector3( direction * -tangent.y, direction * +tangent.x, 0 ).normalize() ); 
                        const intersect = raycast.intersectObject( psgeInMesh );

                        // 연결통로 내측
                        psgeStartPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y ) );

                    }

                    for ( let i=0; i< psgeStartPts.length ; i++ ) { 

                        // 갯수로 나누기
                        const segment = connDistrInShp.getPointAt( i/(psgeStartPts.length-1) );
                        const tangent = connDistrInShp.getTangentAt( i/(psgeStartPts.length-1) );
                        tanValue.push( new THREE.Vector3( tangent.x, tangent.y, 0 ) );
                    
                        // 연결통로-본선 접속부 
                        psgeConnPts.push( new THREE.Vector3( segment.x, segment.y ) );

                        // 본선 접속부 정착장 포인트
                        psgeAnchPts.push( new THREE.Vector3( segment.x + 0.1*direction*tangent.y, segment.y - 0.1*direction*tangent.x ) );                    

                    }

                    // showPts( psgeStartPts, 'cadetblue' )
                    // showPts( psgeConnPts, 'cyan' )

                    // 5.2 배력철근 포인트 위치 이동
                    const psgeStartRotPts = psgeStartPts.map( i => psgePositionSet(i) );
                    const psgeConnRotPts = psgeConnPts.map( i => psgePositionSet(i) );
                    const psgeAnchRotPts = psgeAnchPts.map( i => psgePositionSet(i) );  
                    const psgeEndRotPts = psgeStartRotPts.map( i => i.clone().applyMatrix4( matrix.makeTranslation( -netReinforceL, 0, 0 ) ) );

                    // 5.3 접속부 철근위치 ray 원본
                    const psgeConnRayPts = [];

                    for ( let i=0; i < psgeConnRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        raycast.set( psgeConnRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                        const intersect = raycast.intersectObject( innerAreaExtr );
                        
                        psgeConnRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 5.4 접속부 철근위치 ray 보정
                    const psgeConnRayPts22 = [];

                    for ( let i=0; i < psgeConnRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( psgeConnRayPts[i].x - psgeStartRotPts[i].x, psgeConnRayPts[i].y - psgeStartRotPts[i].y, psgeConnRayPts[i].z - psgeStartRotPts[i].z ).normalize();
                        raycast.set( psgeStartRotPts[i], normalize );
                        const intersect = raycast.intersectObject( rayDistrExtr );
                        
                        psgeConnRayPts22.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 5.5 정착길이 ray 원본
                    const psgeAnchRayPts = [];

                    for ( let i=0; i < psgeAnchRotPts.length; i++ ) {

                        // raycast
                        const raycast = new THREE.Raycaster();
                        raycast.set( psgeAnchRotPts[i], new THREE.Vector3( 1, 0, 0 ).normalize() );
                        const intersect = raycast.intersectObject( rayDistrExtr );
                        
                        psgeAnchRayPts.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) );

                    }

                    // 5.6 정착길이 ray 보정
                    const psgeAnchRayPts22 = [];

                    for ( let i=0; i < psgeAnchRayPts.length; i++ ) {

                        const v1 = psgeConnRayPts22[i].clone();
                        const v2 = psgeAnchRayPts[i].clone();
                        const v3 = new THREE.Vector3();
                        const len = psgeAnchorRebarL;

                        // v3.subVectors( v2, v1 ).multiplyScalar( 1 + ( len / v3.length() ) ).add( v1 );

                        v3.subVectors( v2, v1 ).normalize ().multiplyScalar( len ).add( v1 );

                        psgeAnchRayPts22.push( v3 );

                    }

                    // 5.7.1 접속부 헌치 1/4점
                    const oneQuarterPts = [];

                    for ( let i=0; i < psgeStartRotPts.length; i++ ) {

                        const oneQuarter = new THREE.Vector3()
                        oneQuarter.lerpVectors( psgeStartRotPts[i], psgeConnRayPts22[i], 1/4 )
                        
                        oneQuarterPts.push( oneQuarter );
                        
                    }

                    // 5.7.2 접속부 헌치 2/4점
                    const twoQuarterPts = [];

                    for ( let i=0; i < psgeStartRotPts.length; i++ ) {
                        
                        twoQuarterPts.push( new THREE.Vector3().lerpVectors( psgeStartRotPts[i], psgeConnRayPts22[i], 2/4 ) );

                    }


                    // 5.7.3 접속부 헌치 3/4점
                    const threeQuarterPts = [];

                    for ( let i=0; i < psgeStartRotPts.length; i++ ) {
                        
                        threeQuarterPts.push( new THREE.Vector3().lerpVectors( psgeStartRotPts[i], psgeConnRayPts22[i], 3/4 ) );

                    }

                    // 5.8.1 접속부 헌치 1/4점 ray 
                    const oneQuarterPtsRay = [];
                    for ( let i=0; i < oneQuarterPts.length; i++ ) {
                        
                        // raycast
                        // clock false, Left = out ( y, -x ), In ( -y, x );
                        // clock true, Right = out ( -y, x ), In ( y, -x );
                        // intersectObject = type : mesh, no line;
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( 0, direction*-tanValue[i].x, direction*tanValue[i].y ).normalize(); // x값 => z값
                        raycast.set( oneQuarterPts[i], normalize );
                        const intersect = raycast.intersectObject( connDistrInMesh );

                        if ( intersect.length != 0 ) {
                        
                            // Out
                            oneQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        } else {
                            
                            // In
                            const normalize2 = new THREE.Vector3( 0, direction*tanValue[i].x, direction*-tanValue[i].y ).normalize(); // x값 => z값
                            raycast.set( oneQuarterPts[i], normalize2 );
                            const intersect = raycast.intersectObject( connDistrInMesh );
                            oneQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        }
                        
                    }

                    // showPts( oneQuarterPtsRay, 'green')

                    // 5.8.2 접속부 헌치 2/4점 ray 
                    const twoQuarterPtsRay = [];
                    for ( let i=0; i < twoQuarterPts.length; i++ ) {
                        
                        // raycast
                        // clock false, Left = out ( y, -x ), In ( -y, x );
                        // clock true, Right = out ( -y, x ), In ( y, -x );
                        // intersectObject = type : mesh, no line;
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( 0, direction*-tanValue[i].x, direction*tanValue[i].y ).normalize(); // x값 => z값
                        raycast.set( twoQuarterPts[i], normalize );
                        const intersect = raycast.intersectObject( connDistrInMesh );

                        if ( intersect.length != 0 ) {
                        
                            // Out
                            twoQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        } else {
                            
                            // In
                            const normalize2 = new THREE.Vector3( 0, direction*tanValue[i].x, direction*-tanValue[i].y ).normalize(); // x값 => z값
                            raycast.set( twoQuarterPts[i], normalize2 );
                            const intersect = raycast.intersectObject( connDistrInMesh );
                            twoQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        }
                        
                    }

                    // showPts( twoQuarterPtsRay, 'green')

                    // 5.8.3 접속부 헌치 3/4점 ray 
                    const threeQuarterPtsRay = [];
                    for ( let i=0; i < threeQuarterPts.length; i++ ) {
                        
                        // raycast
                        // clock false, Left = out ( y, -x ), In ( -y, x );
                        // clock true, Right = out ( -y, x ), In ( y, -x );
                        // intersectObject = type : mesh, no line;
                        const raycast = new THREE.Raycaster();
                        const normalize = new THREE.Vector3( 0, direction*-tanValue[i].x, direction*tanValue[i].y ).normalize(); // x값 => z값
                        raycast.set( threeQuarterPts[i], normalize );
                        const intersect = raycast.intersectObject( connDistrInMesh );

                        if ( intersect.length != 0 ) {
                        
                            // Out
                            threeQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        } else {
                            
                            // In
                            const normalize2 = new THREE.Vector3( 0, direction*tanValue[i].x, direction*-tanValue[i].y ).normalize(); // x값 => z값
                            raycast.set( threeQuarterPts[i], normalize2 );
                            const intersect = raycast.intersectObject( connDistrInMesh );
                            threeQuarterPtsRay.push( new THREE.Vector3( intersect[0].point.x, intersect[0].point.y, intersect[0].point.z ) ); 

                        }
                        
                    }

                    // showPts( threeQuarterPtsRay, 'green')

                    // 5.9 접속부 헌치 배력철근 배치
                    for ( let i=center; i < psgeStartRotPts.length; i++ ) {
                        
                        const haunchDistrPath = new THREE.CurvePath();
                        const p1 = psgeEndRotPts[i]
                        const p2 = psgeStartRotPts[i]
                        const p3 = oneQuarterPtsRay[i]
                        const p4 = twoQuarterPtsRay[i]
                        const p5 = threeQuarterPtsRay[i]
                        const p6 = psgeConnRayPts22[i]
                        const p7 = psgeAnchRayPts22[i]

                        const L1 = new THREE.LineCurve3( p1, p2 );
                        const L2 = new THREE.LineCurve3( p2, p3 );
                        const L3 = new THREE.LineCurve3( p3, p4 );
                        const L4 = new THREE.LineCurve3( p4, p5 );
                        const L5 = new THREE.LineCurve3( p5, p6 );
                        const L6 = new THREE.LineCurve3( p6, p7 );

                        haunchDistrPath.add( L1 );
                        haunchDistrPath.add( L2 );
                        haunchDistrPath.add( L3 );
                        haunchDistrPath.add( L4 );
                        haunchDistrPath.add( L5 );
                        haunchDistrPath.add( L6 );

                        // 배력철근 형상 distr Rebar, 
                        const main1Shp = new THREE.Shape()
                            .absarc( 0, 0, ui.psgeDistrDia/2, 0, Math.PI * 2, false );

                        const haunchDistrSweep = addSweep( main1Shp, 'navy', haunchDistrPath, 1 );
                        showContainer.push( haunchDistrSweep )

                        // 철근 길이
                        // console.log( haunchDistrPath.cacheLengths[haunchDistrPath.cacheLengths.length-1] )
                        
                    }

                    // for ( let i=0; i<psgeStartRotPts.length; i++ ) {
                    //     const points = [];
                    //     points.push( psgeStartRotPts[i] );
                    //     points.push( psgeConnRayPts[i] );

                    //     const geometry = new THREE.BufferGeometry().setFromPoints( points );

                    //     const line = new THREE.Line( geometry, new THREE.LineBasicMaterial({color: 'navy'}) );
                    //     showContainer.push( line );

                    // }

                }

            }


            // scene 생성
            showContainer.forEach( mesh => { scene.add( mesh ) });

            // 결과값 저장
            sessionStorage.setItem('적용편경사', JSON.stringify( ui.crossSlopeStandard ) );

            // 시간측정
            console.log( '연산시간: ' + ((new Date()).getTime() - start_time) + 'ms' );
            //

            // 로딩스피너 숨기기
            hideLoading();

        }


        function createUI() {

            // onFinishChange 적용
            const gui = new GUI();
            
            const commonFolder = gui.addFolder( '공통' )
            commonFolder.add( ui, 'crossSlopeStandard', crossSlopeMin, crossSlopeMax, 0.050 ).name( '적용 편경사' ).onFinishChange( designTunnel );
            commonFolder.add( ui, 'totalLength', 16, 40, 0.1 ).name( '적용 연장' ).onFinishChange( designTunnel );

            const crossPsgeTypeFolder = gui.addFolder( '구분' )
            crossPsgeTypeFolder.add( ui, 'crossPsgeType', [ '대인용', '차량용', '대형차량용' ] ).name( '연결통로 타입' ).onFinishChange( designTunnel );
            crossPsgeTypeFolder.add( ui, 'category', [ '일반도', '보강도', '구조도' ] ).name( '카테고리' ).onFinishChange( categoryDetail );
            crossPsgeTypeFolder.open();
            
            // const crossPassageFolder = gui.addFolder( '접속각도' )
            // crossPassageFolder.add( ui, 'verticalAngle', -9, 9, 0.05 ).name( '연직각도' ).onFinishChange( designTunnel );
            // crossPassageFolder.add( ui, 'horizontalAngle', -9, 9, 0.05 ).name( '수평각도' ).onFinishChange( designTunnel );

            const clippingFolder = gui.addFolder( '절단면' )
            const props = { 
                get '생성'() {
                    return renderer.localClippingEnabled;
                },
                set '생성'(v) {
                    renderer.localClippingEnabled = v;
                },
                get '위치'() {
                    return clippingPlane.constant;
                },
                set '위치'( v ) {
                    clippingPlane.constant = v;
                }
            }
            clippingFolder.add( props, '생성' );
            clippingFolder.add( props, '위치', -3, 10 );

            const tunnelSupportFolder = gui.addFolder( '본선지보' );
            tunnelSupportFolder.add( ui, 'longSpacing', 1.000, 4.000, 0.100 ).name( '굴진장/지보장' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'shotcrete', 0.050, 0.300, 0.010 ).name( '숏크리트 두께' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'rbZone', [ '없음', '전단면' ] ).name( '록볼트 보강영역' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'rbLength', 3.000, 6.000, 1.000 ).name( '록볼트 길이' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'rbCircSpacing', 1.000, 4.000, 0.100 ).name( '록볼트 횡간격' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'rbLtLastDel').name( '좌측하단 삭제' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'rbRtLastDel').name( '우측하단 삭제' ).onFinishChange( designTunnel );
            tunnelSupportFolder.add( ui, 'steelribType', [ '없음', 'LG-50', 'LG-70', 'LG-95', 'H-100', 'H-125', 'H-150' ] ).name( '강지보공' ).onFinishChange( designTunnel );

            const crossPageSupportFolder = gui.addFolder( '연결통로지보' );
            crossPageSupportFolder.add( ui, 'psgeLongSpacing', 1, 3, 0.1).name( '굴진장/지보장').onFinishChange( designTunnel );
            crossPageSupportFolder.add( ui, 'psgeShotcrete', 0.050, 0.300, 0.010 ).name( '숏크리트 두께').onFinishChange( designTunnel );
            crossPageSupportFolder.add( ui, 'psgeRbZone', [ '없음', '전단면' ] ).name( '록볼트 보강영역').onFinishChange( designTunnel );
            crossPageSupportFolder.add( ui, 'psgeRbLength', 3.000, 6.000, 1.000 ).name( '록볼트 길이').onFinishChange( designTunnel );
            crossPageSupportFolder.add( ui, 'psgeRbCircSpacing', 1.000, 4.000, 0.100 ).name( '록볼트 횡간격').onFinishChange( designTunnel );
            crossPageSupportFolder.add( ui, 'psgeSteelribType', [ '없음', 'LG-50', 'LG-70', 'LG-95', 'H-100', 'H-125', 'H-150' ] ).name( '강지보공' ).onFinishChange( designTunnel );

            const psgeMainFolder = gui.addFolder( '연결통로 주철근' );
            psgeMainFolder.add( ui, 'psgeMainCompDia', { H13 : 0.013, H16 : 0.016, H19 : 0.019, H22 : 0.022, H25 : 0.025, H29 : 0.029, H32 : 0.032 } ).name( '직경1(빨강)' ).onChange( designTunnel );
            psgeMainFolder.add( ui, 'psgeMainTensDia', { H13 : 0.013, H16 : 0.016, H19 : 0.019, H22 : 0.022, H25 : 0.025, H29 : 0.029, H32 : 0.032 } ).name( '직경2(파랑)' ).onChange( designTunnel );
            psgeMainFolder.add( ui, 'psgeOutMaxLen', 6.000, 12.000, 1.000 ).name( '외측 장철근길이' ).onChange( designTunnel );
            psgeMainFolder.add( ui, 'psgeInMaxLen', 6.000, 12.000, 1.000 ).name( '내측 장철근길이' ).onChange( designTunnel );
            psgeMainFolder.add( ui, 'psgeLap', 0.300, 1.500, 0.010 ).name( '겹이음길이' ).onChange( designTunnel );
            psgeMainFolder.add( ui, 'psgeCtc', 0.100, 0.400, 0.005 ).name( '종간격' ).onChange( designTunnel );
            // psgeMainFolder.add( ui, 'outControl', 0.100, 0.900, 0.001 ).name( '외측위치조절' ).onChange( designTunnel );
            // psgeMainFolder.add( ui, 'inControl', 0.100, 0.900, 0.001 ).name( '내측위치조절' ).onChange( designTunnel );


            const psgeDistrFolder = gui.addFolder( '연결통로 배력철근' );
            psgeDistrFolder.add( ui, 'psgeDistrDia', { H13 : 0.013, H16 : 0.016, H19 : 0.019, H22 : 0.022, H25 : 0.025, H29 : 0.029, H32 : 0.032 } ).name( '직경' ).onChange( designTunnel );
            psgeDistrFolder.add( ui, 'psgeDistrSpacing', 0.100, 0.400, 0.050 ).name( '횡간격' ).onChange( designTunnel );

            tunnelSupportFolder.hide();
            crossPageSupportFolder.hide();
            psgeMainFolder.hide();
            psgeDistrFolder.hide();
            
            function categoryDetail() {

                if( ui.category == '일반도') {

                    tunnelSupportFolder.hide();
                    crossPageSupportFolder.hide();
                    psgeMainFolder.hide();
                    psgeDistrFolder.hide();
                    designTunnel();

                } else if ( ui.category == '보강도') {

                    tunnelSupportFolder.show();
                    crossPageSupportFolder.show();                    
                    psgeMainFolder.hide();
                    psgeDistrFolder.hide();
                    designTunnel();

                } else if ( ui.category == '구조도') {

                    tunnelSupportFolder.hide();
                    crossPageSupportFolder.hide();
                    psgeMainFolder.show();
                    psgeDistrFolder.show();
                    designTunnel();

                }

            }

        }
        


        function addLine( shape, color ) {
            const points = shape.getPoints( 1000 ); // 곡선에서 raycast점을 찾기 위해
            const lineGeo = new THREE.BufferGeometry().setFromPoints( points );
            const lineMat = new THREE.LineBasicMaterial( { color } );
            const line = new THREE.Line( lineGeo, lineMat );
            // line.castShadow = true;
            return line;
        }

        function addDashLine( shape, color ) {
            const points = shape.getPoints();
            const lineGeo = new THREE.BufferGeometry().setFromPoints( points );
            const lineMat = new THREE.LineDashedMaterial( { color , dashSize: 0.2, gapSize: 0.05 } );
            const line = new THREE.Line( lineGeo, lineMat );
            // line.castShadow = true;
            line.computeLineDistances(); //점선으로 만들어주기 위해 필요
            return line;
        }

        function addSurf( shape, color, opacity ) {
            const surfGeo = new THREE.ShapeGeometry( shape, 100 );
            const surfMat = new THREE.MeshBasicMaterial( { color, opacity: 0.7, transparent: true, side: THREE.DoubleSide } );
            const mesh = new THREE.Mesh( surfGeo, surfMat );
            return mesh;
        }
        
        function addExtr( shape, color, length, opacity ) {            
            const extrudeSettings = {
                steps : 1,
                // curveSegments : 12, // 기본값
                depth : length,
                bevelEnabled : false,
            }           
            const extrudeGeo = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );
            const extrudeMat = new THREE.MeshStandardMaterial( { color, opacity, transparent: true, side : THREE.DoubleSide, clippingPlanes: [ clippingPlane ] } );
            const mesh = new THREE.Mesh( extrudeGeo, extrudeMat ) ;
            return mesh;
        }

        function addExtrHD( shape, color, length, opacity ) {            
            const extrudeSettings = {
                steps : 1,
                curveSegments : 24,
                depth : length,
                bevelEnabled : false,
            }           
            const extrudeGeo = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );
            const extrudeMat = new THREE.MeshStandardMaterial( { color, opacity, transparent: true, side : THREE.DoubleSide, clippingPlanes: [ clippingPlane ] } );
            const mesh = new THREE.Mesh( extrudeGeo, extrudeMat ) ;
            return mesh;
        }

        function addArr ( path ) {
            const arr = [];
            for ( let i=0; i*0.01 <= path.getLength(); i++) {
                const segment = path.getPointAt( i*0.01 / path.getLength() );
                arr.push( new THREE.Vector3( segment.x, segment.y, 0 ) );
            }
            return arr
        }

        function addPath ( arr ) {
            const curvePath = new THREE.CurvePath();
            for ( let i=0; i < arr.length-1; i++ ) {
                const point1 = new THREE.Vector3( arr[i].x, arr[i].y, arr[i].z );
                const point2 = new THREE.Vector3( arr[i+1].x, arr[i+1].y, arr[i+1].z );
                const line = new THREE.LineCurve3( point1, point2 );
                curvePath.add( line )
            }
            return curvePath
        }

        function addSweep( shape, color, path, opacity ) {
            const extrudeSettings = {
                steps : 100, 
                extrudePath : path
            }
            const extrudeGeo = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );
            const extrudeMat = new THREE.MeshStandardMaterial( { color, opacity, transparent: true } );
            const mesh = new THREE.Mesh( extrudeGeo, extrudeMat ) ;
            return mesh;
        }

        function showPts( arr, color ) {
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints( arr );            
            const pointsMaterial = new THREE.PointsMaterial( { color, size: 7 } );
            const points = new THREE.Points( pointsGeometry, pointsMaterial );
            showContainer.push( points );
        }




        function rbDraw( path, spacing, direction, rockboltGeometry, rockboltMaterial, container ) {

            for ( let i=1; i * spacing <= path.getLength(); i++) {

                const segment = path.getPointAt( i * spacing / path.getLength() );
                const tangent = path.getTangentAt( i * spacing / path.getLength() );

                const angle = Math.atan2( tangent.y*direction, tangent.x*direction );

                const rbMesh = new THREE.Mesh( rockboltGeometry, rockboltMaterial );
                rbMesh.rotation.x = Math.PI/2;
                
                const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                blockSystem.add( rbMesh );

                blockSystem.position.set ( segment.x, segment.y, 0);
                blockSystem.rotation.z = angle;

                container.push( blockSystem );

            }

        }        

        function installAngle ( url, path, direction ) { 
                    
            const group = new THREE.Group();

            loader.load( url, function ( gLeft ) {

                gLeft.scene.traverse( function( node ) {
                    if ( node instanceof THREE.Mesh ) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                } );
            
                const mesh = gLeft.scene;
                const newMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide, color : 'crimson', opacity : 0.9, transparent: true } );

                mesh.traverse( (o) => { if ( o.isMesh ) o.material = newMaterial } );

                if ( path != undefined ) {

                    const segment = path.getPointAt( 0 ); 

                    const tangent = path.getTangentAt( 0 );
                    const angle = Math.atan2( direction * tangent.y, direction * tangent.x) 
                    
                    mesh.position.set ( segment.x, segment.y, 0 );
                    mesh.rotation.z = angle;
                    
                    group.add( mesh );

                }
                
            } );

            return group

        }

        function installSpider ( url, path, direction ) { 

            const group = new THREE.Group();

            const blockSpacing = 0.3
            
            loader.load( url, function ( gLeft ) {

                gLeft.scene.traverse( function( node ) {
                    if ( node instanceof THREE.Mesh ) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                } )
                
                const mesh = gLeft.scene;
                
                if ( path != undefined ) {

                    for ( let k=1; k*blockSpacing <= (path.getLength() - 0.120 ); k++ ) {
                        // 마지막에 걸리는 스파이더를 빼주기 위해 0.12m 정도 길에서 빼줌
                        const segment = path.getPointAt( k*blockSpacing / path.getLength() ); 

                        const tangent = path.getTangentAt( k*blockSpacing / path.getLength() );
                        const angle = Math.atan2( direction * tangent.y, direction * tangent.x );
                        
                        const meshClone = mesh.clone()

                        meshClone.position.set ( segment.x, segment.y, 0 );
                        meshClone.rotation.z = angle;
                        
                        group.add( meshClone );

                    } 

                }
                
            } );

            return group

        }

        function installCoupler ( url, path, direction ) { 
            
            const group = new THREE.Group();

            const blockSpacing = 0.750;
            
            loader.load( url, function ( gLeft ) {

                gLeft.scene.traverse( function( node ) {
                    if ( node instanceof THREE.Mesh ) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                } );
                
                const mesh = gLeft.scene;
                const newMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide,  color : 'deeppink', opacity : 0.9, transparent: false } );

                mesh.traverse((o) => { if ( o.isMesh ) o.material = newMaterial });
                
                for ( let k=1; (2 * k - 1)*blockSpacing <= path.getLength(); k++) {
                    const segment = path.getPointAt( (2 * k - 1)*blockSpacing / path.getLength() ); 

                    const tangent = path.getTangentAt( (2 * k - 1)*blockSpacing / path.getLength() );
                    const angle = Math.atan2( direction * tangent.y, direction * tangent.x );

                    const meshClone = mesh.clone();
                                        
                    meshClone.position.set ( segment.x, segment.y, 0 );
                    meshClone.rotation.z = angle;
                    
                    group.add( meshClone );

                }
                        
            } );
            
            return group

        }        

        function installPlate ( size, move, path ) {    

            const group = new THREE.Group();

            const plateGeo = new THREE.BoxGeometry( size, 0.010, size );
            const plateMat = new THREE.MeshStandardMaterial( {color: 'cadetblue'} );
            const plateMesh = new THREE.Mesh( plateGeo, plateMat );
            plateMesh.position.set( path.getPointAt(1).x , path.getPointAt(1).y, 0 );
            plateMesh.applyMatrix4( matrix.makeTranslation( move, 0.005, 0 ) );
            group.add( plateMesh );

            return group
            
        }

        function installReinForceRB ( path, direction, offset ) {

            const group = new THREE.Group();

            for ( let i=0; i<3; i++) {

                const initSpacing = 0.5;
                const spacing = 0.6;

                // 단부에서 초기에 0.3m 띄우고, 이후 0.6 간격으로 띄움
                const segment = path.getPointAt( ( path.getLength() - initSpacing - i * spacing ) / path.getLength() );
                const tangent = path.getTangentAt( ( path.getLength() - initSpacing - i * spacing ) / path.getLength() );

                const angle = Math.atan2( tangent.y*direction, tangent.x*direction );

                // 록볼트 제원
                const rockboltShp = new THREE.Shape();
                rockboltShp.absarc( 0, 0, 0.025/2, 0, Math.PI * 2, false );

                const rbGeo = new THREE.ExtrudeBufferGeometry( rockboltShp, { steps : 1, depth : ui.rbLength,  bevelEnabled : false} );
                const rbmat = new THREE.MeshStandardMaterial( {color: 'purple'} );

                const rbMesh = new THREE.Mesh( rbGeo, rbmat );
                rbMesh.rotation.x = -Math.PI/2;

                const rbMeshClone = rbMesh.clone();

                rbMesh.position.set( 0, -offset, -0.15);
                rbMeshClone.position.set( 0, -offset, 0.15);

                const plateGeo = new THREE.BoxGeometry( 0.200, 0.016, 0.500 );
                const plateMat = new THREE.MeshStandardMaterial( {color: 'navy'} );
                const plateMesh = new THREE.Mesh( plateGeo, plateMat );
                plateMesh.position.set( 0, -0.008 -offset, 0);

                const blockSystem = new THREE.Object3D();  // 빈 객체에 회전된 객체를 넣음, 캐드에서 블록을 만드는 개념
                blockSystem.add( plateMesh );
                blockSystem.add( rbMesh );
                blockSystem.add( rbMeshClone );

                blockSystem.position.set ( segment.x, segment.y, 0);
                blockSystem.rotation.z = angle;

                group.add( blockSystem );

            }

            return group

        }

        function onKeyDown( event ) {

            switch ( event.keyCode ) {

                case 82: /*R*/

                    moveCam( 40, 0, 0, 0, 0, 0 );

                    break;

                case 70: /*F*/

                    moveCam( 0, 0, 100, 0, 0, 0 );

                    break;

            }

        }

        function moveCam(eye_x, eye_y, eye_z, target_x, target_y, target_z ) {
            camera.position.set ( eye_x, eye_y, eye_z );
            orbitControls.target.set( 0, 0, 0 );
        }
        // moveCam( -40, 0, 0, 0, 0, 0 )

        

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            
            return needResize;
        }
        
        function render() {
            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }


            // 

            
            renderer.renderLists.dispose();
            renderer.render(scene, camera);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);




        // export STL        
        function exportFile() {

            const result = exporter.parse( scene, { binary: true } );
            saveArrayBuffer( result, '연결통로.stl' );
            
        };

        const exporter = new STLExporter();
        document.getElementById("button").addEventListener("click", exportFile);

        const link = document.createElement( 'a' );
        link.style.display = 'none';
        document.body.appendChild( link );

        function save( blob, filename ) {

            link.href = URL.createObjectURL( blob );
            link.download = filename;
            link.click();

        }

        function saveString( text, filename ) {

            save( new Blob( [ text ], { type: 'text/plain' } ), filename );

        }

        function saveArrayBuffer( buffer, filename ) {

            save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

        } 

        
    </script>
    
</body>

</html>
