<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>한맥가족 클라우드센터</title>
    <style>
        html, body {
            margin : 0;
            height : 100%;
            font-size : 10px;
            background: linear-gradient(to bottom,  #cadff3 0%,#f0e3e4 100%);
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            /* left : 50%; */
            padding: 10px;
            /* transform : translate( -50% ); */
            /* text-align: center; */
            background: rgba( 0, 0, 0, 0 );
            color: black;
            font-size: 1.2rem;
        } 


        /* obit-controls */
        .obit-controls-gizmo {
            position: absolute;
            top: 2em;
            right: 2em;
            z-index: 1000;
            background-color: #FFF0;
            border-radius: 100%;
            transition: background-color .15s  linear;
            cursor: pointer;
        }

        .obit-controls-gizmo.dragging, 
        .obit-controls-gizmo:hover {
            background-color: #FFF3;
        }

        .obit-controls-gizmo.inactive {
            pointer-events: none;
            background-color: #FFF0  !important;
        }


        /* bottom btn-Group */
        .btn-container {
            width : 100%;
            position : absolute;
            bottom : 0;
            margin-bottom: 3.0rem;
        }

        .btn-group button {
            justify-content: space-between;
            width: 25%;
            /* background-color: #555;  */
            background-color: transparent; 
            border-style: hidden;
            color: black;
            padding: 2.4rem 0;
            cursor: pointer;
            float: left; /* Float the buttons side by side */
            text-align: center;
            font-size: 3.6rem;
        }

        .btn-group button:not(:last-child) {
            border-right: none; /* Prevent double borders */
        }

        .btn-group:after { /* Clear floats (clearfix hack) */
            content: "";
            clear: both;
            display: table;
        }

        .btn-group button:hover {
            background-color: rgb(170, 170, 170);
        }


        /* offcanvas */
        .offcanvasBottom {
            height: 0%;
            width: 100%;
            position: fixed;
            z-index: 10001;
            /* top: 0; */
            bottom : 0;
            left: 0;
            color:white; 
            background-color: rgba( 29, 49, 45, 0.5 );
            overflow-x: hidden;
            transition: 0.3s;
            padding-left : 3.0rem;
            /* padding-top: 30px; */
        }

        .offcanvasBottom a {
            padding: 0.8rem 0.8rem 0.8rem 0.8rem;
            text-decoration: none;
            font-size: 3.6rem;
            color: white;
            display: block;
            transition: 0.3s;
        }

        .offcanvasBottom a:hover {
            color: #f1f1f1;
        }

        .offcanvasBottom .closebtn {
            position: absolute;
            top: 1.0rem;
            right: 2.5rem;
            font-size: 3.6rem;
            margin-right: 3.0rem;
        }

        @media screen and (max-height: 450px) {
            .offcanvasBottom {padding-top: 15px;}
            .offcanvasBottom a {font-size: 18px;}
        }
        

        /* btnNeg */
        .btnNeg {
            border: 0.2rem solid #EB530C;
            background-color: transparent;
            color: #EB530C;
            padding: 0.0rem 2.8rem;
            font-size: 3.6rem;
            cursor: pointer;
        }


        /* slider */
        .slidecontainer {
            width: 60%; /* Width of the outside container */
        }

        .slider {
            -webkit-appearance: none;  /* Override default CSS styles */
            appearance: none;
            display:flex;
            width: 85%; /* Full-width */
            border-radius: 2.0rem;
            /* border: none; */
            margin-left: 5%;
            height: 1.0rem; /* Specified height */
            background: white; /* Grey background */
            outline: none; /* Remove outline */
            opacity: 1.0; /* Set transparency (for mouse-over effects on hover) */
            -webkit-transition: .2s; /* 0.2 seconds transition on hover */
            transition: opacity .2s;
        }

        .slider:hover {
            opacity: 1.0; /* Fully shown on mouse-over */
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; /* Override default look */
            appearance: none;
            border-radius: 50%;
            width: 3.6rem; /* Set a specific slider handle width */
            height: 3.6rem; /* Slider handle height */
            background: #EB530C; /* Green background */
            cursor: pointer; /* Cursor on hover */
        }

        .slider::-moz-range-thumb {
            width: 3.6rem; /* Set a specific slider handle width */
            height: 3.6rem; /* Slider handle height */
            border-radius: 50%;
            background: #EB530C; /* Green background */
            cursor: pointer; /* Cursor on hover */
        }


        /* toggle */
        .switch {
            position: relative;
            display: inline-block;
            width: 6.0rem;
            height: 3.6rem;
        }

        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch-label {
            position: relative;
            left: 10rem;
            /* top: 10%; */
            width: 40rem
        }

        .toggle {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .2s;
            transition: .2s;
        }

        .toggle:before {
            position: absolute;
            content: "";
            height: 2.6rem;
            width: 2.6rem;
            left: 0.4rem;
            bottom: 0.4rem;
            background-color: white;
            -webkit-transition: .2s;
            transition: .2s;
        }

        input:checked + .toggle {
            background-color: #EB530C;
        }

        input:focus + .toggle {
            box-shadow: 0 0 0.1rem #EB530C;
        }

        input:checked + .toggle:before {
            -webkit-transform: translateX(2.6rem);
            -ms-transform: translateX(2.6rem);
            transform: translateX(2.6rem);
        }

        .toggle.round {
            border-radius: 3.4rem;
        }

        .toggle.round:before {
            border-radius: 50%;
        }

    </style>
</head>
<body>

    <!-- Add icon library -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <div style="position:absolute; top: 0; left: 0.8rem; color:black; font-size: 1.8rem; font-weight: bold">HanmacFamily Cloudcenter</div>

    <div class="btn-container btn-group ">
        <button id="btn1">
            <!-- <i class="fa fa-square-o" aria-hidden="true"></i> -->
            <i class="fa fa-adjust" aria-hidden="true"></i>
            <br>
            투명도
        </button>
        <button id="btn2">
            <i class="fa fa-crop" aria-hidden="true"></i>
            <br>
            절단면
        </button>
        <button id="btn3">
            <i class="fa fa-expand" aria-hidden="true"></i>
            <br>
            스케일
        </button>
        <button id="btn4"> 
            <i class="fa fa-ellipsis-h" aria-hidden="true"></i> 
            <br>
            더보기
        </button>
    </div>

    <!-- 오프캔버스 -->
    <div class="offcanvasBottom" id="myoffcanvasBottom1" style="font-size: 3.6rem; line-height:0.9">
        <a href="javascript:void(0)" class="closebtn" id="close1" >&times;</a>
        <br>
        <div >Opacity : 
            <span id="opacityValue"></span>
        </div>
        <br>
        <input type="range" class="slider" id="opacityId" min="0" max="1" step="0.05" value="1">
    </div>


    <div class="offcanvasBottom" id="myoffcanvasBottom2" style="font-size: 3.6rem; line-height:0.9">
        <a href="javascript:void(0)" class="closebtn" id="close2">&times;</a>
        <br>
        <div>X방향 : <button id="negateX" class="btnNeg">반전</button></div>
        <br>
        <input type="range" class="slider" id="clippingXId">
        <span style="line-height:1.5"><br></span>
        <div>Y방향 : <button id="negateY" class="btnNeg">반전</button></div>
        <br>
        <input type="range" class="slider" id="clippingYId">
        <span style="line-height:1.5"><br></span>
        <div>Z방향 : <button id="negateZ" class="btnNeg">반전</button></div>
        <br>
        <input type="range" class="slider" id="clippingZId">
    </div>

    <div class="offcanvasBottom" id="myoffcanvasBottom3" style="font-size: 3.6rem; line-height:1.0">
        <a href="javascript:void(0)" class="closebtn" id="close3">&times;</a>
        <br>
        <div>X방향 : <span id="scaleXValue"></span></div>
        <br>
        <input type="range" class="slider" id="scaleXId" min="1" max="6" step="0.5" value="1">
        <span style="line-height:1.8"><br></span>
        <div>Y방향 : <span id="scaleYValue"></span></div>
        <br>
        <input type="range" class="slider" id="scaleYId" min="1" max="6" step="0.5" value="1">
        <span style="line-height:1.8"><br></span>
        <div>Z방향 : <span id="scaleZValue"></span></div>
        <br>
        <input type="range" class="slider" id="scaleZId" min="1" max="6" step="0.5" value="1">
    </div>

    <div class="offcanvasBottom" id="myoffcanvasBottom4" style="font-size: 3.6rem; line-height:1.2">
        <a href="javascript:void(0)" class="closebtn" id="close4">&times;</a>
        <br>
        <label class="switch">
            <div class="switch-label"> 와이어프레임 </div>
            <input type="checkbox" id="wireframeSwitch">
            <span class="toggle round"> </span>
        </label>
        <br>
        <label class="switch">
            <div class="switch-label"> 그리드 </div>
            <input type="checkbox" id="gridSwitch">
            <span class="toggle round"> </span>
        </label>
        <br>
        <label class="switch">
            <div class="switch-label"> 원근감 </div>
            <input type="checkbox" id="cameraSwitch" checked>
            <span class="toggle round"> </span>
        </label>
        <br>
        <label class="switch">
            <div class="switch-label"> 좌표축 </div>
            <input type="checkbox" id="axeSwitch">
            <span class="toggle round"> </span>
        </label>
        <br>
        <!-- <label class="switch">
            <div class="switch-label"> 자동회전 </div>
            <input type="checkbox" id="autoRotate">
            <span class="toggle round"> </span>
        </label> -->
        <div style="display: flex; ">
            배경
            <select style="margin-left:3rem; padding:1rem 1rem 1rem 1rem; font-size: 3.0rem;" id="background" style="width:30%" >
                <option value="1" >없음</option>
                <option value="2" selected>하늘색</option>
                <option value="3" >텍스쳐</option>
            </select>
        </div>
    </div>  

    <!-- <div class="fixed-bottom" style="background: #18312D; ">
        <div class="row text-center">
            <button type="button" class="col" id="button"> <div id="btn1">
                자동회전:<span id="autoRotate" style="color:sandybrown">On</span></div> </button>
        </div>
    </div> -->

    <!-- function labelChange1() {
        const x = document.getElementById("autoRotate");
        x.innerText === "On" ? x.innerText = "Off" : x.innerText = "On";
    } -->

    <!-- <div id="info">
        <b>Camera Type</b>
        <br>
        <b style="color:#2FA1D6">C : </b>Perspective/Orthographic
        <br>
        <b>Wireframe</b>
        <br>
        <b style="color:#2FA1D6">W : </b>On/Off
        <br>
        <b>Auto Rotate</b>
        <br>
        <b style="color:#2FA1D6">A : </b>On/Off
        <br>
        <b>View Mode</b>
        <br>
        <b style="color:#2FA1D6">F : </b>Front, <b style="color:#2FA1D6">B : </b>Back, <b style="color:#2FA1D6">R : </b>Right, <b style="color:#2FA1D6">L : </b>Left, <b style="color:#2FA1D6">T : </b>Top 
    </div> -->



    <canvas id="c"></canvas>

    <script type="module">


        /* import */
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js';
        import { GLTFLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/GLTFLoader.js';
        import { RGBELoader } from 'https://Lee-hoseong.github.io/jsm/loaders/RGBELoader.js';
        import { DRACOLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/DRACOLoader.js';

        import { OrbitControls } from 'https://Lee-hoseong.github.io//ThreeOrbitControlsGizmo/OrbitControls.js';
        import { OrbitControlsGizmo  } from 'https://Lee-hoseong.github.io/ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';
        // import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';

        // import * as THREE from '/release/PIPE/source1/r131/build/three.module.js';
        // import { GLTFLoader } from '/release/PIPE/source1/r131/examples/jsm/loaders/GLTFLoader.js';
        // import { RGBELoader } from '/release/PIPE/source1/r131/examples/jsm/loaders/RGBELoader.js';
        // import { DRACOLoader } from '/release/PIPE/source1/r131/examples/jsm/loaders/DRACOLoader.js';

        // import { OrbitControls } from '/release/PIPE/source2/ThreeOrbitControlsGizmo/OrbitControls.js';
        // import { OrbitControlsGizmo  } from '/release/PIPE/source2/ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';


        /* variable */
        let camera, scene, light, renderer;
        let cameraPerspective, cameraOrtho;
        let controlsPerspective, controlsOrtho;
        let controlsGizmoPerspective, controlsGizmoOrtho;
        let box, sizeBox, centerBox, model;
        let progressBarDiv;
        let clippingPlanes, clipHelperX, clipHelperY, clipHelperZ;
        let axes, gridHelper;
        let env;


        create3DViewer();
        animate();


        function create3DViewer () {
            const canvas = document.querySelector('#c'); 
            
            /* scene */
            scene = new THREE.Scene();               
            // const vignette = createBackground({
            //     aspect: aspect,
            //     grainScale: IS_IOS ? 0 : 0.001, // mattdesl/three-vignette-background#1
            //     colors: [0xffffff, 0x353535]
            // });

            // scene.background = new THREE.Color( 0xf0f0f0 );

            /* camera */
            const aspect = window.innerWidth/window.innerHeight;
            
            cameraPerspective = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            scene.add( cameraPerspective );

            cameraOrtho = new THREE.OrthographicCamera( 
                window.innerWidth/-aspect, 
                window.innerWidth/aspect, 
                window.innerHeight/aspect, 
                window.innerHeight/-aspect, 0.1, 1000 
            );
            // cameraOrtho.zoom = 1;
            scene.add( cameraOrtho );

            camera = cameraPerspective;
            

            /* OrbitControl */
            controlsPerspective = new OrbitControls( cameraPerspective, canvas );
            controlsPerspective.autoRotate = false;
            controlsPerspective.autoRotateSpeed = -3;
            controlsPerspective.screenSpacePanning = true;
     
            controlsOrtho = new OrbitControls( cameraOrtho, canvas );
            controlsOrtho.autoRotate = false;
            controlsOrtho.autoRotateSpeed = -3;
            controlsOrtho.screenSpacePanning = true;


            /* Gizmo */
            controlsGizmoPerspective = new OrbitControlsGizmo(controlsPerspective, { size:  100, padding:  8 });
            controlsGizmoOrtho = new OrbitControlsGizmo(controlsOrtho, { size:  100, padding:  8 });

            document.body.appendChild(controlsGizmoPerspective.domElement);
          

            /* light */
            scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );
            
            light = new THREE.DirectionalLight( 'white', 0.5 );
            light.position.set( -1, 2, 4 );
            // light.position.set( 0.5, 0, 0.866 );
            // light.target.position.set( 0, 0, 0 );
            // light.castShadow = true;
            // scene.add(light);
            camera.add( light );


            /* light helper */
            // const lightHelper = new THREE.DirectionalLightHelper( light, 10, 'black' );
            // scene.add( lightHelper );


            /* Render */
            renderer = new THREE.WebGLRenderer( { canvas, antialias: true, alpha: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );

            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;

            // renderer.shadowMap.enabled = true;

            renderer.physicallyCorrectLights = true
            renderer.localClippingEnabled = true;


            /* resize */
            window.addEventListener( 'resize', onWindowResize );


            /* keydown */
            document.addEventListener( 'keydown', onKeyDown );


            /* progressBar */
            progressBarDiv = document.createElement( 'div' );
            progressBarDiv.innerText = 'Loading...';
            progressBarDiv.style.fontSize = '3rem';
            progressBarDiv.style.color = '#888';
            progressBarDiv.style.display = 'block';
            progressBarDiv.style.position = 'absolute';
            progressBarDiv.style.top = '50%';
            progressBarDiv.style.width = '100%';
            progressBarDiv.style.textAlign = 'center';


            updateProgressBar( 0 );
            showProgressBar();

            /* environment Mapping */
            new RGBELoader()
                .setDataType( THREE.FloatType )
                // .setPath( 'https://Lee-hoseong.github.io/texture/' )
                // .setPath( '/release/PIPE/texture/' )
                .load( 'wasteland_clouds_1k.hdr', ( texture ) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    env = texture;


                    /* DRACO Loader */
                    const dracoLoader = new DRACOLoader();
                    dracoLoader.setDecoderPath('https://Lee-hoseong.github.io/js/libs/draco/');
                    // dracoLoader.setDecoderPath('/release/PIPE/source1/r131/examples/js/libs/draco/');

                    
                    /* GLTF Loader */
                    const gltfLoader = new GLTFLoader();
                    gltfLoader.setDRACOLoader(dracoLoader); // draco로더 적용

                    // gltfLoader.setPath( 'https://Lee-hoseong.github.io/model/' );
                    // gltfLoader.setPath( '/release/PIPE/model/' );
                    const url = 'boxTest_draco.glb';

                    gltfLoader.load( url, function ( gltf ) {


                        // gltf.scene.traverse( function( node ) {
                        //     if ( node instanceof THREE.Mesh ) {
                        //         node.castShadow = true;
                        //         node.receiveShadow = true;
                        //     }
                        // });


                        model = gltf.scene;

                        scene.environment = env;
                        // scene.background = env;
                        
                        scene.add( model );

                        zoomFit( model, camera, "Z", true );


                        /* Axes */
                        axes = new THREE.AxesHelper( sizeBox );
                        axes.visible = false;
                        scene.add( axes );


                        /* grid */
                        const size = 2*sizeBox;
                        const divisions = 20;
                        gridHelper = new THREE.GridHelper( size, divisions );
                        gridHelper.position.x = centerBox.x;
                        gridHelper.position.y = 0;
                        gridHelper.position.z = centerBox.z;
                        gridHelper.visible = false;
                        scene.add( gridHelper );


                        hideProgressBar();

                    }, onProgress, onError );
                    
                } );
                
            
        }

        function zoomFit(obj3D, viewMode, bFront) {
            box = new THREE.Box3().setFromObject(obj3D);
            sizeBox = box.getSize(new THREE.Vector3()).length();
            centerBox = box.getCenter(new THREE.Vector3());

            // viewmode 설정
            let offsetX =0, offsetY=0, offsetZ=0;
            viewMode === "X" ? offsetX = 1 : (viewMode === "Y") ? offsetY = 1 : offsetZ = 1;

            // 앞면을 볼지 뒷면을 볼지
            if( !bFront ) {
                offsetX *= -1; 
                offsetY *= -1; 
                offsetZ *= -1; 
            }

            // 카메라 위치 설정
            camera.position.set( 
                centerBox.x + offsetX, centerBox.y + offsetY, centerBox.z + offsetZ
            );
            
            // 모델 크기의 절반값
            const halfSizeModel = sizeBox * 0.5;

            // 카메라의 fov의 절반값
            const halfFov = THREE.Math.degToRad(cameraPerspective.fov * 0.5);

            // 모델을 화면에 꽉 채우기 위한 적당한 거리
            const distance = halfSizeModel / Math.tan(halfFov);

            // 모델 중심에서 카메라 위치로 향하는 방향 단위 벡터 계산
            const direction = (new THREE.Vector3()).subVectors(camera.position, centerBox).normalize();

            // "단위 방향 벡터" 방향으로 모델 중심 위치에서 distance 거리에 대한 위치
            const position = direction.multiplyScalar(distance).add(centerBox);
            camera.position.copy(position);

            // 모델의 크기에 맞춰 카메라의 near, far 값을 대략적으로 조정
            camera.near = sizeBox / 100;
            camera.far = sizeBox * 100;

            // 카메라 기본 속성 변경에 따른 투영행렬 업데이트
            camera.updateProjectionMatrix();

            // 카메라 모델의 중심을 바라 보도록 함
            camera.lookAt(centerBox.x, centerBox.y, centerBox.z);

            // orbitControl이 객체중심에서 회전하도록
            controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
            controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
        }


        function onKeyDown( event ) {
            switch ( event.keyCode ) {

                case 70: /*F*/
                    zoomFit(model, "Z", true);
                    break;

                case 66: /*b*/
                    zoomFit(model, "Z", false);
                    break;                    

                case 82: /*R*/
                    zoomFit(model, "X", true);
                    break;

                case 76: /*L*/
                    zoomFit(model, "X", false);
                    break;

                case 84: /*T*/
                    zoomFit(model, "Y", true);
                    break;

                case 65: /*A*/
                    changeautoRotate();
                    break;

                case 67: /*C*/
                    changeCamera();
                    break;
                    
                case 87: /*W*/
                    changeWireframe();
                    break;
            }
        }


        // 1. btn1 - opacity
        //  1.1 offcanvas open
        document.getElementById("btn1").addEventListener("click", ()=>{
            document.getElementById("myoffcanvasBottom1").style.height = "25rem";
            document.getElementsByClassName("btn-container")[0].style.display = "none";

            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                child.material.transparent = true;
            });
        });

        //  1.2 offcanvas close
        document.getElementById("close1").addEventListener("click", ()=> {
            document.getElementById("myoffcanvasBottom1").style.height = "0";
            document.getElementsByClassName("btn-container")[0].style.display = "block";
        });

        //  1.3 addEventListener : Change
        document.getElementById("opacityId").min = 0.1; // <=수정해야함

        const opaV = document.querySelector('#opacityValue');
        opaV.textContent = document.getElementById("opacityId").value;

        document.getElementById("opacityId").addEventListener("input", (value)=>{
            /* addEventListener
                - input : onChange
                - change : onFinishChange
            */

            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                child.material.opacity = document.getElementById("opacityId").value;
            });

            opaV.textContent = document.getElementById("opacityId").value;
        });


        // 2. btn2 - clipping
        // 2.0 negate 값 정의
        let negateX = false;
        let negateY = false;
        let negateZ = false;

        //  2.1 offcanvas open
        document.getElementById("btn2").addEventListener("click", ()=>{
            document.getElementById("myoffcanvasBottom2").style.height = "50rem";
            document.getElementsByClassName("btn-container")[0].style.display = "none";

            // negate 초기화
            const x = document.getElementById("negateX");
            if ( x.style.color === "white" ) {
                x.style.backgroundColor = 'transparent';
                x.style.color = '#EB530C';

                clippingPlanes[ 0 ].negate();
                negateX = false;
            } 

            const y = document.getElementById("negateY");
            if ( y.style.color === "white" ) {
                y.style.backgroundColor = 'transparent';
                y.style.color = '#EB530C';

                clippingPlanes[ 0 ].negate();
                negateY = false;
            } 

            const z = document.getElementById("negateZ");
            if ( z.style.color === "white" ) {
                z.style.backgroundColor = 'transparent';
                z.style.color = '#EB530C';

                clippingPlanes[ 0 ].negate();
                negateZ = false;
            } 

            // 박스 재계산 : 스케일이 바뀐 경우
            const box2 = new THREE.Box3().setFromObject(model);

            document.getElementById("clippingXId").min = box2.min.x -0.1;
            document.getElementById("clippingXId").max = box2.max.x +0.1;
            document.getElementById("clippingXId").step = 0.01;
            document.getElementById("clippingXId").value = box2.max.x +0.1;


            document.getElementById("clippingYId").min = box2.min.y -0.1;
            document.getElementById("clippingYId").max = box2.max.y +0.1;
            document.getElementById("clippingYId").step = 0.01;
            document.getElementById("clippingYId").value = box2.max.y +0.1;


            document.getElementById("clippingZId").min = box2.min.z -0.1;
            document.getElementById("clippingZId").max = box2.max.z +0.1;
            document.getElementById("clippingZId").step = 0.01;
            document.getElementById("clippingZId").value = box2.max.z +0.1;


            // boxHelper
            // const boxHelper = new THREE.BoxHelper( model, 'black' );
            // scene.add( boxHelper );


            // * clipping
            clippingPlanes = [ 
                new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), document.getElementById("clippingXId").value ),
                new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), document.getElementById("clippingYId").value ),
                new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), document.getElementById("clippingZId").value )
            ];

            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                child.material.clippingPlanes = clippingPlanes;
            });


            // * clipping Helper
            const matrix = new THREE.Matrix4();

            clipHelperX = new THREE.PlaneHelper( clippingPlanes[0], 2*sizeBox, 'red' );
            clipHelperX.visible = false;
            // clipHelperX.applyMatrix4( matrix.makeTranslation( 0, 0, box2.min.z) );
            scene.add( clipHelperX );

            clipHelperY = new THREE.PlaneHelper( clippingPlanes[1], 2*sizeBox, 'green' );
            clipHelperY.visible = false;
            scene.add( clipHelperY );

            clipHelperZ = new THREE.PlaneHelper( clippingPlanes[2], 2*sizeBox, 'blue' );
            clipHelperZ.visible = false;
            scene.add( clipHelperZ );
        });

        //  2.2 offcanvas close 
        document.getElementById("close2").addEventListener("click", ()=> {
            document.getElementById("myoffcanvasBottom2").style.height = "0";
            document.getElementsByClassName("btn-container")[0].style.display = "block";
            clipHelperX.visible = false;
            scene.remove( clipHelperX );
            scene.remove( clipHelperY );
            scene.remove( clipHelperZ );
        });

        //  2.3 addEventListener : Change
        //  a. 반전X
        document.getElementById("negateX").addEventListener("click", () => {
            const x = document.getElementById("negateX");

            if ( x.style.color === "white" ) {
                x.style.backgroundColor = 'transparent';
                x.style.color = '#EB530C';

                clippingPlanes[ 0 ].negate();
                negateX = false;
            } else {
                x.style.backgroundColor = '#EB530C';
                x.style.color = 'white';

                clippingPlanes[ 0 ].negate();
                negateX = true;
            }
        });

        //  b. 반전Y
        document.getElementById("negateY").addEventListener("click", () => {
            const x = document.getElementById("negateY");

            if ( x.style.color === "white" ) {
                x.style.backgroundColor = 'transparent';
                x.style.color = '#EB530C';

                clippingPlanes[ 1 ].negate();
                negateY = false;
            } else {
                x.style.backgroundColor = '#EB530C';
                x.style.color = 'white';

                clippingPlanes[ 1 ].negate();
                negateY = true;
            }
        });

        //  c. 반전Z
        document.getElementById("negateZ").addEventListener("click", () => {
            const x = document.getElementById("negateZ");

            if ( x.style.color === "white" ) {
                x.style.backgroundColor = 'transparent';
                x.style.color = '#EB530C';

                clippingPlanes[ 2 ].negate();
                negateZ = false;
            } else {
                x.style.backgroundColor = '#EB530C';
                x.style.color = 'white';

                clippingPlanes[ 2 ].negate();
                negateZ = true;
            }
        });

        //  d. 클리핑X
        document.getElementById("clippingXId").addEventListener("input", (value)=>{
            clipHelperX.visible = true;

            if(negateX) {
                clippingPlanes[ 0 ].constant = -document.getElementById("clippingXId").value;
            } else {
                clippingPlanes[ 0 ].constant = document.getElementById("clippingXId").value;
            }
        });

        //  e. 클리핑Y
        document.getElementById("clippingYId").addEventListener("input", (value)=>{
            clipHelperY.visible = true;

            if(negateY) {
                clippingPlanes[ 1 ].constant = -document.getElementById("clippingYId").value;
            } else {
                clippingPlanes[ 1 ].constant = document.getElementById("clippingYId").value;
            }
        });

        //  f. 클리핑Z
        document.getElementById("clippingZId").addEventListener("input", (value)=>{
            clipHelperZ.visible = true;

            if(negateZ) {
                clippingPlanes[ 2 ].constant = -document.getElementById("clippingZId").value;
            } else {
                clippingPlanes[ 2 ].constant = document.getElementById("clippingZId").value;
            }
        });


        // 3. btn3 - scale
        //  3.1 offcanvas open
        document.getElementById("btn3").addEventListener("click", ()=>{
            document.getElementById("myoffcanvasBottom3").style.height = "50rem";
            document.getElementsByClassName("btn-container")[0].style.display = "none";

            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                child.material.clippingPlanes = null;
            })
        });

        //  3.2 offcanvas close
        document.getElementById("close3").addEventListener("click", ()=> {
            document.getElementById("myoffcanvasBottom3").style.height = "0";
            document.getElementsByClassName("btn-container")[0].style.display = "block";
        });

        //  3.3 addEventListener : Change
        //  a. scale X
        const sXV = document.querySelector('#scaleXValue');
        sXV.textContent = document.getElementById("scaleXId").value;

        document.getElementById("scaleXId").addEventListener("input", (value)=>{
            model.scale.x = document.getElementById("scaleXId").value;
            sXV.textContent = document.getElementById("scaleXId").value;
        });

        //  b. scale Y
        const sYV = document.querySelector('#scaleYValue');
        sYV.textContent = document.getElementById("scaleYId").value;

        document.getElementById("scaleYId").addEventListener("input", (value)=>{
            model.scale.y = document.getElementById("scaleYId").value;
            sYV.textContent = document.getElementById("scaleYId").value;
        });

        //  c. scale Z
        const sZV = document.querySelector('#scaleZValue');
        sZV.textContent = document.getElementById("scaleZId").value;

        document.getElementById("scaleZId").addEventListener("input", (value)=>{
            model.scale.z = document.getElementById("scaleZId").value;
            sZV.textContent = document.getElementById("scaleZId").value;
        });


        // 4. btn4 - more
        //  4.1 offcanvas open btn4
        document.getElementById("btn4").addEventListener("click", ()=>{
            document.getElementById("myoffcanvasBottom4").style.height = "50rem";
            document.getElementsByClassName("btn-container")[0].style.display = "none";
        });

        //  4.2 offcanvas close btn5
        document.getElementById("close4").addEventListener("click", ()=> {
            document.getElementById("myoffcanvasBottom4").style.height = "0";
            document.getElementsByClassName("btn-container")[0].style.display = "block";
        });

        //  4.3 ViewMode
        // document.getElementById("autoRotate").addEventListener("click", changeautoRotate );

        document.getElementById("cameraSwitch").addEventListener("click", changeCamera );
        document.getElementById("wireframeSwitch").addEventListener("click", changeWireframe );
        document.getElementById("axeSwitch").addEventListener("click", ()=>{
            axes.visible ? axes.visible = false : axes.visible = true;
        } );
        document.getElementById("gridSwitch").addEventListener("click", ()=>{
            gridHelper.visible ? gridHelper.visible = false : gridHelper.visible = true;
        } );

        
        //  4.3+ background
        document.getElementById("background").addEventListener("change", ()=>{
            if( document.getElementById("background").value == 1 ) {
                scene.background = new THREE.Color( 0xffffff );

            } else if ( document.getElementById("background").value == 2 ) {
                scene.background = null;

            } else if ( document.getElementById("background").value == 3 ) {
                scene.background = env;
            }
        });


        function changeautoRotate () {
            if( controlsPerspective.autoRotate || controlsOrtho.autoRotate ) {
                controlsPerspective.autoRotate = false;
                controlsOrtho.autoRotate = false;
            } else {
                controlsPerspective.autoRotate = true;
                controlsOrtho.autoRotate = true;
            }
        }

        function changeWireframe () {
            scene.traverse( ( child )=> {
                if( !child.isMesh ) return;

                if( child.material.wireframe ) {
                    child.material.wireframe = false;
                } else {
                    child.material.wireframe = true; 
                }
            });
        }
      
        function changeCamera () {
            if( camera == cameraPerspective ) {
                // perspective에서 ortho로 변경
                cameraOrtho.near = cameraPerspective.near;
                cameraOrtho.far = cameraPerspective.far;
                cameraOrtho.zoom = Math.min( window.innerWidth / (box.max.x - box.min.x), window.innerHeight / (box.max.y - box.min.y)) * 0.4

                camera = cameraOrtho;
                camera.position.copy( cameraPerspective.position );
                cameraOrtho.updateProjectionMatrix();

                camera.add(light);

                controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
                // controlsOrtho.update();

                // Gizmo
                document.body.removeChild(controlsGizmoPerspective.domElement);
                document.body.appendChild(controlsGizmoOrtho.domElement);

                // console.log( 'controlsGizmo', controlsGizmo );

            } else {
                // ortho에서 perspective로 변경
                camera = cameraPerspective;
                camera.position.copy( cameraOrtho.position );
                cameraPerspective.updateProjectionMatrix();
                
                camera.add(light);

                controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
                // controlsPerspective.update();

                // Gizmo
                document.body.removeChild(controlsGizmoOrtho.domElement);
                document.body.appendChild(controlsGizmoPerspective.domElement);
            }
        }


        /* Resize & render*/
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;

            camera.left = -height * aspect;
            camera.right = height * aspect;
            camera.top = height;
            camera.bottom = -height;
      
            camera.updateProjectionMatrix();

            renderer.setSize( width, height );
        }

        function animate() {
            controlsPerspective.update();
            controlsOrtho.update();
            
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( scene, camera );
        }


        /* Progress */
        function onProgress( xhr ) {
            if ( xhr.lengthComputable ) {
                updateProgressBar( xhr.loaded / xhr.total );
                console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );
            }
        }

        function onError( error ) {
            const message = 'Error loading model';
            progressBarDiv.innerText = message;
            console.log( message );
            console.error( error );
        }

        function showProgressBar() {
            document.body.appendChild( progressBarDiv );
        }

        function hideProgressBar() {
            document.body.removeChild( progressBarDiv );
            console.log( "설명하지 못한다면, 그것은 진정으로 이해한 것이 아니다.");
            console.log( "더구나, 지금은 설명도 필요없는 시대다!");
        }

        function updateProgressBar( fraction ) {
            progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';
        }
    </script>
</body>
</html>