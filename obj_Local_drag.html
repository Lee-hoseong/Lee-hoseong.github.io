<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>한맥가족 클라우드센터</title>
    <style>
        html, body {
            margin : 0;
            height : 100%;
            font-size : 10px;
        }

        #c {
            width: 100%;
            height: 100%;
            display: block;
        }

    </style>
</head>
<body>

    <canvas id="c"></canvas>

    <script type="module">

        /* import */
        import * as THREE from 'https://Lee-hoseong.github.io/build/three.module.js';
        import { MTLLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/MTLLoader.js';
        import { OBJLoader } from 'https://Lee-hoseong.github.io/jsm/loaders/OBJLoader.js';
        import { RGBELoader } from 'https://Lee-hoseong.github.io/jsm/loaders/RGBELoader.js';
        

        // import { OrbitControls } from 'https://Lee-hoseong.github.io//ThreeOrbitControlsGizmo/OrbitControls.js';
        // import { OrbitControlsGizmo  } from 'https://Lee-hoseong.github.io/ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';
        import { OrbitControls } from 'https://Lee-hoseong.github.io/jsm/controls/OrbitControls.js';


        // import * as THREE from '/release/PIPE/source1/r131/build/three.module.js';
        // import { GLTFLoader } from '/release/PIPE/source1/r131/examples/jsm/loaders/GLTFLoader.js';
        // import { RGBELoader } from '/release/PIPE/source1/r131/examples/jsm/loaders/RGBELoader.js';

        // import { OrbitControls } from '/release/PIPE/source2/ThreeOrbitControlsGizmo/OrbitControls.js';
        // import { OrbitControlsGizmo  } from '/release/PIPE/source2/ThreeOrbitControlsGizmo/OrbitControlsGizmo.js';


        /* variable */
        let camera, scene, light, renderer;
        let cameraPerspective, cameraOrtho;
        let controlsPerspective, controlsOrtho;
        let controlsGizmoPerspective, controlsGizmoOrtho;
        let box, sizeBox, centerBox, model;
        let progressBarDiv;
        let clippingPlanes, clipHelperX, clipHelperY, clipHelperZ;
        let axes, gridHelper;
        let env;


        create3DViewer();
        animate();


        function create3DViewer () {
            const canvas = document.querySelector('#c'); 
            
            /* scene */
            scene = new THREE.Scene();               
            // const vignette = createBackground({
            //     aspect: aspect,
            //     grainScale: IS_IOS ? 0 : 0.001, // mattdesl/three-vignette-background#1
            //     colors: [0xffffff, 0x353535]
            // });

            scene.background = new THREE.Color( 0xf0f0f0 );

            /* camera */
            const aspect = window.innerWidth/window.innerHeight;
            
            cameraPerspective = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            scene.add( cameraPerspective );

            cameraOrtho = new THREE.OrthographicCamera( 
                window.innerWidth/-aspect, 
                window.innerWidth/aspect, 
                window.innerHeight/aspect, 
                window.innerHeight/-aspect, 0.1, 1000 
            );
            // cameraOrtho.zoom = 1;
            scene.add( cameraOrtho );

            camera = cameraPerspective;
            

            /* OrbitControl */
            controlsPerspective = new OrbitControls( cameraPerspective, canvas );
            controlsPerspective.autoRotate = false;
            controlsPerspective.autoRotateSpeed = -3;
            controlsPerspective.screenSpacePanning = true;
     
            controlsOrtho = new OrbitControls( cameraOrtho, canvas );
            controlsOrtho.autoRotate = false;
            controlsOrtho.autoRotateSpeed = -3;
            controlsOrtho.screenSpacePanning = true;


            /* Gizmo */
            // controlsGizmoPerspective = new OrbitControlsGizmo(controlsPerspective, { size:  100, padding:  8 });
            // controlsGizmoOrtho = new OrbitControlsGizmo(controlsOrtho, { size:  100, padding:  8 });

            // document.body.appendChild(controlsGizmoPerspective.domElement);
          

            /* light */
            scene.add( new THREE.AmbientLight( 0xffffff, 0.3 ) );
            
            light = new THREE.DirectionalLight( 'white', 3 );
            light.position.set( -1, 2, 4 );
            // light.position.set( 0.5, 0, 0.866 );
            // light.target.position.set( 0, 0, 0 );
            // light.castShadow = true;
            // scene.add(light);
            camera.add( light );


            /* light helper */
            // const lightHelper = new THREE.DirectionalLightHelper( light, 10 );
            // scene.add( lightHelper );


            /* Render */
            renderer = new THREE.WebGLRenderer( { canvas, antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );

            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // renderer.shadowMap.enabled = true;

            renderer.physicallyCorrectLights = true
            renderer.localClippingEnabled = true;


            /* resize */
            window.addEventListener( 'resize', onWindowResize );


            /* keydown */
            document.addEventListener( 'keydown', onKeyDown );

            /* Progress */
            progressBarDiv = document.createElement( 'div' );
            progressBarDiv.innerText = '파일을 드래그 하세요';
            progressBarDiv.style.fontSize = '3rem';
            progressBarDiv.style.color = '#888';
            progressBarDiv.style.display = 'block';
            progressBarDiv.style.position = 'absolute';
            progressBarDiv.style.top = '50%';
            progressBarDiv.style.width = '100%';
            progressBarDiv.style.textAlign = 'center';
            document.body.appendChild( progressBarDiv );

            // updateProgressBar( 0 );
            // showProgressBar();




            const objLoader = new OBJLoader();
            const mtlLoader = new MTLLoader();

            const group = new THREE.Group();
            const meshes = [];

            let mtlMaterials;



            const $uploadBox = document.getElementById( 'c' );

            $uploadBox.addEventListener('dragover', function( e ) {

                e.preventDefault();
                this.style.backgroundColor = 'lightgray';

            })


            $uploadBox.addEventListener('drop', function( event ) {
                
                event.stopPropagation();
                event.preventDefault();

                // modelLoaded = false;

                // if( !isValid(event.dataTransfer) ) return;
                
                const fileList = event.dataTransfer.files;

                [...fileList].forEach( ( v, i ) => { 

                    const file = v;

                    const extension = ( file.name ).split( '.' ).pop().toLowerCase();

                    // console.log( file.webkitRelativePath );

                    if( extension == 'obj' ) {

                        fileReadAsText( file )
                            .then( objFileLoad )
                            .then( modelTraverse )
                            // .then( meshReset );

                    }

                    if( extension == 'mtl' ) {

                        fileReadAsText( file )
                            // .then ( console.log )
                            .then( mtlFileLoad )

                    }

                } )

            })


            function fileReadAsText( file ) {

                return new Promise( ( resolve, reject ) => {

                    const fileReader = new FileReader();

                    fileReader.onload = () => resolve( fileReader.result );
                    fileReader.readAsText( file );

                });

            }

            function fileReadAsDataURL( file ) {

                return new Promise( ( resolve, reject ) => {

                    const fileReader = new FileReader();

                    fileReader.onload = () => resolve( fileReader.result );
                    fileReader.readAsDataURL( file );

                });

            }

                       
            function objFileLoad( text ) {

                return new Promise( ( resolve, reject ) => {

                    // const model = objLoader.parse( text );
                    const model = objLoader.setMaterials( mtlMaterials ).parse( text );
                    // objLoader.setMaterials( mtlMaterials );
                    model.name = 'objLoad';

                    // console.log( model )

                    resolve( model )

                })

            }

            function mtlFileLoad( text ) {

                return new Promise( ( resolve, reject ) => {

                    // const mtlFile = mtlLoader.parse( text );
                    const mtlFile = mtlLoader.parse( text );
                    mtlFile.name = 'mtlLoad';
                    console.log( mtlFile );
                    // objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );

                    mtlMaterials = mtlFile;

                    resolve( mtlMaterials )

                })


            }


            function modelTraverse ( model ) {
                                
                model.traverse( ( child ) => { 

                    if( !child.isMesh ) return

                    // group.add( child ); (*)traverse할 때 개체 트리 구조 수정할 수 없음
                    meshes.push( child );

                })

                meshes.forEach( element => group.add( element ) );

                scene.add( group );

                modelSetting( group );

                return meshes

                // scene.add( model );

                // modelSetting( model );

                // return model


            }

            function modelSetting ( group ) {

                zoomFit( group, camera, "Z", true );

                hideProgressBar();

            }

            function meshReset ( meshes ) {

                console.clear();

                meshes.forEach( mesh => console.log( mesh ) );

            }









                

                // addFileName( fileList[0].name );

                // async function fileReadPromiseAll () {

                //     let beforePromiseAllArr = [];
                //     // jsonData = [];
                //     // console.clear();
                //     // console.log( beforePromiseAllArr );

                //     [...fileList].forEach( ( v, i ) => { 
            
                //         const readFile = event.dataTransfer.files[i]

                //         const extension = (readFile.name ).split( '.' ).pop().toLowerCase();

                //         console.log( 'readFile', readFile )

                //         if( extension == 'glb' ) {

                //             beforePromiseAllArr.push( glbFileReader( readFile ) )

                //         }
                    
                        
                //         if( extension == 'obj' ) {

                //             beforePromiseAllArr.push( fileReadAsText( readFile ) )
                            
                //         }


                //         if( extension == 'json' ) {

                //             jsonFileReader( readFile )
                //                 .then( ( result ) => { jsonData.push( JSON.parse(result) ) } );

                //         }

                //     } );
            
                //     return Promise.all( beforePromiseAllArr ).then( val => { return val; } )
                    
                // }

                // fileReadPromiseAll()
                //     .then( async ( filesArrayBuffer ) => {

                //         const fileArr = [];

                //         filesArrayBuffer.forEach( ( v, i ) => { fileArr.push( objLoadAsync(v) ) })
                        
                //         console.time( 'fileReadPromiseAll Time');

                //         await Promise.all( fileArr );
                        
                //         console.timeEnd( 'fileReadPromiseAll Time');

                //         // modelLoaded = true;

                //     })








































            /* environment Mapping */
            // new RGBELoader()
            //     .setDataType( THREE.FloatType )
            //     .setPath( 'https://Lee-hoseong.github.io/texture/' )
            //     // .setPath( '/release/PIPE/texture/' )
            //     .load( 'wasteland_clouds_1k.hdr', ( texture ) => {
            //         texture.mapping = THREE.EquirectangularReflectionMapping;
            //         env = texture;
                    
            //         /* GLTF Loader */
            //         new MTLLoader()
			// 		// .setPath( 'models/obj/male02/' )
			// 		.load( 'Dr_Obj_blender.mtl', function ( materials ) {

			// 			materials.preload();

						// new OBJLoader()
						// 	// .setMaterials( materials )
						// 	// .setPath( 'models/obj/male02/' )
						// 	.load( 'Dr_Obj_blender.obj', function ( object ) {

                        //         model = object
						// 		// object.position.y = - 95;
						// 		scene.add( object );

                        //         model.traverse( ( child ) => {

                        //             if( !child.isMesh ) return

                        //             console.log( child )

                        //         })
                                

                        //         zoomFit( model, camera, "Z", true );


                        //         /* Axes */
                        //         axes = new THREE.AxesHelper( sizeBox );
                        //         axes.visible = false;
                        //         scene.add( axes );


                        //         /* grid */
                        //         const size = 2*sizeBox;
                        //         const divisions = 20;
                        //         gridHelper = new THREE.GridHelper( size, divisions );
                        //         gridHelper.position.x = centerBox.x;
                        //         gridHelper.position.y = 0;
                        //         gridHelper.visible = false;
                        //         scene.add( gridHelper );


                        //         hideProgressBar();
                        //         // createUI();

						// 	}, onProgress, onError );

					// } );

            
            //     } );
            
        }

        function zoomFit(obj3D, viewMode, bFront) {
            box = new THREE.Box3().setFromObject(obj3D);
            sizeBox = box.getSize(new THREE.Vector3()).length();
            centerBox = box.getCenter(new THREE.Vector3());

            // viewmode 설정
            let offsetX =0, offsetY=0, offsetZ=0;
            viewMode === "X" ? offsetX = 1 : (viewMode === "Y") ? offsetY = 1 : offsetZ = 1;

            // 앞면을 볼지 뒷면을 볼지
            if( !bFront ) {
                offsetX *= -1; 
                offsetY *= -1; 
                offsetZ *= -1; 
            }

            // 카메라 위치 설정
            camera.position.set( 
                centerBox.x + offsetX, centerBox.y + offsetY, centerBox.z + offsetZ
            );
            
            // 모델 크기의 절반값
            const halfSizeModel = sizeBox * 0.5;

            // 카메라의 fov의 절반값
            const halfFov = THREE.Math.degToRad(cameraPerspective.fov * 0.5);

            // 모델을 화면에 꽉 채우기 위한 적당한 거리
            const distance = halfSizeModel / Math.tan(halfFov);

            // 모델 중심에서 카메라 위치로 향하는 방향 단위 벡터 계산
            const direction = (new THREE.Vector3()).subVectors(camera.position, centerBox).normalize();

            // "단위 방향 벡터" 방향으로 모델 중심 위치에서 distance 거리에 대한 위치
            const position = direction.multiplyScalar(distance).add(centerBox);
            camera.position.copy(position);

            // 모델의 크기에 맞춰 카메라의 near, far 값을 대략적으로 조정
            camera.near = sizeBox / 100;
            camera.far = sizeBox * 100;

            // 카메라 기본 속성 변경에 따른 투영행렬 업데이트
            camera.updateProjectionMatrix();

            // 카메라 모델의 중심을 바라 보도록 함
            camera.lookAt(centerBox.x, centerBox.y, centerBox.z);

            // orbitControl이 객체중심에서 회전하도록
            controlsPerspective.target.set(centerBox.x, centerBox.y, centerBox.z);
            controlsOrtho.target.set(centerBox.x, centerBox.y, centerBox.z);
        }


        function onKeyDown( event ) {
            switch ( event.keyCode ) {

                case 70: /*F*/
                    zoomFit(model, "Z", true);
                    break;

                case 66: /*b*/
                    zoomFit(model, "Z", false);
                    break;                    

                case 82: /*R*/
                    zoomFit(model, "X", true);
                    break;

                case 76: /*L*/
                    zoomFit(model, "X", false);
                    break;

                case 84: /*T*/
                    zoomFit(model, "Y", true);
                    break;

                case 65: /*A*/
                    changeautoRotate();
                    break;

                case 67: /*C*/
                    changeCamera();
                    break;
                    
                case 87: /*W*/
                    changeWireframe();
                    break;
            }
        }


        /* Resize & render*/
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = window.innerWidth / window.innerHeight;

            camera.aspect = aspect;

            camera.left = -height * aspect;
            camera.right = height * aspect;
            camera.top = height;
            camera.bottom = -height;
      
            camera.updateProjectionMatrix();

            renderer.setSize( width, height );
        }

        function animate() {
            controlsPerspective.update();
            
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            renderer.render( scene, camera );
        }


        /* Progress */
        // progressBarDiv = document.createElement( 'div' );
        // progressBarDiv.innerText = 'Loading...';
        // progressBarDiv.style.fontSize = '3rem';
        // progressBarDiv.style.color = '#888';
        // progressBarDiv.style.display = 'block';
        // progressBarDiv.style.position = 'absolute';
        // progressBarDiv.style.top = '50%';
        // progressBarDiv.style.width = '100%';
        // progressBarDiv.style.textAlign = 'center';
        // document.body.appendChild( progressBarDiv );


        function onProgress( xhr ) {
            
            if ( xhr.lengthComputable ) {
                updateProgressBar( xhr.loaded / xhr.total );
                console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );
            }
        }

        function onError( error ) {
            const message = 'Error loading model';
            progressBarDiv.innerText = message;
            console.log( message );
            console.error( error );
        }

        function showProgressBar() {
            progressBarDiv.style.display = 'block';
            // document.body.appendChild( progressBarDiv );
        }

        function showText() {
            progressBarDiv.innerText = '로딩중 입니다';
            progressBarDiv.style.display = 'block';
            // document.body.appendChild( progressBarDiv );
        }

        function hideProgressBar() {
            // document.body.removeChild( progressBarDiv );
            progressBarDiv.style.display = 'none';
        }

        function updateProgressBar( fraction ) {
            progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';
        }
    </script>
</body>
</html>