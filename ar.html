<!DOCTYPE html>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!-- three.js library -->
<script src='https://Lee-hoseong.github.io/ar/three.min.js'></script>
<!-- ar.js -->
<script src='https://Lee-hoseong.github.io/ar/ar.js'></script>
<!-- three.js load GLTF -->
<script src='https://Lee-hoseong.github.io/ar/GLTFLoader.js'></script>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
	<div style='position: absolute; top: 10px; width:100%; text-align: center; z-index: 1;'>
		설명하지 못한다면, 그것은 진정으로 이해한 것이 아니다.
		<br/>
		더구나, 지금은 설명도 필요없는 시대다!
	</div>

	<!-- 사파리 정책 변경으로 무음으로 재생 -->
	<video id="video" autoplay loop muted playsinline crossOrigin="anonymous" style="display:none">
		<source src="https://Lee-hoseong.github.io/ar/video-sample.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
	</video>

	<script>
		//////////////////////////////////////////////////////////////////////////////////
		//		Init
		//////////////////////////////////////////////////////////////////////////////////

		// init renderer
		var renderer = new THREE.WebGLRenderer({
			antialias: true,
			alpha: true
		});
		renderer.setClearColor(new THREE.Color('lightgrey'), 0)
		renderer.setSize( 1280, 960 );
		renderer.domElement.style.position = 'absolute'
		renderer.domElement.style.top = '0px'
		renderer.domElement.style.left = '0px'
		document.body.appendChild( renderer.domElement );

		// array of functions for the rendering loop
		var onRenderFcts= [];

		// init scene and camera
		var scene	= new THREE.Scene();

		//////////////////////////////////////////////////////////////////////////////////
		//		Initialize a basic camera
		//////////////////////////////////////////////////////////////////////////////////

		// Create a camera
		var camera = new THREE.Camera();
		scene.add(camera);

		////////////////////////////////////////////////////////////////////////////////
		//          handle arToolkitSource
		////////////////////////////////////////////////////////////////////////////////

		var arToolkitSource = new THREEx.ArToolkitSource({
			// to read from the webcam
			sourceType : 'webcam',

			// // to read from an image
			// sourceType : 'image',
			// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',

			// to read from a video
			// sourceType : 'video',
			// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
		})

		arToolkitSource.init(function onReady(){
			setTimeout(() => {
				onResize()
			}, 2000);
		})

		// handle resize
		window.addEventListener('resize', function(){
			onResize()
		})

		function onResize(){
			arToolkitSource.onResizeElement()
			arToolkitSource.copyElementSizeTo(renderer.domElement)
			if( arToolkitContext.arController !== null ){
				arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas)
			}
		}
		////////////////////////////////////////////////////////////////////////////////
		//          initialize arToolkitContext
		////////////////////////////////////////////////////////////////////////////////


		// create atToolkitContext
		var arToolkitContext = new THREEx.ArToolkitContext({
			// cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
			cameraParametersUrl: 'https://Lee-hoseong.github.io/ar/camera_para.dat',
			detectionMode: 'mono',
		})
		// initialize it
		arToolkitContext.init(function onCompleted(){
			// copy projection matrix to camera
			camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
		})

		// update artoolkit on every frame
		onRenderFcts.push(function(){
			if( arToolkitSource.ready === false )	return

			arToolkitContext.update( arToolkitSource.domElement )

			// update scene.visible if the marker is seen
			scene.visible = camera.visible
		})

		////////////////////////////////////////////////////////////////////////////////
		//          Create a ArMarkerControls
		////////////////////////////////////////////////////////////////////////////////

		// init controls for camera
		var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
			type : 'pattern',
			// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
			// patternUrl : 'https://Lee-hoseong.github.io/ar/pattern-test.patt',
			patternUrl : 'https://Lee-hoseong.github.io/ar/pattern-qr-code.patt',
			// patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
			// as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
			changeMatrixMode: 'cameraTransformMatrix'
		})
		// as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
		scene.visible = false

		//////////////////////////////////////////////////////////////////////////////////
		//		add an object in the scene
		//////////////////////////////////////////////////////////////////////////////////



		/* 기본 메쉬 */
		// add a torus knot
		var geometry	= new THREE.CubeGeometry(1,1,1);
		var material	= new THREE.MeshNormalMaterial({
			transparent : true,
			opacity: 0.5,
			side: THREE.DoubleSide
		});
		
		var mesh1	= new THREE.Mesh( geometry, material );
		mesh1.position.y	= geometry.parameters.height/2
		scene.add( mesh1 );

		var geometry2	= new THREE.TorusKnotGeometry(0.3,0.1,64,16);
		var material2	= new THREE.MeshNormalMaterial();
		var mesh2	= new THREE.Mesh( geometry2, material2 );
		mesh2.position.y	= 0.5
		scene.add( mesh2 );


		/* 라인 */
		// const videoBoxShp = new THREE.Shape();
		// videoBoxShp.moveTo( 0, 0 );
		// videoBoxShp.lineTo( 2, 0 );
		// videoBoxShp.lineTo( 2, 1.125 );
		// videoBoxShp.lineTo( 0, 1.125 );
		// videoBoxShp.lineTo( 0, 0 ); //close Path

		// const mesh3 = addLine( videoBoxShp, 'black' );
		// scene.add( mesh3 )

		// mesh3.rotation.x = Math.PI / 2;
		// mesh3.scale.set( 1, 1, 1);
		// mesh3.position.set( 1/2, 0, -1.125/2 );

		// function addLine( shape, color ) {
		// 	const points = shape.getPoints();
		// 	const lineGeo = new THREE.BufferGeometry().setFromPoints( points );
		// 	const lineMat = new THREE.LineBasicMaterial( { color } );
		// 	const line = new THREE.Line( lineGeo, lineMat );
		// 	return line;
		// }
		


		/* 이미지 */
		var textureLoader = new THREE.TextureLoader();

		var texture1 = textureLoader.load( 'https://Lee-hoseong.github.io/ar/cardInfo.png' );

		var imageGeo = new THREE.PlaneGeometry( 2.571429, 1.446428 );
		var imageMat = new THREE.MeshBasicMaterial( { } );
		var imageMesh = new THREE.Mesh( imageGeo, imageMat );

		imageMesh.material.map = texture1;

		imageMesh.rotation.x = -Math.PI / 2;
		imageMesh.position.set( -0.714286, 3.0, 0 );
		scene.add( imageMesh );


		/* 비디오 */
		var videoGeo = new THREE.PlaneBufferGeometry( 2.571429, 1.446428 );
		var video = document.getElementById( 'video' );
		video.play();

		var videoTexture = new THREE.VideoTexture( video );
		videoTexture.minFilter = THREE.LinearFilter;
		videoTexture.magFilter = THREE.LinearFilter;
		videoTexture.format = THREE.RGBFormat;
		var videoMaterial = new THREE.MeshBasicMaterial( { map: videoTexture } );
		
		var videoMesh = new THREE.Mesh( videoGeo, videoMaterial );

		videoMesh.rotation.x = -Math.PI/2;
		videoMesh.position.set( -0.714286, 3.0, 1.8);

		scene.add( videoMesh );	


		/* 모델로더 */
		// var threeGLTFLoader = new THREE.GLTFLoader();
		// var model;

		// threeGLTFLoader.load("https://Lee-hoseong.github.io/model/arch.glb", function (gltf) {
		// 	model = gltf.scene;

		// 	var newMaterial = new THREE.MeshNormalMaterial({
		// 		side: THREE.DoubleSide, 
		// 		// color : 0x2FA1D6,
		// 		opacity : 0.8, 
		// 		transparent: true,
		// 	});

		// 	model.traverse((o) => {
		// 		if (o.isMesh) o.material = newMaterial;
		// 	});

		// 	model.scale.set( 0.2, 0.2, 0.2);
		// 	model.position.set( 2, 0, 0 );

		// 	scene.add( model );
		// })
		

		/* 텍스트 */
		// const labelGeometry = new THREE.PlaneGeometry(1, 1);

		// function makeLabelCanvas( size, name, color ) {
		// 	const borderSize = 2;
		// 	const ctx = document.createElement('canvas').getContext('2d');
		// 	const font =  `${ size }px bold sans-serif`;
		// 	ctx.font = font;

		// 	// 이름의 길이를 예측합니다.
		// 	const doubleBorderSize = borderSize * 2;
		// 	const width = ctx.measureText(name).width + doubleBorderSize;
		// 	const height = size + doubleBorderSize;
		// 	ctx.canvas.width = width;
		// 	ctx.canvas.height = height;
			
		// 	// 캔버스 크기를 바꿨을 때 폰트를 다시 설정해줘야 합니다.
		// 	ctx.font = font;
		// 	ctx.textBaseline = 'top';
			
		// 	ctx.fillStyle = 'rgba(255, 255, 255, 0.0 )';
		// 	ctx.fillRect(0, 0, width, height);
		// 	ctx.fillStyle = color
		// 	ctx.fillText(name, borderSize, borderSize);
			
		// 	return ctx.canvas;
		// }

		// function addLabel( color, name ) {
		// 	const textCanvas = makeLabelCanvas( 50, name, color );
		// 	const texture = new THREE.CanvasTexture( textCanvas );

		// 	// 텍스처용 캔버스는 2D이므로 픽셀이 모자를 경우 대략적으로 필터링도록 설정
		// 	texture.minFilter = THREE.LinearFilter;
		// 	texture.wrapS = THREE.ClampToEdgeWrapping;
		// 	texture.wrapT = THREE.ClampToEdgeWrapping;

		// 	const labelMaterial = new THREE.MeshBasicMaterial({
		// 		map: texture,
		// 		side: THREE.DoubleSide,
		// 		transparent: true,
		// 	} );

		// 	// 라벨의 크기를 조정 : 해상도를 높임
		// 	const label = new THREE.Mesh( labelGeometry, labelMaterial );
		// 	const labelBaseScale = 0.01;
		// 	label.scale.x = textCanvas.width  * labelBaseScale;
		// 	label.scale.y = textCanvas.height * labelBaseScale;

		// 	return label
		// }

		// const label1 = addLabel( '#2FA1D6' , '기술개발센터' );
		
		// label1.rotation.x = -Math.PI / 2;
		// label1.position.set( 1.5, 0, 0 ); // 오른쪽으로 : 0.5, 아래로 : -0.3

		// scene.add( label1 );		
		
		
		onRenderFcts.push(function(delta){
			mesh2.rotation.y += Math.PI*delta
		})


		//////////////////////////////////////////////////////////////////////////////////
		//		render the whole thing on the page
		//////////////////////////////////////////////////////////////////////////////////

		// render the scene
		onRenderFcts.push(function(){
			renderer.render( scene, camera );
		})

		// run the rendering loop
		var lastTimeMsec= null
		requestAnimationFrame(function animate(nowMsec){
			// keep looping
			requestAnimationFrame( animate );
			
			// measure time
			lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
			var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
			lastTimeMsec	= nowMsec

			// call each update function
			onRenderFcts.forEach(function(onRenderFct){
				onRenderFct(deltaMsec/1000, nowMsec/1000)
			})
		})
	</script>
</body>
